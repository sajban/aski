(defun macroexpand (V11009) (let Fs (map (lambda X (tl X)) (value *macros*)) (shen.macroexpand-h V11009 Fs Fs)))

(defun shen.macroexpand-h (V11018 V11019 V11020) (cond ((= () V11019) V11018) ((cons? V11019) (let Y (shen.walk (hd V11019) V11018) (if (= V11018 Y) (shen.macroexpand-h V11018 (tl V11019) V11020) (shen.macroexpand-h Y V11020 V11020)))) (true (simple-error "implementation error in shen.macroexpand-h"))))

(defun shen.walk (V11021 V11022) (cond ((cons? V11022) (V11021 (map (lambda Z (shen.walk V11021 Z)) V11022))) (true (V11021 V11022))))

(defun shen.defmacro-macro (V11023) (cond ((and (cons? V11023) (and (= defmacro (hd V11023)) (cons? (tl V11023)))) (let Default (cons (protect X) (cons -> (cons (protect X) ()))) (let Def (eval (cons define (cons (hd (tl V11023)) (append (tl (tl V11023)) Default)))) (let Record (shen.record-macro (hd (tl V11023)) (fn (hd (tl V11023))) (hd (tl V11023)))))) (true V11023)))

(defun shen.u!-macro (V11024) (cond ((and (cons? V11024) (and (= u! (hd V11024)) (and (cons? (tl V11024)) (= () (tl (tl V11024)))))) (cons protect (cons (shen.make-uppercase (hd (tl V11024))) ()))) (true V11024)))

(defun shen.make-uppercase (V11025) (intern (shen.mu-h (str V11025))))

(defun shen.mu-h (V11026) (cond ((= "" V11026) "") ((shen.+string? V11026) (let ASCII (string->n (hdstr V11026)) (let ASCII-32 (- ASCII 32) (let Upper (if (and (>= ASCII 97) (<= ASCII 122)) (n->string ASCII-32) (hdstr V11026)) (@s Upper (shen.mu-h (tlstr V11026))))))) (true (shen.f-error shen.mu-h))))

(defun shen.record-macro (V11027 V11028) (set *macros* (shen.update-assoc V11027 V11028 (value *macros*))))

(defun shen.update-assoc (V11038 V11039 V11040) (cond ((= () V11040) (cons (cons V11038 V11039) ())) ((and (cons? V11040) (and (cons? (hd V11040)) (= V11038 (hd (hd V11040))))) (cons (cons (hd (hd V11040)) V11039) (tl V11040))) ((cons? V11040) (cons (hd V11040) (shen.update-assoc V11038 V11039 (tl V11040)))) (true (simple-error "implementation error in shen.update-assoc"))))

(defun shen.error-macro (V11041) (cond ((and (cons? V11041) (and (= error (hd V11041)) (cons? (tl V11041)))) (cons simple-error (cons (shen.mkstr (hd (tl V11041)) (tl (tl V11041))) ()))) (true V11041)))

(defun shen.output-macro (V11042) (cond ((and (cons? V11042) (and (= output (hd V11042)) (cons? (tl V11042)))) (cons pr (cons (shen.mkstr (hd (tl V11042)) (tl (tl V11042))) (cons (cons stoutput ()) ())))) ((and (cons? V11042) (and (= pr (hd V11042)) (and (cons? (tl V11042)) (= () (tl (tl V11042)))))) (cons pr (cons (hd (tl V11042)) (cons (cons stoutput ()) ())))) (true V11042)))

(defun shen.make-string-macro (V11043) (cond ((and (cons? V11043) (and (= make-string (hd V11043)) (cons? (tl V11043)))) (shen.mkstr (hd (tl V11043)) (tl (tl V11043)))) (true V11043)))

(defun shen.input-macro (V11044) (cond ((and (cons? V11044) (and (= lineread (hd V11044)) (= () (tl V11044)))) (cons lineread (cons (cons stinput ()) ()))) ((and (cons? V11044) (and (= input (hd V11044)) (= () (tl V11044)))) (cons input (cons (cons stinput ()) ()))) ((and (cons? V11044) (and (= read (hd V11044)) (= () (tl V11044)))) (cons read (cons (cons stinput ()) ()))) ((and (cons? V11044) (and (= input+ (hd V11044)) (and (cons? (tl V11044)) (= () (tl (tl V11044)))))) (cons input+ (cons (hd (tl V11044)) (cons (cons stinput ()) ())))) ((and (cons? V11044) (and (= read-byte (hd V11044)) (= () (tl V11044)))) (if (shen.char-stinput? (stinput)) (cons string->n (cons (cons shen.read-unit-string (cons (cons stinput ()) ())) ())) (cons read-byte (cons (cons stinput ()) ())))) (true V11044)))

(defun shen.defcc-macro (V11045) (cond ((and (cons? V11045) (= defcc (hd V11045))) (shen.yacc->shen (tl V11045))) (true V11045)))

(defun shen.prolog-macro (V11046) (cond ((and (cons? V11046) (= prolog? (hd V11046))) (shen.call-prolog (tl V11046))) (true V11046)))

(defun shen.call-prolog (V11047) (let Bindings (cons shen.reset-prolog-vector ()) (let Lock (cons @v (cons true (cons 0 (cons (cons vector (cons 0 ())) ())))) (let Key 0 (let Continuation (cons freeze (cons true ())) (let CLiterals (compile (lambda X (shen.<body> X)) V11047) (let Received (shen.received V11047) (let B (gensym (protect V)) (let L (gensym (protect L)) (let K (gensym (protect K)) (let C (gensym (protect C)) (let Lambda (cons lambda (cons B (cons (cons lambda (cons L (cons (cons lambda (cons K (cons (cons lambda (cons C (cons (shen.continue Received CLiterals B L K C) ()))) ()))) ()))) ()))) (cons Lambda (cons Bindings (cons Lock (cons Key (cons Continuation ())))))))))))))))))

(defun shen.received (V11050) (cond ((and (cons? V11050) (and (= receive (hd V11050)) (and (cons? (tl V11050)) (= () (tl (tl V11050)))))) (tl V11050)) ((cons? V11050) (union (shen.received (hd V11050)) (shen.received (tl V11050)))) (true ())))

(defun shen.reset-prolog-vector () (address-> (value shen.*prolog-vector*) 1 2))

(defun receive (V11051) V11051)

(defun shen.defprolog-macro (V11052) (cond ((and (cons? V11052) (and (= defprolog (hd V11052)) (cons? (tl V11052)))) (shen.compile-prolog (hd (tl V11052)) (tl (tl V11052)))) (true V11052)))

(defun shen.datatype-macro (V11053) (cond ((and (cons? V11053) (and (= datatype (hd V11053)) (cons? (tl V11053)))) (let D (shen.intern-type (hd (tl V11053))) (let Compile (compile (lambda X (shen.<datatype> X)) (cons D (tl (tl V11053)))) D))) (true V11053)))

(defun shen.rcons_form (V11054) (cond ((cons? V11054) (cons cons (cons (shen.rcons_form (hd V11054)) (cons (shen.rcons_form (tl V11054)) ())))) (true V11054)))

(defun shen.intern-type (V11055) (intern (cn (str V11055) "#type")))

(defun shen.@s-macro (V11056) (cond ((and (cons? V11056) (and (= @s (hd V11056)) (and (cons? (tl V11056)) (and (cons? (tl (tl V11056))) (cons? (tl (tl (tl V11056)))))))) (cons @s (cons (hd (tl V11056)) (cons (shen.@s-macro (cons @s (tl (tl V11056)))) ())))) ((and (cons? V11056) (and (= @s (hd V11056)) (and (cons? (tl V11056)) (and (cons? (tl (tl V11056))) (and (= () (tl (tl (tl V11056)))) (string? (hd (tl V11056)))))))) (let E (explode (hd (tl V11056))) (if (> (length E) 1) (shen.@s-macro (cons @s (append E (tl (tl V11056))))) V11056))) (true V11056)))

(defun shen.synonyms-macro (V11057) (cond ((and (cons? V11057) (= synonyms (hd V11057))) (shen.synonyms-h (append (tl V11057) (value shen.*synonyms*)))) (true V11057)))

(defun shen.synonyms-h (V11058) (let CurryTypes (map (lambda X (shen.curry-type X)) V11058) (let Eval (eval (cons define (cons shen.demod (shen.compile-synonyms CurryTypes)))) synonyms)))

(defun shen.compile-synonyms (V11061) (cond ((= () V11061) (let X (gensym (protect X)) (cons X (cons -> (cons X ()))))) ((and (cons? V11061) (cons? (tl V11061))) (cons (shen.rcons_form (hd V11061)) (cons -> (cons (shen.rcons_form (hd (tl V11061))) (shen.compile-synonyms (tl (tl V11061))))))) (true (simple-error "synonyms requires an even number of arguments
"))))

(defun shen.nl-macro (V11062) (cond ((and (cons? V11062) (and (= nl (hd V11062)) (= () (tl V11062)))) (cons nl (cons 1 ()))) (true V11062)))

(defun shen.assoc-macro (V11063) (cond ((and (cons? V11063) (and (cons? (tl V11063)) (and (cons? (tl (tl V11063))) (and (cons? (tl (tl (tl V11063)))) (element? (hd V11063) (cons @p (cons @v (cons append (cons and (cons or (cons + (cons * (cons do ()))))))))))))) (cons (hd V11063) (cons (hd (tl V11063)) (cons (shen.assoc-macro (cons (hd V11063) (tl (tl V11063)))) ())))) (true V11063)))

(defun shen.let-macro (V11064) (cond ((and (cons? V11064) (and (= let (hd V11064)) (and (cons? (tl V11064)) (and (cons? (tl (tl V11064))) (and (cons? (tl (tl (tl V11064)))) (cons? (tl (tl (tl (tl V11064)))))))))) (cons let (cons (hd (tl V11064)) (cons (hd (tl (tl V11064))) (cons (shen.let-macro (cons let (tl (tl (tl V11064))))) ()))))) ((and (cons? V11064) (and (= let (hd V11064)) (and (cons? (tl V11064)) (and (cons? (tl (tl V11064))) (and (cons? (tl (tl (tl V11064)))) (= () (tl (tl (tl (tl V11064)))))))))) (if (variable? (hd (tl V11064))) V11064 (simple-error (shen.app (hd (tl V11064)) " is not a variable
" shen.s)))) (true V11064)))

(defun shen.abs-macro (V11065) (cond ((and (cons? V11065) (and (= /. (hd V11065)) (and (cons? (tl V11065)) (and (cons? (tl (tl V11065))) (cons? (tl (tl (tl V11065)))))))) (cons lambda (cons (hd (tl V11065)) (cons (shen.abs-macro (cons /. (tl (tl V11065)))) ())))) ((and (cons? V11065) (and (= /. (hd V11065)) (and (cons? (tl V11065)) (and (cons? (tl (tl V11065))) (= () (tl (tl (tl V11065)))))))) (if (variable? (hd (tl V11065))) (cons lambda (tl V11065)) (simple-error (shen.app (hd (tl V11065)) " is not a variable
" shen.s)))) (true V11065)))

(defun shen.cases-macro (V11068) (cond ((and (cons? V11068) (and (= cases (hd V11068)) (and (cons? (tl V11068)) (and (= true (hd (tl V11068))) (cons? (tl (tl V11068))))))) (hd (tl (tl V11068)))) ((and (cons? V11068) (and (= cases (hd V11068)) (and (cons? (tl V11068)) (and (cons? (tl (tl V11068))) (= () (tl (tl (tl V11068)))))))) (cons if (cons (hd (tl V11068)) (cons (hd (tl (tl V11068))) (cons (cons simple-error (cons "error: cases exhausted" ())) ()))))) ((and (cons? V11068) (and (= cases (hd V11068)) (and (cons? (tl V11068)) (cons? (tl (tl V11068)))))) (cons if (cons (hd (tl V11068)) (cons (hd (tl (tl V11068))) (cons (shen.cases-macro (cons cases (tl (tl (tl V11068))))) ()))))) ((and (cons? V11068) (and (= cases (hd V11068)) (and (cons? (tl V11068)) (= () (tl (tl V11068)))))) (simple-error "error: odd number of case elements
")) (true V11068)))

(defun shen.timer-macro (V11069) (cond ((and (cons? V11069) (and (= time (hd V11069)) (and (cons? (tl V11069)) (= () (tl (tl V11069)))))) (shen.let-macro (cons let (cons (protect Start) (cons (cons get-time (cons run ())) (cons (protect Result) (cons (hd (tl V11069)) (cons (protect Finish) (cons (cons get-time (cons run ())) (cons (protect Time) (cons (cons - (cons (protect Finish) (cons (protect Start) ()))) (cons (protect Message) (cons (cons pr (cons (cons cn (cons "
run time: " (cons (cons cn (cons (cons str (cons (protect Time) ())) (cons " secs
" ()))) ()))) (cons (cons stoutput ()) ()))) (cons (protect Result) ())))))))))))))) (true V11069)))

(defun shen.tuple-up (V11070) (cond ((cons? V11070) (cons @p (cons (hd V11070) (cons (shen.tuple-up (tl V11070)) ())))) (true V11070)))

(defun shen.put/get-macro (V11071) (cond ((and (cons? V11071) (and (= put (hd V11071)) (and (cons? (tl V11071)) (and (cons? (tl (tl V11071))) (and (cons? (tl (tl (tl V11071)))) (= () (tl (tl (tl (tl V11071)))))))))) (cons put (cons (hd (tl V11071)) (cons (hd (tl (tl V11071))) (cons (hd (tl (tl (tl V11071)))) (cons (cons value (cons *property-vector* ())) ())))))) ((and (cons? V11071) (and (= get (hd V11071)) (and (cons? (tl V11071)) (and (cons? (tl (tl V11071))) (= () (tl (tl (tl V11071)))))))) (cons get (cons (hd (tl V11071)) (cons (hd (tl (tl V11071))) (cons (cons value (cons *property-vector* ())) ()))))) ((and (cons? V11071) (and (= unput (hd V11071)) (and (cons? (tl V11071)) (and (cons? (tl (tl V11071))) (= () (tl (tl (tl V11071)))))))) (cons unput (cons (hd (tl V11071)) (cons (hd (tl (tl V11071))) (cons (cons value (cons *property-vector* ())) ()))))) (true V11071)))

(defun undefmacro (V11072) (do (set *macros* (remove (assoc V11072 (value *macros*)) (value *macros*))) V11072))

