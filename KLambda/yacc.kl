(defun compile (V6244 V6245) (let Compile (V6244 (cons V6245 (cons shen.no-action ()))) (if (shen.parsed? Compile) (shen.objectcode Compile) (simple-error "parse failure
"))))

(defun shen.parsed? (V6250) (cond ((shen.parse-failure? V6250) false) ((and (cons? V6250) (cons? (hd V6250))) (do (set shen.*residue* (hd V6250)) (simple-error (cn "syntax error here: " (shen.app (hd V6250) "
 ..." shen.r))))) (true true)))

(defun shen.parse-failure? (V6251) (= V6251 (fail)))

(defun shen.objectcode (V6254) (cond ((and (cons? V6254) (and (cons? (tl V6254)) (= () (tl (tl V6254))))) (hd (tl V6254))) (true (simple-error (shen.app V6254 " is not a YACC stream
" shen.s)))))

(defun shen.yacc->shen (V6255) (compile (lambda X (shen.<yacc> X)) V6255))

(defun shen.<yacc> (V6256) (let Result (if (shen.non-empty-stream? V6256) (let F (shen.hds V6256) (let News6137 (shen.tls V6256) (let Parseshen.<yaccsig> (shen.<yaccsig> News6137) (if (shen.parse-failure? Parseshen.<yaccsig>) (shen.parse-failure) (let Parseshen.<c-rules> (shen.<c-rules> Parseshen.<yaccsig>) (if (shen.parse-failure? Parseshen.<c-rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<c-rules>) (let Stream (gensym S) (let Def (append (cons define (cons F ())) (append (shen.<-out Parseshen.<yaccsig>) (cons Stream (cons -> (cons (shen.c-rules->shen (shen.<-out Parseshen.<yaccsig>) Stream (shen.<-out Parseshen.<c-rules>)) ()))))) Def))))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<yaccsig> (V6257) (let Result (if (shen.non-empty-stream? V6257) (let LC (shen.hds V6257) (let News6139 (shen.tls V6257) (if (shen.ccons? News6139) (let SynCons (shen.comb (shen.hds News6139) (shen.<-out News6139)) (if (shen.=hd? SynCons list) (let News6140 (shen.tls SynCons) (if (shen.non-empty-stream? News6140) (let A (shen.hds News6140) (let News6141 (shen.tls News6140) (let Parseshen.<end> (shen.<end> News6141) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (if (shen.=hd? (shen.tlstream News6139) ==>) (let News6142 (shen.tls (shen.tlstream News6139)) (if (shen.non-empty-stream? News6142) (let B (shen.hds News6142) (let News6143 (shen.tls News6142) (if (shen.non-empty-stream? News6143) (let RC (shen.hds News6143) (let News6144 (shen.tls News6143) (if (and (= { LC) (= } RC)) (shen.comb (shen.in-> News6144) (let C (gensym C) (cons { (cons (cons str (cons (cons list (cons A ())) (cons C ()))) (cons --> (cons (cons str (cons (cons list (cons A ())) (cons B ()))) (cons } ()))))))) (shen.parse-failure)))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))))) (shen.parse-failure))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V6257) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<c-rules> (V6258) (let Result (let Parseshen.<c-rule> (shen.<c-rule> V6258) (if (shen.parse-failure? Parseshen.<c-rule>) (shen.parse-failure) (let Parseshen.<c-rules> (shen.<c-rules> Parseshen.<c-rule>) (if (shen.parse-failure? Parseshen.<c-rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<c-rules>) (cons (shen.<-out Parseshen.<c-rule>) (shen.<-out Parseshen.<c-rules>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<!> (<!> V6258) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (shen.comb (shen.in-> Parse<!>) (if (empty? (shen.<-out Parse<!>)) () (simple-error (cn "YACC syntax error here:
 " (shen.app (shen.<-out Parse<!>) "
 ..." shen.r))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<c-rule> (V6259) (let Result (let Parseshen.<syntax> (shen.<syntax> V6259) (if (shen.parse-failure? Parseshen.<syntax>) (shen.parse-failure) (let Parseshen.<semantics> (shen.<semantics> Parseshen.<syntax>) (if (shen.parse-failure? Parseshen.<semantics>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<semantics>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sc>) (cons (shen.<-out Parseshen.<syntax>) (cons (shen.<-out Parseshen.<semantics>) ()))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<syntax> (shen.<syntax> V6259) (if (shen.parse-failure? Parseshen.<syntax>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<syntax>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sc>) (cons (shen.<-out Parseshen.<syntax>) (cons (shen.autocomplete (shen.<-out Parseshen.<syntax>)) ()))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.autocomplete (V6260) (cond ((and (cons? V6260) (and (= () (tl V6260)) (shen.non-terminal? (hd V6260)))) (hd V6260)) ((and (cons? V6260) (shen.non-terminal? (hd V6260))) (cons append (cons (hd V6260) (cons (shen.autocomplete (tl V6260)) ())))) ((cons? V6260) (cons cons (cons (shen.autocomplete (hd V6260)) (cons (shen.autocomplete (tl V6260)) ())))) (true V6260)))

(defun shen.non-terminal? (V6261) (and (symbol? V6261) (let Explode (explode V6261) (compile (lambda X (shen.<non-terminal?> X)) Explode))))

(defun shen.<non-terminal?> (V6262) (let Result (let Parseshen.<packagenames> (shen.<packagenames> V6262) (if (shen.parse-failure? Parseshen.<packagenames>) (shen.parse-failure) (let Parseshen.<non-terminal-name> (shen.<non-terminal-name> Parseshen.<packagenames>) (if (shen.parse-failure? Parseshen.<non-terminal-name>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<non-terminal-name>) true))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<non-terminal-name> (shen.<non-terminal-name> V6262) (if (shen.parse-failure? Parseshen.<non-terminal-name>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<non-terminal-name>) true))) (if (shen.parse-failure? Result) (let Result (let Parse<!> (<!> V6262) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (shen.comb (shen.in-> Parse<!>) false))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<packagenames> (V6263) (let Result (let Parseshen.<packagename> (shen.<packagename> V6263) (if (shen.parse-failure? Parseshen.<packagename>) (shen.parse-failure) (if (shen.=hd? Parseshen.<packagename> ".") (let News6149 (shen.tls Parseshen.<packagename>) (let Parseshen.<packagenames> (shen.<packagenames> News6149) (if (shen.parse-failure? Parseshen.<packagenames>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<packagenames>) shen.skip)))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<packagename> (shen.<packagename> V6263) (if (shen.parse-failure? Parseshen.<packagename>) (shen.parse-failure) (if (shen.=hd? Parseshen.<packagename> ".") (let News6150 (shen.tls Parseshen.<packagename>) (shen.comb (shen.in-> News6150) shen.skip)) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<packagename> (V6264) (let Result (let Parseshen.<packagechar> (shen.<packagechar> V6264) (if (shen.parse-failure? Parseshen.<packagechar>) (shen.parse-failure) (let Parseshen.<packagename> (shen.<packagename> Parseshen.<packagechar>) (if (shen.parse-failure? Parseshen.<packagename>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<packagename>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V6264) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<packagechar> (V6265) (let Result (if (shen.non-empty-stream? V6265) (let X (shen.hds V6265) (let News6153 (shen.tls V6265) (if (not (= X ".")) (shen.comb (shen.in-> News6153) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<non-terminal-name> (V6266) (let Result (if (shen.=hd? V6266 "<") (let News6155 (shen.tls V6266) (let Parse<!> (<!> News6155) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (if (let Reverse (reverse (shen.<-out Parse<!>)) (and (cons? Reverse) (= (hd Reverse) ">"))) (shen.comb (shen.in-> Parse<!>) shen.skip) (shen.parse-failure))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.semicolon? (V6267) (= V6267 (intern ";")))

(defun shen.<colon-equal> (V6268) (let Result (if (shen.non-empty-stream? V6268) (let X (shen.hds V6268) (let News6157 (shen.tls V6268) (if (shen.colon-equal? X) (shen.comb (shen.in-> News6157) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.colon-equal? (V6269) (= (intern ":=") V6269))

(defun shen.<syntax> (V6270) (let Result (let Parseshen.<syntax-item> (shen.<syntax-item> V6270) (if (shen.parse-failure? Parseshen.<syntax-item>) (shen.parse-failure) (let Parseshen.<syntax> (shen.<syntax> Parseshen.<syntax-item>) (if (shen.parse-failure? Parseshen.<syntax>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<syntax>) (cons (shen.<-out Parseshen.<syntax-item>) (shen.<-out Parseshen.<syntax>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<syntax-item> (shen.<syntax-item> V6270) (if (shen.parse-failure? Parseshen.<syntax-item>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<syntax-item>) (cons (shen.<-out Parseshen.<syntax-item>) ())))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<syntax-item> (V6271) (let Result (if (shen.non-empty-stream? V6271) (let X (shen.hds V6271) (let News6160 (shen.tls V6271) (if (shen.syntax-item? X) (shen.comb (shen.in-> News6160) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.syntax-item? (V6274) (cond ((shen.colon-equal? V6274) false) ((shen.semicolon? V6274) false) ((atom? V6274) true) ((and (cons? V6274) (and (= cons (hd V6274)) (and (cons? (tl V6274)) (and (cons? (tl (tl V6274))) (= () (tl (tl (tl V6274)))))))) (and (shen.syntax-item? (hd (tl V6274))) (shen.syntax-item? (hd (tl (tl V6274)))))) (true false)))

(defun shen.<semantics> (V6275) (let Result (let Parseshen.<colon-equal> (shen.<colon-equal> V6275) (if (shen.parse-failure? Parseshen.<colon-equal>) (shen.parse-failure) (if (shen.non-empty-stream? Parseshen.<colon-equal>) (let Semantics (shen.hds Parseshen.<colon-equal>) (let News6162 (shen.tls Parseshen.<colon-equal>) (if (shen.=hd? News6162 where) (let News6163 (shen.tls News6162) (if (shen.non-empty-stream? News6163) (let Guard (shen.hds News6163) (let News6164 (shen.tls News6163) (if (not (shen.semicolon? Semantics)) (shen.comb (shen.in-> News6164) (cons where (cons Guard (cons Semantics ())))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon-equal> (shen.<colon-equal> V6275) (if (shen.parse-failure? Parseshen.<colon-equal>) (shen.parse-failure) (if (shen.non-empty-stream? Parseshen.<colon-equal>) (let Semantics (shen.hds Parseshen.<colon-equal>) (let News6165 (shen.tls Parseshen.<colon-equal>) (if (not (shen.semicolon? Semantics)) (shen.comb (shen.in-> News6165) Semantics) (shen.parse-failure)))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.c-rules->shen (V6284 V6285 V6286) (cond ((= () V6286) (cons shen.parse-failure ())) ((cons? V6286) (shen.combine-c-code (shen.c-rule->shen V6284 (hd V6286) V6285) (shen.c-rules->shen V6284 V6285 (tl V6286)))) (true (simple-error "implementation error in shen.c-rules->shen
"))))

(defun shen.parse-failure () (fail))

(defun shen.combine-c-code (V6287 V6288) (cons let (cons Result (cons V6287 (cons (cons if (cons (cons shen.parse-failure? (cons Result ())) (cons V6288 (cons Result ())))) ())))))

(defun shen.c-rule->shen (V6295 V6296 V6297) (cond ((and (cons? V6296) (and (cons? (tl V6296)) (= () (tl (tl V6296))))) (shen.yacc-syntax V6295 V6297 (hd V6296) (hd (tl V6296)))) (true (simple-error "implementation error in shen.c-rule->shen
"))))

(defun shen.yacc-syntax (V6306 V6307 V6308 V6309) (cond ((and (= () V6308) (and (cons? V6309) (and (= where (hd V6309)) (and (cons? (tl V6309)) (and (cons? (tl (tl V6309))) (= () (tl (tl (tl V6309))))))))) (cons if (cons (shen.process-yacc-semantics (hd (tl V6309))) (cons (shen.yacc-syntax V6306 V6307 () (hd (tl (tl V6309)))) (cons (cons shen.parse-failure ()) ()))))) ((= () V6308) (shen.yacc-semantics V6306 V6307 V6309)) ((cons? V6308) (if (shen.non-terminal? (hd V6308)) (shen.non-terminalcode V6306 V6307 (hd V6308) (tl V6308) V6309) (if (variable? (hd V6308)) (shen.variablecode V6306 V6307 (hd V6308) (tl V6308) V6309) (if (= _ (hd V6308)) (shen.wildcardcode V6306 V6307 (hd V6308) (tl V6308) V6309) (if (atom? (hd V6308)) (shen.terminalcode V6306 V6307 (hd V6308) (tl V6308) V6309) (if (cons? (hd V6308)) (shen.conscode V6306 V6307 (hd V6308) (tl V6308) V6309) (simple-error "implementation error in shen.yacc-syntax
"))))))) (true (simple-error "implementation error in shen.yacc-syntax
"))))

(defun shen.non-terminalcode (V6310 V6311 V6312 V6313 V6314) (let ApplyNonTerminal (concat Parse V6312) (cons let (cons ApplyNonTerminal (cons (cons V6312 (cons V6311 ())) (cons (cons if (cons (cons shen.parse-failure? (cons ApplyNonTerminal ())) (cons (cons shen.parse-failure ()) (cons (shen.yacc-syntax V6310 ApplyNonTerminal V6313 V6314) ())))) ()))))))

(defun shen.variablecode (V6315 V6316 V6317 V6318 V6319) (let NewStream (gensym News) (cons if (cons (cons shen.non-empty-stream? (cons V6316 ())) (cons (cons let (cons V6317 (cons (cons shen.hds (cons V6316 ())) (cons NewStream (cons (cons shen.tls (cons V6316 ())) (cons (shen.yacc-syntax V6315 NewStream V6318 V6319) ())))))) (cons (cons shen.parse-failure ()) ()))))))

(defun shen.wildcardcode (V6320 V6321 V6322 V6323 V6324) (let NewStream (gensym News) (cons if (cons (cons shen.non-empty-stream? (cons V6321 ())) (cons (cons let (cons NewStream (cons (cons shen.tls (cons V6321 ())) (cons (shen.yacc-syntax V6320 NewStream V6323 V6324) ())))) (cons (cons shen.parse-failure ()) ()))))))

(defun shen.terminalcode (V6325 V6326 V6327 V6328 V6329) (let NewStream (gensym News) (cons if (cons (cons shen.=hd? (cons V6326 (cons V6327 ()))) (cons (cons let (cons NewStream (cons (cons shen.tls (cons V6326 ())) (cons (shen.yacc-syntax V6325 NewStream V6328 V6329) ())))) (cons (cons shen.parse-failure ()) ()))))))

(defun shen.conscode (V6330 V6331 V6332 V6333 V6334) (cons if (cons (cons shen.ccons? (cons V6331 ())) (cons (cons let (cons SynCons (cons (cons shen.comb (cons (cons shen.hds (cons V6331 ())) (cons (cons shen.<-out (cons V6331 ())) ()))) (cons (shen.yacc-syntax V6330 SynCons (append (shen.decons V6332) (cons shen.<end> ())) (cons shen.pushsemantics (cons (cons shen.tlstream (cons V6331 ())) (cons V6333 (cons V6334 ()))))) ())))) (cons (cons shen.parse-failure ()) ())))))

(defun shen.decons (V6335) (cond ((and (cons? V6335) (and (= cons (hd V6335)) (and (cons? (tl V6335)) (and (cons? (tl (tl V6335))) (= () (tl (tl (tl V6335)))))))) (cons (hd (tl V6335)) (shen.decons (hd (tl (tl V6335)))))) (true V6335)))

(defun shen.ccons? (V6342) (cond ((and (cons? V6342) (and (cons? (hd V6342)) (and (cons? (tl V6342)) (= () (tl (tl V6342)))))) (cons? (hd (hd V6342)))) (true false)))

(defun shen.non-empty-stream? (V6351) (cond ((and (cons? V6351) (cons? (hd V6351))) true) (true false)))

(defun shen.hds (V6352) (hd (hd V6352)))

(defun shen.hdstream (V6357) (cond ((and (cons? V6357) (and (cons? (hd V6357)) (and (cons? (tl V6357)) (= () (tl (tl V6357)))))) (cons (hd (hd V6357)) (tl V6357))) (true (simple-error "implementation error in shen.hdstream
"))))

(defun shen.comb (V6358 V6359) (cons V6358 (cons V6359 ())))

(defun shen.tlstream (V6364) (cond ((and (cons? V6364) (and (cons? (hd V6364)) (and (cons? (tl V6364)) (= () (tl (tl V6364)))))) (cons (tl (hd V6364)) (tl V6364))) (true (simple-error "implementation error in shen.tlstream
"))))

(defun shen.=hd? (V6374 V6375) (cond ((and (cons? V6374) (and (cons? (hd V6374)) (= (hd (hd V6374)) V6375))) true) (true false)))

(defun shen.tls (V6380) (cond ((and (cons? V6380) (and (cons? (hd V6380)) (and (cons? (tl V6380)) (= () (tl (tl V6380)))))) (cons (tl (hd V6380)) (tl V6380))) (true (simple-error "implementation error in shen.tls
"))))

(defun shen.yacc-semantics (V6383 V6384 V6385) (cond ((and (cons? V6385) (and (= shen.pushsemantics (hd V6385)) (and (cons? (tl V6385)) (and (cons? (tl (tl V6385))) (and (cons? (tl (tl (tl V6385)))) (= () (tl (tl (tl (tl V6385)))))))))) (shen.yacc-syntax V6383 (hd (tl V6385)) (hd (tl (tl V6385))) (hd (tl (tl (tl V6385)))))) (true (let Process (shen.process-yacc-semantics V6385) (let Annotate (shen.use-type-info V6383 Process) (cons shen.comb (cons (cons shen.in-> (cons V6384 ())) (cons Annotate ()))))))))

(defun shen.use-type-info (V6389 V6390) (cond ((and (cons? V6389) (and (= { (hd V6389)) (and (cons? (tl V6389)) (and (cons? (hd (tl V6389))) (and (= str (hd (hd (tl V6389)))) (and (cons? (tl (hd (tl V6389)))) (and (cons? (hd (tl (hd (tl V6389))))) (and (= list (hd (hd (tl (hd (tl V6389)))))) (and (cons? (tl (hd (tl (hd (tl V6389)))))) (and (= () (tl (tl (hd (tl (hd (tl V6389))))))) (and (cons? (tl (tl (hd (tl V6389))))) (and (= () (tl (tl (tl (hd (tl V6389)))))) (and (cons? (tl (tl V6389))) (and (= --> (hd (tl (tl V6389)))) (and (cons? (tl (tl (tl V6389)))) (and (cons? (hd (tl (tl (tl V6389))))) (and (= str (hd (hd (tl (tl (tl V6389)))))) (and (cons? (tl (hd (tl (tl (tl V6389)))))) (and (cons? (hd (tl (hd (tl (tl (tl V6389))))))) (and (= list (hd (hd (tl (hd (tl (tl (tl V6389)))))))) (and (cons? (tl (hd (tl (hd (tl (tl (tl V6389)))))))) (and (= () (tl (tl (hd (tl (hd (tl (tl (tl V6389))))))))) (and (cons? (tl (tl (hd (tl (tl (tl V6389))))))) (and (= () (tl (tl (tl (hd (tl (tl (tl V6389)))))))) (and (cons? (tl (tl (tl (tl V6389))))) (and (= } (hd (tl (tl (tl (tl V6389)))))) (and (= () (tl (tl (tl (tl (tl V6389)))))) (= (hd (tl (hd (tl (hd (tl V6389)))))) (hd (tl (hd (tl (hd (tl (tl (tl V6389)))))))))))))))))))))))))))))))))))) (cons type (cons V6390 (tl (tl (hd (tl (tl (tl V6389))))))))) (true V6390)))

(defun shen.process-yacc-semantics (V6391) (cond ((cons? V6391) (map (lambda Z (shen.process-yacc-semantics Z)) V6391)) ((shen.non-terminal? V6391) (cons shen.<-out (cons (concat Parse V6391) ()))) (true V6391)))

(defun shen.<-out (V6396) (cond ((and (cons? V6396) (and (cons? (tl V6396)) (= () (tl (tl V6396))))) (hd (tl V6396))) (true (simple-error "implementation error in shen.<-out
"))))

(defun shen.in-> (V6401) (cond ((and (cons? V6401) (and (cons? (tl V6401)) (= () (tl (tl V6401))))) (hd V6401)) (true (simple-error "implementation error in shen.in->
"))))

(defun <!> (V6406) (cond ((and (cons? V6406) (and (cons? (tl V6406)) (= () (tl (tl V6406))))) (cons () (cons (hd V6406) ()))) (true (simple-error "implementation error in <!>
"))))

(defun <e> (V6411) (cond ((and (cons? V6411) (and (cons? (tl V6411)) (= () (tl (tl V6411))))) (cons (hd V6411) (cons () ()))) (true (simple-error "implementation error in <e>
"))))

(defun shen.<end> (V6414) (cond ((and (cons? V6414) (and (= () (hd V6414)) (and (cons? (tl V6414)) (= () (tl (tl V6414)))))) V6414) (true (shen.parse-failure))))

