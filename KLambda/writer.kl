(defun print (V9818) (let String (shen.insert V9818 "~S") (let Print (pr String (stoutput)) V9818)))

(defun pr (V9819 V9820) (if (value *hush*) V9819 (if (shen.char-stoutput? V9820) (shen.write-string V9819 V9820) (shen.write-chars V9819 V9820 (shen.string->byte V9819 0) 1))))

(defun shen.string->byte (V9821 V9822) (trap-error (string->n (pos V9821 V9822)) (lambda E shen.eos)))

(defun shen.write-chars (V9823 V9824 V9825 V9826) (cond ((= shen.eos V9825) V9823) (true (shen.write-chars V9823 V9824 (do (write-byte V9825 V9824) (shen.string->byte V9823 V9826)) (+ V9826 1)))))

(defun shen.mkstr (V9827 V9828) (cond ((string? V9827) (shen.mkstr-l (shen.proc-nl V9827) V9828)) (true (shen.mkstr-r (cons shen.proc-nl (cons V9827 ())) V9828))))

(defun shen.mkstr-l (V9833 V9834) (cond ((= () V9834) V9833) ((cons? V9834) (shen.mkstr-l (shen.insert-l (hd V9834) V9833) (tl V9834))) (true (simple-error "implementation error in shen.mkstr-l"))))

(defun shen.insert-l (V9841 V9842) (cond ((= "" V9842) "") ((and (shen.+string? V9842) (and (= "~" (hdstr V9842)) (and (shen.+string? (tlstr V9842)) (= "A" (hdstr (tlstr V9842)))))) (cons shen.app (cons V9841 (cons (tlstr (tlstr V9842)) (cons shen.a ()))))) ((and (shen.+string? V9842) (and (= "~" (hdstr V9842)) (and (shen.+string? (tlstr V9842)) (= "R" (hdstr (tlstr V9842)))))) (cons shen.app (cons V9841 (cons (tlstr (tlstr V9842)) (cons shen.r ()))))) ((and (shen.+string? V9842) (and (= "~" (hdstr V9842)) (and (shen.+string? (tlstr V9842)) (= "S" (hdstr (tlstr V9842)))))) (cons shen.app (cons V9841 (cons (tlstr (tlstr V9842)) (cons shen.s ()))))) ((shen.+string? V9842) (shen.factor-cn (cons cn (cons (hdstr V9842) (cons (shen.insert-l V9841 (tlstr V9842)) ()))))) ((and (cons? V9842) (and (= cn (hd V9842)) (and (cons? (tl V9842)) (and (cons? (tl (tl V9842))) (= () (tl (tl (tl V9842)))))))) (cons cn (cons (hd (tl V9842)) (cons (shen.insert-l V9841 (hd (tl (tl V9842)))) ())))) ((and (cons? V9842) (and (= shen.app (hd V9842)) (and (cons? (tl V9842)) (and (cons? (tl (tl V9842))) (and (cons? (tl (tl (tl V9842)))) (= () (tl (tl (tl (tl V9842)))))))))) (cons shen.app (cons (hd (tl V9842)) (cons (shen.insert-l V9841 (hd (tl (tl V9842)))) (tl (tl (tl V9842))))))) (true (simple-error "implementation error in shen.insert-l"))))

(defun shen.factor-cn (V9843) (cond ((and (cons? V9843) (and (= cn (hd V9843)) (and (cons? (tl V9843)) (and (cons? (tl (tl V9843))) (and (cons? (hd (tl (tl V9843)))) (and (= cn (hd (hd (tl (tl V9843))))) (and (cons? (tl (hd (tl (tl V9843))))) (and (cons? (tl (tl (hd (tl (tl V9843)))))) (and (= () (tl (tl (tl (hd (tl (tl V9843))))))) (and (= () (tl (tl (tl V9843)))) (and (string? (hd (tl V9843))) (string? (hd (tl (hd (tl (tl V9843))))))))))))))))) (cons cn (cons (cn (hd (tl V9843)) (hd (tl (hd (tl (tl V9843)))))) (tl (tl (hd (tl (tl V9843)))))))) (true V9843)))

(defun shen.proc-nl (V9846) (cond ((= "" V9846) "") ((and (shen.+string? V9846) (and (= "~" (hdstr V9846)) (and (shen.+string? (tlstr V9846)) (= "%" (hdstr (tlstr V9846)))))) (cn (n->string 10) (shen.proc-nl (tlstr (tlstr V9846))))) ((shen.+string? V9846) (cn (hdstr V9846) (shen.proc-nl (tlstr V9846)))) (true (simple-error "implementation error in shen.proc-nl"))))

(defun shen.mkstr-r (V9851 V9852) (cond ((= () V9852) V9851) ((cons? V9852) (shen.mkstr-r (cons shen.insert (cons (hd V9852) (cons V9851 ()))) (tl V9852))) (true (simple-error "implementation error in shen.mkstr-r"))))

(defun shen.insert (V9853 V9854) (shen.insert-h V9853 V9854 ""))

(defun shen.insert-h (V9863 V9864 V9865) (cond ((= "" V9864) V9865) ((and (shen.+string? V9864) (and (= "~" (hdstr V9864)) (and (shen.+string? (tlstr V9864)) (= "A" (hdstr (tlstr V9864)))))) (cn V9865 (shen.app V9863 (tlstr (tlstr V9864)) shen.a))) ((and (shen.+string? V9864) (and (= "~" (hdstr V9864)) (and (shen.+string? (tlstr V9864)) (= "R" (hdstr (tlstr V9864)))))) (cn V9865 (shen.app V9863 (tlstr (tlstr V9864)) shen.r))) ((and (shen.+string? V9864) (and (= "~" (hdstr V9864)) (and (shen.+string? (tlstr V9864)) (= "S" (hdstr (tlstr V9864)))))) (cn V9865 (shen.app V9863 (tlstr (tlstr V9864)) shen.s))) ((shen.+string? V9864) (shen.insert-h V9863 (tlstr V9864) (cn V9865 (hdstr V9864)))) (true (simple-error "implementation error in shen.insert-h"))))

(defun shen.app (V9866 V9867 V9868) (cn (shen.arg->str V9866 V9868) V9867))

(defun shen.arg->str (V9872 V9873) (cond ((= V9872 (fail)) "...") ((shen.list? V9872) (shen.list->str V9872 V9873)) ((string? V9872) (shen.str->str V9872 V9873)) ((absvector? V9872) (shen.vector->str V9872 V9873)) (true (shen.atom->str V9872))))

(defun shen.list->str (V9874 V9875) (cond ((= shen.r V9875) (@s "(" (@s (shen.iter-list V9874 shen.r (shen.maxseq)) ")"))) (true (@s "[" (@s (shen.iter-list V9874 V9875 (shen.maxseq)) "]")))))

(defun shen.maxseq () (value *maximum-print-sequence-size*))

(defun shen.iter-list (V9886 V9887 V9888) (cond ((= () V9886) "") ((= 0 V9888) "... etc") ((and (cons? V9886) (= () (tl V9886))) (shen.arg->str (hd V9886) V9887)) ((cons? V9886) (@s (shen.arg->str (hd V9886) V9887) (@s " " (shen.iter-list (tl V9886) V9887 (- V9888 1))))) (true (@s "|" (@s " " (shen.arg->str V9886 V9887))))))

(defun shen.str->str (V9891 V9892) (cond ((= shen.a V9892) V9891) (true (@s (n->string 34) (@s V9891 (n->string 34))))))

(defun shen.vector->str (V9893 V9894) (if (shen.print-vector? V9893) ((fn (<-address V9893 0)) V9893) (if (vector? V9893) (@s "<" (@s (shen.iter-vector V9893 1 V9894 (shen.maxseq)) ">")) (@s "<" (@s "<" (@s (shen.iter-vector V9893 0 V9894 (shen.maxseq)) ">>"))))))

(defun shen.print-vector? (V9895) (let Zero (<-address V9895 0) (if (= Zero shen.tuple) true (if (= Zero shen.pvar) true (if (not (number? Zero)) (shen.fbound? Zero) false)))))

(defun shen.fbound? (V9896) (not (= (arity V9896) -1)))

(defun shen.tuple (V9897) (cn "(@p " (shen.app (<-address V9897 1) (cn " " (shen.app (<-address V9897 2) ")" shen.s)) shen.s)))

(defun shen.iter-vector (V9904 V9905 V9906 V9907) (cond ((= 0 V9907) "... etc") (true (let Item (trap-error (<-address V9904 V9905) (lambda E shen.out-of-bounds)) (let Next (trap-error (<-address V9904 (+ V9905 1)) (lambda E shen.out-of-bounds)) (if (= Item shen.out-of-bounds) "" (if (= Next shen.out-of-bounds) (shen.arg->str Item V9906) (@s (shen.arg->str Item V9906) (@s " " (shen.iter-vector V9904 (+ V9905 1) V9906 (- V9907 1)))))))))))

(defun shen.atom->str (V9908) (trap-error (str V9908) (lambda E (shen.funexstring))))

(defun shen.funexstring () (@s "" (@s "f" (@s "u" (@s "n" (@s "e" (@s (shen.arg->str (gensym (intern "x")) shen.a) "")))))))

(defun shen.list? (V9909) (or (empty? V9909) (cons? V9909)))

