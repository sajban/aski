(defun shen.typecheck (V12849 V12850) (let Vs (shen.extract-vars V12850) (let A* (shen.rectify-type V12850) (let Curried (shen.curry V12849) (((((lambda V12412 (lambda L12413 (lambda K12414 (lambda C12415 (let Out (shen.newpv V12412) (shen.gc V12412 (do (shen.incinfs) (shen.insert-prolog-variables (receive (shen.deref Vs V12412)) (receive (shen.deref A* V12412)) Out V12412 L12413 K12414 (freeze (shen.toplevel-forms (receive (shen.deref Curried V12412)) Out V12412 L12413 K12414 (freeze (return Out V12412 L12413 K12414 C12415)))))))))))) (shen.reset-prolog-vector)) (@v true (@v 0 (vector 0)))) 0) (freeze true))))))

(defun shen.insert-prolog-variables (V12851 V12852 V12853 V12854 V12855 V12856 V12857) (let C12424 (if (shen.unlocked? V12855) (let Tm12425 (shen.lazyderef V12851 V12854) (if (= Tm12425 ()) (do (shen.incinfs) (is! V12852 V12853 V12854 V12855 V12856 V12857)) false)) false) (if (= C12424 false) (if (shen.unlocked? V12855) (let Tm12426 (shen.lazyderef V12851 V12854) (if (cons? Tm12426) (let V (hd Tm12426) (let Vs (tl Tm12426) (let X (shen.newpv V12854) (shen.gc V12854 (do (shen.incinfs) (shen.insert-prolog-variables Vs (subst (shen.deref X V12854) V V12852) V12853 V12854 V12855 V12856 V12857)))))) false)) false) C12424)))

(defun shen.toplevel-forms (V12858 V12859 V12860 V12861 V12862 V12863) (let K12429 (+ V12862 1) (let C12433 (if (shen.unlocked? V12861) (let Tm12434 (shen.lazyderef V12858 V12860) (if (cons? Tm12434) (let Tm12435 (shen.lazyderef (hd Tm12434) V12860) (if (= Tm12435 define) (let Tm12436 (shen.lazyderef (tl Tm12434) V12860) (if (cons? Tm12436) (let F (hd Tm12436) (let X (tl Tm12436) (do (shen.incinfs) (shen.cut V12860 V12861 K12429 (freeze (shen.signal-def (value shen.*spy*) F V12860 V12861 K12429 (freeze (shen.t* (cons define (cons F X)) V12859 V12860 V12861 K12429 V12863)))))))) false)) false)) false)) false) (if (= C12433 false) (let C12437 (if (shen.unlocked? V12861) (do (shen.incinfs) (shen.system-S (cons V12858 (cons (intern ":") (cons V12859 ()))) () V12860 V12861 K12429 V12863)) false) (if (= C12437 false) (shen.unlock V12861 K12429) C12437)) C12433))))

(defun shen.signal-def (V12864 V12865 V12866 V12867 V12868 V12869) (let C12444 (if (shen.unlocked? V12867) (let Tm12445 (shen.lazyderef V12864 V12866) (if (= Tm12445 false) (do (shen.incinfs) (thaw V12869)) false)) false) (if (= C12444 false) (if (shen.unlocked? V12867) (let Tm12446 (shen.lazyderef V12864 V12866) (if (= Tm12446 true) (let ShowF (shen.newpv V12866) (shen.gc V12866 (do (shen.incinfs) (is ShowF (pr (cn "
typechecking (fn " (shen.app (shen.deref V12865 V12866) ")
" shen.a)) (stoutput)) V12866 V12867 V12868 V12869)))) false)) false) C12444)))

(defun shen.rectify-type (V12870) (shen.demodulate (shen.curry-type V12870)))

(defun shen.demodulate (V12871) (trap-error (let Demod (shen.walk (lambda Y (shen.demod Y)) V12871) (if (= Demod V12871) V12871 (shen.demodulate Demod))) (lambda E V12871)))

(defun shen.curry-type (V12872) (cond ((and (cons? V12872) (and (cons? (tl V12872)) (and (= --> (hd (tl V12872))) (and (cons? (tl (tl V12872))) (and (cons? (tl (tl (tl V12872)))) (= --> (hd (tl (tl (tl V12872)))))))))) (shen.curry-type (cons (hd V12872) (cons --> (cons (tl (tl V12872)) ()))))) ((and (cons? V12872) (and (cons? (tl V12872)) (and (= ==> (hd (tl V12872))) (and (cons? (tl (tl V12872))) (= () (tl (tl (tl V12872)))))))) (shen.curry-type (cons (cons (hd V12872) (cons * (cons (protect A) ()))) (cons --> (cons (cons (cons vector (cons boolean ())) (cons --> (cons (cons (hd V12872) (cons * (tl (tl V12872)))) ()))) ()))))) ((and (cons? V12872) (and (cons? (tl V12872)) (and (= * (hd (tl V12872))) (and (cons? (tl (tl V12872))) (and (cons? (tl (tl (tl V12872)))) (= * (hd (tl (tl (tl V12872)))))))))) (shen.curry-type (cons (hd V12872) (cons * (cons (tl (tl V12872)) ()))))) ((cons? V12872) (map (lambda Z (shen.curry-type Z)) V12872)) (true V12872)))

(defun shen.curry (V12873) (cond ((and (cons? V12873) (and (= define (hd V12873)) (cons? (tl V12873)))) V12873) ((and (cons? V12873) (and (= type (hd V12873)) (and (cons? (tl V12873)) (and (cons? (tl (tl V12873))) (= () (tl (tl (tl V12873)))))))) (cons type (cons (shen.curry (hd (tl V12873))) (tl (tl V12873))))) ((and (cons? V12873) (and (= input+ (hd V12873)) (and (cons? (tl V12873)) (and (cons? (tl (tl V12873))) (= () (tl (tl (tl V12873)))))))) (cons input+ (cons (hd (tl V12873)) (cons (shen.curry (hd (tl (tl V12873)))) ())))) ((and (cons? V12873) (shen.special? (hd V12873))) (cons (hd V12873) (map (lambda Y (shen.curry Y)) (tl V12873)))) ((and (cons? V12873) (shen.extraspecial? (hd V12873))) V12873) ((and (cons? V12873) (and (cons? (tl V12873)) (cons? (tl (tl V12873))))) (shen.curry (cons (cons (hd V12873) (cons (hd (tl V12873)) ())) (tl (tl V12873))))) ((and (cons? V12873) (and (cons? (tl V12873)) (= () (tl (tl V12873))))) (cons (shen.curry (hd V12873)) (cons (shen.curry (hd (tl V12873))) ()))) (true V12873)))

(defun shen.special? (V12874) (element? V12874 (value shen.*special*)))

(defun shen.extraspecial? (V12875) (element? V12875 (value shen.*extraspecial*)))

(defun shen.system-S (V12876 V12877 V12878 V12879 V12880 V12881) (let K12449 (+ V12880 1) (let C12453 (if (shen.unlocked? V12879) (do (shen.incinfs) (when (shen.maxinfexceeded?) V12878 V12879 K12449 V12881)) false) (if (= C12453 false) (let C12454 (if (shen.unlocked? V12879) (let Tm12455 (shen.lazyderef V12876 V12878) (if (cons? Tm12455) (let X (hd Tm12455) (let Tm12456 (shen.lazyderef (tl Tm12455) V12878) (if (cons? Tm12456) (let Colon (hd Tm12456) (let Tm12457 (shen.lazyderef (tl Tm12456) V12878) (if (cons? Tm12457) (let A (hd Tm12457) (let Tm12458 (shen.lazyderef (tl Tm12457) V12878) (if (= Tm12458 ()) (do (shen.incinfs) (when (= (shen.deref Colon V12878) (intern ":")) V12878 V12879 K12449 (freeze (when (shen.type-theory-enabled?) V12878 V12879 K12449 (freeze (shen.cut V12878 V12879 K12449 (freeze (shen.system-S-h X A V12877 V12878 V12879 K12449 V12881)))))))) false))) false))) false))) false)) false) (if (= C12454 false) (let C12459 (if (shen.unlocked? V12879) (do (shen.incinfs) (when (value shen.*spy*) V12878 V12879 K12449 (freeze (shen.show V12876 V12877 V12878 V12879 K12449 V12881)))) false) (if (= C12459 false) (let C12460 (if (shen.unlocked? V12879) (do (shen.incinfs) (shen.search-user-datatypes V12876 V12877 (value shen.*datatypes*) V12878 V12879 K12449 V12881)) false) (if (= C12460 false) (shen.unlock V12879 K12449) C12460)) C12459)) C12454)) C12453))))

(defun shen.show (V12888 V12889 V12890 V12891 V12892 V12893) (do (shen.line) (do (shen.show-p (shen.deref V12888 V12890)) (do (nl 2) (do (shen.show-assumptions (shen.deref V12889 V12890) 1) (do (shen.pause-for-user) false))))))

(defun shen.line () (let Infs (inferences) (pr (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V12894) (cond ((and (cons? V12894) (and (cons? (tl V12894)) (and (cons? (tl (tl V12894))) (and (= () (tl (tl (tl V12894)))) (= (hd (tl V12894)) (intern ":")))))) (do (shen.prterm (hd V12894)) (do (pr " : " (stoutput)) (pr (shen.app (hd (tl (tl V12894))) "" shen.r) (stoutput))))) (true (shen.prterm V12894))))

(defun shen.prterm (V12895) (cond ((and (cons? V12895) (and (= cons (hd V12895)) (and (cons? (tl V12895)) (and (cons? (tl (tl V12895))) (= () (tl (tl (tl V12895)))))))) (do (pr "[" (stoutput)) (do (shen.prterm (hd (tl V12895))) (do (shen.prtl (hd (tl (tl V12895)))) (pr "]" (stoutput)))))) ((cons? V12895) (do (pr "(" (stoutput)) (do (shen.prterm (hd V12895)) (do (map (lambda Y (do (pr " " (stoutput)) (shen.prterm Y))) (tl V12895)) (pr ")" (stoutput)))))) (true (print V12895))))

(defun shen.prtl (V12896) (cond ((= () V12896) "") ((and (cons? V12896) (and (= cons (hd V12896)) (and (cons? (tl V12896)) (and (cons? (tl (tl V12896))) (= () (tl (tl (tl V12896)))))))) (do (pr " " (stoutput)) (do (shen.prterm (hd (tl V12896))) (shen.prtl (hd (tl (tl V12896))))))) (true (do (pr " | " (stoutput)) (shen.prterm V12896)))))

(defun shen.show-assumptions (V12903 V12904) (cond ((= () V12903) (pr "
> " (stoutput))) ((cons? V12903) (do (pr (shen.app V12904 ". " shen.a) (stoutput)) (do (shen.show-p (hd V12903)) (do (nl 1) (shen.show-assumptions (tl V12903) (+ V12904 1)))))) (true (simple-error "implementation error in shen.show-assumptions"))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun shen.maxinfexceeded? () (if (> (inferences) (value shen.*maxinferences*)) (simple-error "maximum inferences exceeded") false))

(defun shen.system-S-h (V12905 V12906 V12907 V12908 V12909 V12910 V12911) (let K12464 (+ V12910 1) (let C12469 (if (shen.unlocked? V12909) (do (shen.incinfs) (when (value shen.*spy*) V12908 V12909 K12464 (freeze (shen.show (cons V12905 (cons (intern ":") (cons V12906 ()))) V12907 V12908 V12909 K12464 V12911)))) false) (if (= C12469 false) (let C12470 (if (shen.unlocked? V12909) (do (shen.incinfs) (when (not (cons? (shen.lazyderef V12905 V12908))) V12908 V12909 K12464 (freeze (shen.primitive V12905 V12906 V12908 V12909 K12464 V12911)))) false) (if (= C12470 false) (let C12471 (if (shen.unlocked? V12909) (do (shen.incinfs) (shen.by-hypothesis V12905 V12906 V12907 V12908 V12909 K12464 V12911)) false) (if (= C12471 false) (let C12472 (if (shen.unlocked? V12909) (let Tm12473 (shen.lazyderef V12905 V12908) (if (cons? Tm12473) (let F (hd Tm12473) (let Tm12474 (shen.lazyderef (tl Tm12473) V12908) (if (= Tm12474 ()) (do (shen.incinfs) (shen.lookupsig F (cons --> (cons V12906 ())) V12908 V12909 K12464 V12911)) false))) false)) false) (if (= C12472 false) (let C12475 (if (shen.unlocked? V12909) (let Tm12476 (shen.lazyderef V12905 V12908) (if (cons? Tm12476) (let Tm12477 (shen.lazyderef (hd Tm12476) V12908) (if (= Tm12477 fn) (let Tm12478 (shen.lazyderef (tl Tm12476) V12908) (if (cons? Tm12478) (let F (hd Tm12478) (let Tm12479 (shen.lazyderef (tl Tm12478) V12908) (if (= Tm12479 ()) (do (shen.incinfs) (shen.lookupsig F V12906 V12908 V12909 K12464 V12911)) false))) false)) false)) false)) false) (if (= C12475 false) (let C12480 (if (shen.unlocked? V12909) (let Tm12481 (shen.lazyderef V12905 V12908) (if (cons? Tm12481) (let F (hd Tm12481) (let Tm12482 (shen.lazyderef (tl Tm12481) V12908) (if (cons? Tm12482) (let X (hd Tm12482) (let Tm12483 (shen.lazyderef (tl Tm12482) V12908) (if (= Tm12483 ()) (let B (shen.newpv V12908) (shen.gc V12908 (do (shen.incinfs) (when (not (cons? (shen.lazyderef F V12908))) V12908 V12909 K12464 (freeze (shen.lookupsig F (cons B (cons --> (cons V12906 ()))) V12908 V12909 K12464 (freeze (shen.system-S-h X B V12907 V12908 V12909 K12464 V12911)))))))) false))) false))) false)) false) (if (= C12480 false) (let C12484 (if (shen.unlocked? V12909) (let Tm12485 (shen.lazyderef V12905 V12908) (if (cons? Tm12485) (let F (hd Tm12485) (let Tm12486 (shen.lazyderef (tl Tm12485) V12908) (if (cons? Tm12486) (let X (hd Tm12486) (let Tm12487 (shen.lazyderef (tl Tm12486) V12908) (if (= Tm12487 ()) (let B (shen.newpv V12908) (shen.gc V12908 (do (shen.incinfs) (shen.system-S-h F (cons B (cons --> (cons V12906 ()))) V12907 V12908 V12909 K12464 (freeze (shen.system-S-h X B V12907 V12908 V12909 K12464 V12911)))))) false))) false))) false)) false) (if (= C12484 false) (let C12488 (if (shen.unlocked? V12909) (let Tm12489 (shen.lazyderef V12905 V12908) (if (cons? Tm12489) (let Tm12490 (shen.lazyderef (hd Tm12489) V12908) (if (= Tm12490 cons) (let Tm12491 (shen.lazyderef (tl Tm12489) V12908) (if (cons? Tm12491) (let X (hd Tm12491) (let Tm12492 (shen.lazyderef (tl Tm12491) V12908) (if (cons? Tm12492) (let Y (hd Tm12492) (let Tm12493 (shen.lazyderef (tl Tm12492) V12908) (if (= Tm12493 ()) (let Tm12494 (shen.lazyderef V12906 V12908) (let GoTo12495 (lambda A (do (shen.incinfs) (shen.system-S-h X A V12907 V12908 V12909 K12464 (freeze (shen.system-S-h Y (cons list (cons A ())) V12907 V12908 V12909 K12464 V12911))))) (if (cons? Tm12494) (let Tm12496 (shen.lazyderef (hd Tm12494) V12908) (let GoTo12497 (freeze (let Tm12498 (shen.lazyderef (tl Tm12494) V12908) (let GoTo12499 (lambda A (GoTo12495 A)) (if (cons? Tm12498) (let A (hd Tm12498) (let Tm12500 (shen.lazyderef (tl Tm12498) V12908) (let GoTo12501 (freeze (GoTo12499 A)) (if (= Tm12500 ()) (thaw GoTo12501) (if (shen.pvar? Tm12500) (shen.bind! Tm12500 () V12908 GoTo12501) false))))) (if (shen.pvar? Tm12498) (let A (shen.newpv V12908) (shen.gc V12908 (shen.bind! Tm12498 (cons A ()) V12908 (freeze (GoTo12499 A))))) false))))) (if (= Tm12496 list) (thaw GoTo12497) (if (shen.pvar? Tm12496) (shen.bind! Tm12496 list V12908 GoTo12497) false)))) (if (shen.pvar? Tm12494) (let A (shen.newpv V12908) (shen.gc V12908 (shen.bind! Tm12494 (cons list (cons A ())) V12908 (freeze (GoTo12495 A))))) false)))) false))) false))) false)) false)) false)) false) (if (= C12488 false) (let C12502 (if (shen.unlocked? V12909) (let Tm12503 (shen.lazyderef V12905 V12908) (if (cons? Tm12503) (let Tm12504 (shen.lazyderef (hd Tm12503) V12908) (if (= Tm12504 @p) (let Tm12505 (shen.lazyderef (tl Tm12503) V12908) (if (cons? Tm12505) (let X (hd Tm12505) (let Tm12506 (shen.lazyderef (tl Tm12505) V12908) (if (cons? Tm12506) (let Y (hd Tm12506) (let Tm12507 (shen.lazyderef (tl Tm12506) V12908) (if (= Tm12507 ()) (let Tm12508 (shen.lazyderef V12906 V12908) (let GoTo12509 (lambda A (lambda B (do (shen.incinfs) (shen.system-S-h X A V12907 V12908 V12909 K12464 (freeze (shen.system-S-h Y B V12907 V12908 V12909 K12464 V12911)))))) (if (cons? Tm12508) (let A (hd Tm12508) (let Tm12510 (shen.lazyderef (tl Tm12508) V12908) (let GoTo12511 (lambda B ((GoTo12509 A) B)) (if (cons? Tm12510) (let Tm12512 (shen.lazyderef (hd Tm12510) V12908) (let GoTo12513 (freeze (let Tm12514 (shen.lazyderef (tl Tm12510) V12908) (let GoTo12515 (lambda B (GoTo12511 B)) (if (cons? Tm12514) (let B (hd Tm12514) (let Tm12516 (shen.lazyderef (tl Tm12514) V12908) (let GoTo12517 (freeze (GoTo12515 B)) (if (= Tm12516 ()) (thaw GoTo12517) (if (shen.pvar? Tm12516) (shen.bind! Tm12516 () V12908 GoTo12517) false))))) (if (shen.pvar? Tm12514) (let B (shen.newpv V12908) (shen.gc V12908 (shen.bind! Tm12514 (cons B ()) V12908 (freeze (GoTo12515 B))))) false))))) (if (= Tm12512 *) (thaw GoTo12513) (if (shen.pvar? Tm12512) (shen.bind! Tm12512 * V12908 GoTo12513) false)))) (if (shen.pvar? Tm12510) (let B (shen.newpv V12908) (shen.gc V12908 (shen.bind! Tm12510 (cons * (cons B ())) V12908 (freeze (GoTo12511 B))))) false))))) (if (shen.pvar? Tm12508) (let A (shen.newpv V12908) (shen.gc V12908 (let B (shen.newpv V12908) (shen.gc V12908 (shen.bind! Tm12508 (cons A (cons * (cons B ()))) V12908 (freeze ((GoTo12509 A) B))))))) false)))) false))) false))) false)) false)) false)) false) (if (= C12502 false) (let C12518 (if (shen.unlocked? V12909) (let Tm12519 (shen.lazyderef V12905 V12908) (if (cons? Tm12519) (let Tm12520 (shen.lazyderef (hd Tm12519) V12908) (if (= Tm12520 @v) (let Tm12521 (shen.lazyderef (tl Tm12519) V12908) (if (cons? Tm12521) (let X (hd Tm12521) (let Tm12522 (shen.lazyderef (tl Tm12521) V12908) (if (cons? Tm12522) (let Y (hd Tm12522) (let Tm12523 (shen.lazyderef (tl Tm12522) V12908) (if (= Tm12523 ()) (let Tm12524 (shen.lazyderef V12906 V12908) (let GoTo12525 (lambda A (do (shen.incinfs) (shen.system-S-h X A V12907 V12908 V12909 K12464 (freeze (shen.system-S-h Y (cons vector (cons A ())) V12907 V12908 V12909 K12464 V12911))))) (if (cons? Tm12524) (let Tm12526 (shen.lazyderef (hd Tm12524) V12908) (let GoTo12527 (freeze (let Tm12528 (shen.lazyderef (tl Tm12524) V12908) (let GoTo12529 (lambda A (GoTo12525 A)) (if (cons? Tm12528) (let A (hd Tm12528) (let Tm12530 (shen.lazyderef (tl Tm12528) V12908) (let GoTo12531 (freeze (GoTo12529 A)) (if (= Tm12530 ()) (thaw GoTo12531) (if (shen.pvar? Tm12530) (shen.bind! Tm12530 () V12908 GoTo12531) false))))) (if (shen.pvar? Tm12528) (let A (shen.newpv V12908) (shen.gc V12908 (shen.bind! Tm12528 (cons A ()) V12908 (freeze (GoTo12529 A))))) false))))) (if (= Tm12526 vector) (thaw GoTo12527) (if (shen.pvar? Tm12526) (shen.bind! Tm12526 vector V12908 GoTo12527) false)))) (if (shen.pvar? Tm12524) (let A (shen.newpv V12908) (shen.gc V12908 (shen.bind! Tm12524 (cons vector (cons A ())) V12908 (freeze (GoTo12525 A))))) false)))) false))) false))) false)) false)) false)) false) (if (= C12518 false) (let C12532 (if (shen.unlocked? V12909) (let Tm12533 (shen.lazyderef V12905 V12908) (if (cons? Tm12533) (let Tm12534 (shen.lazyderef (hd Tm12533) V12908) (if (= Tm12534 @s) (let Tm12535 (shen.lazyderef (tl Tm12533) V12908) (if (cons? Tm12535) (let X (hd Tm12535) (let Tm12536 (shen.lazyderef (tl Tm12535) V12908) (if (cons? Tm12536) (let Y (hd Tm12536) (let Tm12537 (shen.lazyderef (tl Tm12536) V12908) (if (= Tm12537 ()) (let Tm12538 (shen.lazyderef V12906 V12908) (let GoTo12539 (freeze (do (shen.incinfs) (shen.system-S-h X string V12907 V12908 V12909 K12464 (freeze (shen.system-S-h Y string V12907 V12908 V12909 K12464 V12911))))) (if (= Tm12538 string) (thaw GoTo12539) (if (shen.pvar? Tm12538) (shen.bind! Tm12538 string V12908 GoTo12539) false)))) false))) false))) false)) false)) false)) false) (if (= C12532 false) (let C12540 (if (shen.unlocked? V12909) (let Tm12541 (shen.lazyderef V12905 V12908) (if (cons? Tm12541) (let Tm12542 (shen.lazyderef (hd Tm12541) V12908) (if (= Tm12542 lambda) (let Tm12543 (shen.lazyderef (tl Tm12541) V12908) (if (cons? Tm12543) (let X (hd Tm12543) (let Tm12544 (shen.lazyderef (tl Tm12543) V12908) (if (cons? Tm12544) (let Y (hd Tm12544) (let Tm12545 (shen.lazyderef (tl Tm12544) V12908) (if (= Tm12545 ()) (let Tm12546 (shen.lazyderef V12906 V12908) (let GoTo12547 (lambda A (lambda B (let Z (shen.newpv V12908) (shen.gc V12908 (let New (shen.newpv V12908) (shen.gc V12908 (do (shen.incinfs) (bind New (shen.freshterm (shen.lazyderef X V12908)) V12908 V12909 K12464 (freeze (bind Z (shen.beta (shen.lazyderef X V12908) (shen.deref New V12908) (shen.deref Y V12908)) V12908 V12909 K12464 (freeze (shen.system-S-h Z B (cons (cons New (cons (intern ":") (cons A ()))) V12907) V12908 V12909 K12464 V12911)))))))))))) (if (cons? Tm12546) (let A (hd Tm12546) (let Tm12548 (shen.lazyderef (tl Tm12546) V12908) (let GoTo12549 (lambda B ((GoTo12547 A) B)) (if (cons? Tm12548) (let Tm12550 (shen.lazyderef (hd Tm12548) V12908) (let GoTo12551 (freeze (let Tm12552 (shen.lazyderef (tl Tm12548) V12908) (let GoTo12553 (lambda B (GoTo12549 B)) (if (cons? Tm12552) (let B (hd Tm12552) (let Tm12554 (shen.lazyderef (tl Tm12552) V12908) (let GoTo12555 (freeze (GoTo12553 B)) (if (= Tm12554 ()) (thaw GoTo12555) (if (shen.pvar? Tm12554) (shen.bind! Tm12554 () V12908 GoTo12555) false))))) (if (shen.pvar? Tm12552) (let B (shen.newpv V12908) (shen.gc V12908 (shen.bind! Tm12552 (cons B ()) V12908 (freeze (GoTo12553 B))))) false))))) (if (= Tm12550 -->) (thaw GoTo12551) (if (shen.pvar? Tm12550) (shen.bind! Tm12550 --> V12908 GoTo12551) false)))) (if (shen.pvar? Tm12548) (let B (shen.newpv V12908) (shen.gc V12908 (shen.bind! Tm12548 (cons --> (cons B ())) V12908 (freeze (GoTo12549 B))))) false))))) (if (shen.pvar? Tm12546) (let A (shen.newpv V12908) (shen.gc V12908 (let B (shen.newpv V12908) (shen.gc V12908 (shen.bind! Tm12546 (cons A (cons --> (cons B ()))) V12908 (freeze ((GoTo12547 A) B))))))) false)))) false))) false))) false)) false)) false)) false) (if (= C12540 false) (let C12556 (if (shen.unlocked? V12909) (let Tm12557 (shen.lazyderef V12905 V12908) (if (cons? Tm12557) (let Tm12558 (shen.lazyderef (hd Tm12557) V12908) (if (= Tm12558 let) (let Tm12559 (shen.lazyderef (tl Tm12557) V12908) (if (cons? Tm12559) (let X (hd Tm12559) (let Tm12560 (shen.lazyderef (tl Tm12559) V12908) (if (cons? Tm12560) (let Y (hd Tm12560) (let Tm12561 (shen.lazyderef (tl Tm12560) V12908) (if (cons? Tm12561) (let Z (hd Tm12561) (let Tm12562 (shen.lazyderef (tl Tm12561) V12908) (if (= Tm12562 ()) (let W (shen.newpv V12908) (shen.gc V12908 (let New (shen.newpv V12908) (shen.gc V12908 (let B (shen.newpv V12908) (shen.gc V12908 (do (shen.incinfs) (shen.system-S-h Y B V12907 V12908 V12909 K12464 (freeze (bind New (shen.freshterm (shen.lazyderef X V12908)) V12908 V12909 K12464 (freeze (bind W (shen.beta (shen.lazyderef X V12908) (shen.lazyderef New V12908) (shen.lazyderef Z V12908)) V12908 V12909 K12464 (freeze (shen.system-S-h W V12906 (cons (cons New (cons (intern ":") (cons B ()))) V12907) V12908 V12909 K12464 V12911)))))))))))))) false))) false))) false))) false)) false)) false)) false) (if (= C12556 false) (let C12563 (if (shen.unlocked? V12909) (let Tm12564 (shen.lazyderef V12905 V12908) (if (cons? Tm12564) (let Tm12565 (shen.lazyderef (hd Tm12564) V12908) (if (= Tm12565 open) (let Tm12566 (shen.lazyderef (tl Tm12564) V12908) (if (cons? Tm12566) (let File (hd Tm12566) (let Tm12567 (shen.lazyderef (tl Tm12566) V12908) (if (cons? Tm12567) (let V12461 (hd Tm12567) (let Tm12568 (shen.lazyderef (tl Tm12567) V12908) (if (= Tm12568 ()) (let Tm12569 (shen.lazyderef V12906 V12908) (let GoTo12570 (lambda D (do (shen.incinfs) (is! V12461 D V12908 V12909 K12464 (freeze (when (element? (shen.lazyderef D V12908) (cons in (cons out ()))) V12908 V12909 K12464 (freeze (shen.system-S-h File string V12907 V12908 V12909 K12464 V12911))))))) (if (cons? Tm12569) (let Tm12571 (shen.lazyderef (hd Tm12569) V12908) (let GoTo12572 (freeze (let Tm12573 (shen.lazyderef (tl Tm12569) V12908) (let GoTo12574 (lambda D (GoTo12570 D)) (if (cons? Tm12573) (let D (hd Tm12573) (let Tm12575 (shen.lazyderef (tl Tm12573) V12908) (let GoTo12576 (freeze (GoTo12574 D)) (if (= Tm12575 ()) (thaw GoTo12576) (if (shen.pvar? Tm12575) (shen.bind! Tm12575 () V12908 GoTo12576) false))))) (if (shen.pvar? Tm12573) (let D (shen.newpv V12908) (shen.gc V12908 (shen.bind! Tm12573 (cons D ()) V12908 (freeze (GoTo12574 D))))) false))))) (if (= Tm12571 stream) (thaw GoTo12572) (if (shen.pvar? Tm12571) (shen.bind! Tm12571 stream V12908 GoTo12572) false)))) (if (shen.pvar? Tm12569) (let D (shen.newpv V12908) (shen.gc V12908 (shen.bind! Tm12569 (cons stream (cons D ())) V12908 (freeze (GoTo12570 D))))) false)))) false))) false))) false)) false)) false)) false) (if (= C12563 false) (let C12577 (if (shen.unlocked? V12909) (let Tm12578 (shen.lazyderef V12905 V12908) (if (cons? Tm12578) (let Tm12579 (shen.lazyderef (hd Tm12578) V12908) (if (= Tm12579 type) (let Tm12580 (shen.lazyderef (tl Tm12578) V12908) (if (cons? Tm12580) (let X (hd Tm12580) (let Tm12581 (shen.lazyderef (tl Tm12580) V12908) (if (cons? Tm12581) (let A (hd Tm12581) (let Tm12582 (shen.lazyderef (tl Tm12581) V12908) (if (= Tm12582 ()) (do (shen.incinfs) (shen.cut V12908 V12909 K12464 (freeze (is! (shen.rectify-type (shen.deref A V12908)) V12906 V12908 V12909 K12464 (freeze (shen.system-S-h X V12906 V12907 V12908 V12909 K12464 V12911)))))) false))) false))) false)) false)) false)) false) (if (= C12577 false) (let C12583 (if (shen.unlocked? V12909) (let Tm12584 (shen.lazyderef V12905 V12908) (if (cons? Tm12584) (let Tm12585 (shen.lazyderef (hd Tm12584) V12908) (if (= Tm12585 input+) (let Tm12586 (shen.lazyderef (tl Tm12584) V12908) (if (cons? Tm12586) (let A (hd Tm12586) (let Tm12587 (shen.lazyderef (tl Tm12586) V12908) (if (cons? Tm12587) (let Stream (hd Tm12587) (let Tm12588 (shen.lazyderef (tl Tm12587) V12908) (if (= Tm12588 ()) (do (shen.incinfs) (is! V12906 (shen.rectify-type (shen.deref A V12908)) V12908 V12909 K12464 (freeze (shen.system-S-h Stream (cons stream (cons in ())) V12907 V12908 V12909 K12464 V12911)))) false))) false))) false)) false)) false)) false) (if (= C12583 false) (let C12589 (if (shen.unlocked? V12909) (let Tm12590 (shen.lazyderef V12905 V12908) (if (cons? Tm12590) (let Tm12591 (shen.lazyderef (hd Tm12590) V12908) (if (= Tm12591 set) (let Tm12592 (shen.lazyderef (tl Tm12590) V12908) (if (cons? Tm12592) (let Var (hd Tm12592) (let Tm12593 (shen.lazyderef (tl Tm12592) V12908) (if (cons? Tm12593) (let Val (hd Tm12593) (let Tm12594 (shen.lazyderef (tl Tm12593) V12908) (if (= Tm12594 ()) (do (shen.incinfs) (shen.system-S-h Var symbol V12907 V12908 V12909 K12464 (freeze (shen.system-S-h (cons value (cons Var ())) V12906 V12907 V12908 V12909 K12464 (freeze (shen.system-S-h Val V12906 V12907 V12908 V12909 K12464 V12911)))))) false))) false))) false)) false)) false)) false) (if (= C12589 false) (let C12595 (if (shen.unlocked? V12909) (let Normalised (shen.newpv V12908) (shen.gc V12908 (do (shen.incinfs) (shen.l-rules V12907 Normalised false V12908 V12909 K12464 (freeze (shen.cut V12908 V12909 K12464 (freeze (shen.system-S-h V12905 V12906 Normalised V12908 V12909 K12464 V12911)))))))) false) (if (= C12595 false) (let C12596 (if (shen.unlocked? V12909) (do (shen.incinfs) (shen.search-user-datatypes (cons V12905 (cons (intern ":") (cons V12906 ()))) V12907 (value shen.*datatypes*) V12908 V12909 K12464 V12911)) false) (if (= C12596 false) (shen.unlock V12909 K12464) C12596)) C12595)) C12589)) C12583)) C12577)) C12563)) C12556)) C12540)) C12532)) C12518)) C12502)) C12488)) C12484)) C12480)) C12475)) C12472)) C12471)) C12470)) C12469))))

(defun shen.primitive (V12912 V12913 V12914 V12915 V12916 V12917) (let C12603 (if (shen.unlocked? V12915) (let Tm12604 (shen.lazyderef V12913 V12914) (let GoTo12605 (freeze (do (shen.incinfs) (when (number? (shen.lazyderef V12912 V12914)) V12914 V12915 V12916 V12917))) (if (= Tm12604 number) (thaw GoTo12605) (if (shen.pvar? Tm12604) (shen.bind! Tm12604 number V12914 GoTo12605) false)))) false) (if (= C12603 false) (let C12606 (if (shen.unlocked? V12915) (let Tm12607 (shen.lazyderef V12913 V12914) (let GoTo12608 (freeze (do (shen.incinfs) (when (boolean? (shen.lazyderef V12912 V12914)) V12914 V12915 V12916 V12917))) (if (= Tm12607 boolean) (thaw GoTo12608) (if (shen.pvar? Tm12607) (shen.bind! Tm12607 boolean V12914 GoTo12608) false)))) false) (if (= C12606 false) (let C12609 (if (shen.unlocked? V12915) (let Tm12610 (shen.lazyderef V12913 V12914) (let GoTo12611 (freeze (do (shen.incinfs) (when (string? (shen.lazyderef V12912 V12914)) V12914 V12915 V12916 V12917))) (if (= Tm12610 string) (thaw GoTo12611) (if (shen.pvar? Tm12610) (shen.bind! Tm12610 string V12914 GoTo12611) false)))) false) (if (= C12609 false) (let C12612 (if (shen.unlocked? V12915) (let Tm12613 (shen.lazyderef V12913 V12914) (let GoTo12614 (freeze (do (shen.incinfs) (when (symbol? (shen.lazyderef V12912 V12914)) V12914 V12915 V12916 V12917))) (if (= Tm12613 symbol) (thaw GoTo12614) (if (shen.pvar? Tm12613) (shen.bind! Tm12613 symbol V12914 GoTo12614) false)))) false) (if (= C12612 false) (if (shen.unlocked? V12915) (let Tm12615 (shen.lazyderef V12912 V12914) (if (= Tm12615 ()) (let Tm12616 (shen.lazyderef V12913 V12914) (let GoTo12617 (lambda A (do (shen.incinfs) (thaw V12917))) (if (cons? Tm12616) (let Tm12618 (shen.lazyderef (hd Tm12616) V12914) (let GoTo12619 (freeze (let Tm12620 (shen.lazyderef (tl Tm12616) V12914) (let GoTo12621 (lambda A (GoTo12617 A)) (if (cons? Tm12620) (let A (hd Tm12620) (let Tm12622 (shen.lazyderef (tl Tm12620) V12914) (let GoTo12623 (freeze (GoTo12621 A)) (if (= Tm12622 ()) (thaw GoTo12623) (if (shen.pvar? Tm12622) (shen.bind! Tm12622 () V12914 GoTo12623) false))))) (if (shen.pvar? Tm12620) (let A (shen.newpv V12914) (shen.gc V12914 (shen.bind! Tm12620 (cons A ()) V12914 (freeze (GoTo12621 A))))) false))))) (if (= Tm12618 list) (thaw GoTo12619) (if (shen.pvar? Tm12618) (shen.bind! Tm12618 list V12914 GoTo12619) false)))) (if (shen.pvar? Tm12616) (let A (shen.newpv V12914) (shen.gc V12914 (shen.bind! Tm12616 (cons list (cons A ())) V12914 (freeze (GoTo12617 A))))) false)))) false)) false) C12612)) C12609)) C12606)) C12603)))

(defun shen.by-hypothesis (V12918 V12919 V12920 V12921 V12922 V12923 V12924) (let C12631 (if (shen.unlocked? V12922) (let Tm12632 (shen.lazyderef V12920 V12921) (if (cons? Tm12632) (let Tm12633 (shen.lazyderef (hd Tm12632) V12921) (if (cons? Tm12633) (let Y (hd Tm12633) (let Tm12634 (shen.lazyderef (tl Tm12633) V12921) (if (cons? Tm12634) (let Colon (hd Tm12634) (let Tm12635 (shen.lazyderef (tl Tm12634) V12921) (if (cons? Tm12635) (let B (hd Tm12635) (let Tm12636 (shen.lazyderef (tl Tm12635) V12921) (if (= Tm12636 ()) (do (shen.incinfs) (when (= (shen.deref Colon V12921) (intern ":")) V12921 V12922 V12923 (freeze (when (= (shen.deref V12918 V12921) (shen.deref Y V12921)) V12921 V12922 V12923 (freeze (is! V12919 B V12921 V12922 V12923 V12924)))))) false))) false))) false))) false)) false)) false) (if (= C12631 false) (if (shen.unlocked? V12922) (let Tm12637 (shen.lazyderef V12920 V12921) (if (cons? Tm12637) (let Hyp (tl Tm12637) (do (shen.incinfs) (shen.by-hypothesis V12918 V12919 Hyp V12921 V12922 V12923 V12924))) false)) false) C12631)))

(defun shen.lookupsig (V12925 V12926 V12927 V12928 V12929 V12930) (if (shen.unlocked? V12928) (do (shen.incinfs) (shen.sigf (assoc V12925 (value shen.*sigf*)) V12926 V12927 V12928 V12929 V12930)) false))

(defun shen.sigf (V12945 V12946 V12947 V12948 V12949 V12950) (cond ((cons? V12945) ((((((tl V12945) V12946) V12947) V12948) V12949) V12950)) (true false)))

(defun shen.freshterm (V12951) (let V (absvector 3) (let V0 (address-> V 0 shen.print-freshterm) (let V1 (address-> V0 1 V12951) (let V2 (address-> V1 2 (set shen.*gensym* (+ 1 (value shen.*gensym*)))) V2)))))

(defun shen.print-freshterm (V12952) (cn "&&" (str (<-address V12952 1))))

(defun shen.search-user-datatypes (V12953 V12954 V12955 V12956 V12957 V12958 V12959) (let C12651 (if (shen.unlocked? V12957) (let Tm12652 (shen.lazyderef V12955 V12956) (if (cons? Tm12652) (let Tm12653 (shen.lazyderef (hd Tm12652) V12956) (if (cons? Tm12653) (let Fn (tl Tm12653) (do (shen.incinfs) (call (((shen.deref Fn V12956) (shen.deref V12953 V12956)) (shen.deref V12954 V12956)) V12956 V12957 V12958 V12959))) false)) false)) false) (if (= C12651 false) (if (shen.unlocked? V12957) (let Tm12654 (shen.lazyderef V12955 V12956) (if (cons? Tm12654) (let Ds (tl Tm12654) (do (shen.incinfs) (shen.search-user-datatypes V12953 V12954 Ds V12956 V12957 V12958 V12959))) false)) false) C12651)))

(defun shen.l-rules (V12960 V12961 V12962 V12963 V12964 V12965 V12966) (let K12657 (+ V12965 1) (let C12662 (if (shen.unlocked? V12964) (let Tm12663 (shen.lazyderef V12960 V12963) (if (= Tm12663 ()) (let Tm12664 (shen.lazyderef V12962 V12963) (if (= Tm12664 true) (do (shen.incinfs) (shen.cut V12963 V12964 K12657 (freeze (bind V12961 () V12963 V12964 K12657 V12966)))) false)) false)) false) (if (= C12662 false) (let C12665 (if (shen.unlocked? V12964) (let Tm12666 (shen.lazyderef V12960 V12963) (if (cons? Tm12666) (let Tm12667 (shen.lazyderef (hd Tm12666) V12963) (if (cons? Tm12667) (let Tm12668 (shen.lazyderef (hd Tm12667) V12963) (if (cons? Tm12668) (let Tm12669 (shen.lazyderef (hd Tm12668) V12963) (if (= Tm12669 cons) (let Tm12670 (shen.lazyderef (tl Tm12668) V12963) (if (cons? Tm12670) (let X (hd Tm12670) (let Tm12671 (shen.lazyderef (tl Tm12670) V12963) (if (cons? Tm12671) (let Y (hd Tm12671) (let Tm12672 (shen.lazyderef (tl Tm12671) V12963) (if (= Tm12672 ()) (let Tm12673 (shen.lazyderef (tl Tm12667) V12963) (if (cons? Tm12673) (let Colon (hd Tm12673) (let Tm12674 (shen.lazyderef (tl Tm12673) V12963) (if (cons? Tm12674) (let Tm12675 (shen.lazyderef (hd Tm12674) V12963) (if (cons? Tm12675) (let Tm12676 (shen.lazyderef (hd Tm12675) V12963) (if (= Tm12676 list) (let Tm12677 (shen.lazyderef (tl Tm12675) V12963) (if (cons? Tm12677) (let A (hd Tm12677) (let Tm12678 (shen.lazyderef (tl Tm12677) V12963) (if (= Tm12678 ()) (let Tm12679 (shen.lazyderef (tl Tm12674) V12963) (if (= Tm12679 ()) (let Hyp (tl Tm12666) (do (shen.incinfs) (when (= (shen.deref Colon V12963) (intern ":")) V12963 V12964 K12657 (freeze (shen.cut V12963 V12964 K12657 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons (cons list (cons A ())) ()))) Hyp)) V12961 true V12963 V12964 K12657 V12966))))))) false)) false))) false)) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C12665 false) (let C12680 (if (shen.unlocked? V12964) (let Tm12681 (shen.lazyderef V12960 V12963) (if (cons? Tm12681) (let Tm12682 (shen.lazyderef (hd Tm12681) V12963) (if (cons? Tm12682) (let Tm12683 (shen.lazyderef (hd Tm12682) V12963) (if (cons? Tm12683) (let Tm12684 (shen.lazyderef (hd Tm12683) V12963) (if (= Tm12684 @p) (let Tm12685 (shen.lazyderef (tl Tm12683) V12963) (if (cons? Tm12685) (let X (hd Tm12685) (let Tm12686 (shen.lazyderef (tl Tm12685) V12963) (if (cons? Tm12686) (let Y (hd Tm12686) (let Tm12687 (shen.lazyderef (tl Tm12686) V12963) (if (= Tm12687 ()) (let Tm12688 (shen.lazyderef (tl Tm12682) V12963) (if (cons? Tm12688) (let Colon (hd Tm12688) (let Tm12689 (shen.lazyderef (tl Tm12688) V12963) (if (cons? Tm12689) (let Tm12690 (shen.lazyderef (hd Tm12689) V12963) (if (cons? Tm12690) (let A (hd Tm12690) (let Tm12691 (shen.lazyderef (tl Tm12690) V12963) (if (cons? Tm12691) (let Tm12692 (shen.lazyderef (hd Tm12691) V12963) (if (= Tm12692 *) (let Tm12693 (shen.lazyderef (tl Tm12691) V12963) (if (cons? Tm12693) (let B (hd Tm12693) (let Tm12694 (shen.lazyderef (tl Tm12693) V12963) (if (= Tm12694 ()) (let Tm12695 (shen.lazyderef (tl Tm12689) V12963) (if (= Tm12695 ()) (let Hyp (tl Tm12681) (do (shen.incinfs) (when (= (shen.deref Colon V12963) (intern ":")) V12963 V12964 K12657 (freeze (shen.cut V12963 V12964 K12657 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons B ()))) Hyp)) V12961 true V12963 V12964 K12657 V12966))))))) false)) false))) false)) false)) false))) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C12680 false) (let C12696 (if (shen.unlocked? V12964) (let Tm12697 (shen.lazyderef V12960 V12963) (if (cons? Tm12697) (let Tm12698 (shen.lazyderef (hd Tm12697) V12963) (if (cons? Tm12698) (let Tm12699 (shen.lazyderef (hd Tm12698) V12963) (if (cons? Tm12699) (let Tm12700 (shen.lazyderef (hd Tm12699) V12963) (if (= Tm12700 @s) (let Tm12701 (shen.lazyderef (tl Tm12699) V12963) (if (cons? Tm12701) (let X (hd Tm12701) (let Tm12702 (shen.lazyderef (tl Tm12701) V12963) (if (cons? Tm12702) (let Y (hd Tm12702) (let Tm12703 (shen.lazyderef (tl Tm12702) V12963) (if (= Tm12703 ()) (let Tm12704 (shen.lazyderef (tl Tm12698) V12963) (if (cons? Tm12704) (let Colon (hd Tm12704) (let Tm12705 (shen.lazyderef (tl Tm12704) V12963) (if (cons? Tm12705) (let Tm12706 (shen.lazyderef (hd Tm12705) V12963) (if (= Tm12706 string) (let Tm12707 (shen.lazyderef (tl Tm12705) V12963) (if (= Tm12707 ()) (let Hyp (tl Tm12697) (do (shen.incinfs) (when (= (shen.deref Colon V12963) (intern ":")) V12963 V12964 K12657 (freeze (shen.cut V12963 V12964 K12657 (freeze (shen.l-rules (cons (cons X (cons Colon (cons string ()))) (cons (cons Y (cons Colon (cons string ()))) Hyp)) V12961 true V12963 V12964 K12657 V12966))))))) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C12696 false) (let C12708 (if (shen.unlocked? V12964) (let Tm12709 (shen.lazyderef V12960 V12963) (if (cons? Tm12709) (let Tm12710 (shen.lazyderef (hd Tm12709) V12963) (if (cons? Tm12710) (let Tm12711 (shen.lazyderef (hd Tm12710) V12963) (if (cons? Tm12711) (let Tm12712 (shen.lazyderef (hd Tm12711) V12963) (if (= Tm12712 @v) (let Tm12713 (shen.lazyderef (tl Tm12711) V12963) (if (cons? Tm12713) (let X (hd Tm12713) (let Tm12714 (shen.lazyderef (tl Tm12713) V12963) (if (cons? Tm12714) (let Y (hd Tm12714) (let Tm12715 (shen.lazyderef (tl Tm12714) V12963) (if (= Tm12715 ()) (let Tm12716 (shen.lazyderef (tl Tm12710) V12963) (if (cons? Tm12716) (let Colon (hd Tm12716) (let Tm12717 (shen.lazyderef (tl Tm12716) V12963) (if (cons? Tm12717) (let Tm12718 (shen.lazyderef (hd Tm12717) V12963) (if (cons? Tm12718) (let Tm12719 (shen.lazyderef (hd Tm12718) V12963) (if (= Tm12719 vector) (let Tm12720 (shen.lazyderef (tl Tm12718) V12963) (if (cons? Tm12720) (let A (hd Tm12720) (let Tm12721 (shen.lazyderef (tl Tm12720) V12963) (if (= Tm12721 ()) (let Tm12722 (shen.lazyderef (tl Tm12717) V12963) (if (= Tm12722 ()) (let Hyp (tl Tm12709) (do (shen.incinfs) (when (= (shen.deref Colon V12963) (intern ":")) V12963 V12964 K12657 (freeze (shen.cut V12963 V12964 K12657 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons (cons vector (cons A ())) ()))) Hyp)) V12961 true V12963 V12964 K12657 V12966))))))) false)) false))) false)) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C12708 false) (let C12723 (if (shen.unlocked? V12964) (let Tm12724 (shen.lazyderef V12960 V12963) (if (cons? Tm12724) (let P (hd Tm12724) (let Hyp (tl Tm12724) (let Tm12725 (shen.lazyderef V12961 V12963) (let GoTo12726 (lambda Q (lambda Normalised (do (shen.incinfs) (bind Q P V12963 V12964 K12657 (freeze (shen.l-rules Hyp Normalised V12962 V12963 V12964 K12657 V12966)))))) (if (cons? Tm12725) (let Q (hd Tm12725) (let Normalised (tl Tm12725) ((GoTo12726 Q) Normalised))) (if (shen.pvar? Tm12725) (let Q (shen.newpv V12963) (shen.gc V12963 (let Normalised (shen.newpv V12963) (shen.gc V12963 (shen.bind! Tm12725 (cons Q Normalised) V12963 (freeze ((GoTo12726 Q) Normalised))))))) false)))))) false)) false) (if (= C12723 false) (shen.unlock V12964 K12657) C12723)) C12708)) C12696)) C12680)) C12665)) C12662))))

(defun shen.t* (V12967 V12968 V12969 V12970 V12971 V12972) (let K12729 (+ V12971 1) (let C12733 (if (shen.unlocked? V12970) (let Tm12734 (shen.lazyderef V12967 V12969) (if (cons? Tm12734) (let Tm12735 (shen.lazyderef (hd Tm12734) V12969) (if (= Tm12735 define) (let Tm12736 (shen.lazyderef (tl Tm12734) V12969) (if (cons? Tm12736) (let F (hd Tm12736) (let X (tl Tm12736) (let SigxRules (shen.newpv V12969) (shen.gc V12969 (let Rules (shen.newpv V12969) (shen.gc V12969 (let FreshSig (shen.newpv V12969) (shen.gc V12969 (let Sig (shen.newpv V12969) (shen.gc V12969 (do (shen.incinfs) (shen.cut V12969 V12970 K12729 (freeze (bind SigxRules (shen.sigxrules (cons F X)) V12969 V12970 K12729 (freeze (bind Sig (fst (shen.lazyderef SigxRules V12969)) V12969 V12970 K12729 (freeze (bind Rules (snd (shen.lazyderef SigxRules V12969)) V12969 V12970 K12729 (freeze (bind FreshSig (shen.freshen-sig (shen.deref Sig V12969)) V12969 V12970 K12729 (freeze (shen.t*-rules F Rules FreshSig 1 V12969 V12970 K12729 (freeze (is Sig V12968 V12969 V12970 K12729 V12972)))))))))))))))))))))))) false)) false)) false)) false) (if (= C12733 false) (shen.unlock V12970 K12729) C12733))))

(defun shen.sigxrules (V12973) (compile (lambda X (shen.<sig*rules> X)) V12973))

(defun shen.<sig*rules> (V12974) (let Result (if (shen.non-empty-stream? V12974) (let F (shen.hds V12974) (let News12738 (shen.tls V12974) (if (shen.=hd? News12738 {) (let News12739 (shen.tls News12738) (let Parseshen.<signature> (shen.<signature> News12739) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (shen.=hd? Parseshen.<signature> }) (let News12740 (shen.tls Parseshen.<signature>) (let Parseshen.<rules*> (shen.<rules*> News12740) (if (shen.parse-failure? Parseshen.<rules*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules*>) (let Rectified (shen.rectify-type (shen.<-out Parseshen.<signature>)) (@p Rectified (shen.<-out Parseshen.<rules*>))))))) (shen.parse-failure))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.freshen-sig (V12975) (let Vs (shen.extract-vars V12975) (let Assoc (map (lambda V (cons V (shen.freshterm (concat & V)))) Vs) (shen.freshen-type Assoc V12975))))

(defun shen.freshen-type (V12976 V12977) (cond ((= () V12976) V12977) ((and (cons? V12976) (cons? (hd V12976))) (shen.freshen-type (tl V12976) (subst (tl (hd V12976)) (hd (hd V12976)) V12977))) (true (shen.f-error shen.freshen-type))))

(defun shen.<rules*> (V12978) (let Result (let Parseshen.<rule*> (shen.<rule*> V12978) (if (shen.parse-failure? Parseshen.<rule*>) (shen.parse-failure) (let Parseshen.<rules*> (shen.<rules*> Parseshen.<rule*>) (if (shen.parse-failure? Parseshen.<rules*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules*>) (cons (shen.linearise (shen.<-out Parseshen.<rule*>)) (shen.<-out Parseshen.<rules*>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<rule*> (shen.<rule*> V12978) (if (shen.parse-failure? Parseshen.<rule*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rule*>) (cons (shen.linearise (shen.<-out Parseshen.<rule*>)) ())))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<rule*> (V12979) (let Result (let Parseshen.<patterns> (shen.<patterns> V12979) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News12743 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News12743) (let Action (shen.hds News12743) (let News12744 (shen.tls News12743) (if (shen.=hd? News12744 where) (let News12745 (shen.tls News12744) (if (shen.non-empty-stream? News12745) (let Guard (shen.hds News12745) (let News12746 (shen.tls News12745) (shen.comb (shen.in-> News12746) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons Action ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V12979) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News12747 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News12747) (let Action (shen.hds News12747) (let News12748 (shen.tls News12747) (if (shen.=hd? News12748 where) (let News12749 (shen.tls News12748) (if (shen.non-empty-stream? News12749) (let Guard (shen.hds News12749) (let News12750 (shen.tls News12749) (shen.comb (shen.in-> News12750) (@p (shen.<-out Parseshen.<patterns>) (shen.correct (cons where (cons Guard (cons Action ())))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V12979) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News12751 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News12751) (let Action (shen.hds News12751) (let News12752 (shen.tls News12751) (shen.comb (shen.in-> News12752) (@p (shen.<-out Parseshen.<patterns>) (shen.correct Action))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V12979) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News12753 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News12753) (let Action (shen.hds News12753) (let News12754 (shen.tls News12753) (shen.comb (shen.in-> News12754) (@p (shen.<-out Parseshen.<patterns>) Action)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.correct (V12980) (cond ((and (cons? V12980) (and (= where (hd V12980)) (and (cons? (tl V12980)) (and (cons? (tl (tl V12980))) (and (cons? (hd (tl (tl V12980)))) (and (= fail-if (hd (hd (tl (tl V12980))))) (and (cons? (tl (hd (tl (tl V12980))))) (and (cons? (tl (tl (hd (tl (tl V12980)))))) (and (= () (tl (tl (tl (hd (tl (tl V12980))))))) (= () (tl (tl (tl V12980))))))))))))) (cons where (cons (cons and (cons (hd (tl V12980)) (cons (cons not (cons (tl (hd (tl (tl V12980)))) ())) ()))) (tl (tl (hd (tl (tl V12980)))))))) ((and (cons? V12980) (and (= where (hd V12980)) (and (cons? (tl V12980)) (and (cons? (tl (tl V12980))) (= () (tl (tl (tl V12980)))))))) (cons where (cons (cons and (cons (hd (tl V12980)) (cons (cons not (cons (cons = (cons (hd (tl (tl V12980))) (cons (cons fail ()) ()))) ())) ()))) (tl (tl V12980))))) ((and (cons? V12980) (and (= fail-if (hd V12980)) (and (cons? (tl V12980)) (and (cons? (tl (tl V12980))) (= () (tl (tl (tl V12980)))))))) (cons where (cons (cons not (cons (tl V12980) ())) (tl (tl V12980))))) (true (cons where (cons (cons not (cons (cons = (cons V12980 (cons (cons fail ()) ()))) ())) (cons V12980 ()))))))

(defun shen.t*-rules (V12981 V12982 V12983 V12984 V12985 V12986 V12987 V12988) (let K12757 (+ V12987 1) (let C12763 (if (shen.unlocked? V12986) (let Tm12764 (shen.lazyderef V12982 V12985) (if (= Tm12764 ()) (do (shen.incinfs) (thaw V12988)) false)) false) (if (= C12763 false) (let C12765 (if (shen.unlocked? V12986) (let Tm12766 (shen.lazyderef V12982 V12985) (if (cons? Tm12766) (let Rule (hd Tm12766) (let Rules (tl Tm12766) (let Fresh (shen.newpv V12985) (shen.gc V12985 (do (shen.incinfs) (bind Fresh (shen.freshen-rule (shen.deref Rule V12985)) V12985 V12986 K12757 (freeze (shen.t*-rule V12981 V12984 (fst (shen.lazyderef Fresh V12985)) (snd (shen.lazyderef Fresh V12985)) V12983 V12985 V12986 K12757 (freeze (shen.cut V12985 V12986 K12757 (freeze (shen.t*-rules V12981 Rules V12983 (+ V12984 1) V12985 V12986 K12757 V12988)))))))))))) false)) false) (if (= C12765 false) (shen.unlock V12986 K12757) C12765)) C12763))))

(defun shen.freshen-rule (V12989) (cond ((tuple? V12989) (let Vs (shen.extract-vars (fst V12989)) (let Assoc (map (lambda V (cons V (shen.freshterm V))) Vs) (@p (shen.freshen Assoc (fst V12989)) (shen.freshen Assoc (snd V12989)))))) (true (shen.f-error shen.freshen-rule))))

(defun shen.freshen (V12990 V12991) (cond ((= () V12990) V12991) ((and (cons? V12990) (cons? (hd V12990))) (shen.freshen (tl V12990) (shen.beta (hd (hd V12990)) (tl (hd V12990)) V12991))) (true (shen.f-error shen.freshen))))

(defun shen.t*-rule (V12992 V12993 V12994 V12995 V12996 V12997 V12998 V12999 V13000) (let C12776 (if (shen.unlocked? V12998) (do (shen.incinfs) (shen.t*-rule-h V12994 V12995 V12996 V12997 V12998 V12999 V13000)) false) (if (= C12776 false) (if (shen.unlocked? V12998) (let Err (shen.newpv V12997) (shen.gc V12997 (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app V12993 (cn " of " (shen.app V12992 "
" shen.a)) shen.a))) V12997 V12998 V12999 V13000)))) false) C12776)))

(defun shen.t*-rule-h (V13001 V13002 V13003 V13004 V13005 V13006 V13007) (let K12779 (+ V13006 1) (let C12784 (if (shen.unlocked? V13005) (let Tm12785 (shen.lazyderef V13001 V13004) (if (= Tm12785 ()) (let Tm12786 (shen.lazyderef V13003 V13004) (if (cons? Tm12786) (let Tm12787 (shen.lazyderef (hd Tm12786) V13004) (if (= Tm12787 -->) (let Tm12788 (shen.lazyderef (tl Tm12786) V13004) (if (cons? Tm12788) (let A (hd Tm12788) (let Tm12789 (shen.lazyderef (tl Tm12788) V13004) (if (= Tm12789 ()) (do (shen.incinfs) (shen.cut V13004 V13005 K12779 (freeze (shen.t*-correct V13002 A () V13004 V13005 K12779 V13007)))) false))) false)) false)) false)) false)) false) (if (= C12784 false) (let C12790 (if (shen.unlocked? V13005) (let B (shen.newpv V13004) (shen.gc V13004 (let Hyps (shen.newpv V13004) (shen.gc V13004 (do (shen.incinfs) (shen.t*-integrity V13001 V13003 Hyps B V13004 V13005 K12779 (freeze (shen.cut V13004 V13005 K12779 (freeze (shen.t*-correct V13002 B Hyps V13004 V13005 K12779 V13007)))))))))) false) (if (= C12790 false) (shen.unlock V13005 K12779) C12790)) C12784))))

(defun shen.t*-correct (V13008 V13009 V13010 V13011 V13012 V13013 V13014) (let K12793 (+ V13013 1) (let C12798 (if (shen.unlocked? V13012) (let Tm12799 (shen.lazyderef V13008 V13011) (if (cons? Tm12799) (let Tm12800 (shen.lazyderef (hd Tm12799) V13011) (if (= Tm12800 where) (let Tm12801 (shen.lazyderef (tl Tm12799) V13011) (if (cons? Tm12801) (let G (hd Tm12801) (let Tm12802 (shen.lazyderef (tl Tm12801) V13011) (if (cons? Tm12802) (let R (hd Tm12802) (let Tm12803 (shen.lazyderef (tl Tm12802) V13011) (if (= Tm12803 ()) (let CurryG (shen.newpv V13011) (shen.gc V13011 (do (shen.incinfs) (shen.cut V13011 V13012 K12793 (freeze (bind CurryG (shen.curry G) V13011 V13012 K12793 (freeze (shen.system-S-h CurryG boolean V13010 V13011 V13012 K12793 (freeze (shen.cut V13011 V13012 K12793 (freeze (shen.t*-correct R V13009 (cons (cons CurryG (cons (intern ":") (cons verified ()))) V13010) V13011 V13012 K12793 V13014)))))))))))) false))) false))) false)) false)) false)) false) (if (= C12798 false) (let C12804 (if (shen.unlocked? V13012) (do (shen.incinfs) (shen.system-S-h (shen.curry V13008) V13009 V13010 V13011 V13012 K12793 V13014)) false) (if (= C12804 false) (shen.unlock V13012 K12793) C12804)) C12798))))

(defun shen.t*-integrity (V13015 V13016 V13017 V13018 V13019 V13020 V13021 V13022) (let K12808 (+ V13021 1) (let C12814 (if (shen.unlocked? V13020) (let Tm12815 (shen.lazyderef V13015 V13019) (if (= Tm12815 ()) (let Tm12816 (shen.lazyderef V13017 V13019) (let GoTo12817 (freeze (do (shen.incinfs) (is! V13016 V13018 V13019 V13020 K12808 V13022))) (if (= Tm12816 ()) (thaw GoTo12817) (if (shen.pvar? Tm12816) (shen.bind! Tm12816 () V13019 GoTo12817) false)))) false)) false) (if (= C12814 false) (let C12818 (if (shen.unlocked? V13020) (let Tm12819 (shen.lazyderef V13015 V13019) (if (cons? Tm12819) (let P (hd Tm12819) (let Ps (tl Tm12819) (let Tm12820 (shen.lazyderef V13016 V13019) (if (cons? Tm12820) (let A (hd Tm12820) (let Tm12821 (shen.lazyderef (tl Tm12820) V13019) (if (cons? Tm12821) (let Tm12822 (shen.lazyderef (hd Tm12821) V13019) (if (= Tm12822 -->) (let Tm12823 (shen.lazyderef (tl Tm12821) V13019) (if (cons? Tm12823) (let B (hd Tm12823) (let Tm12824 (shen.lazyderef (tl Tm12823) V13019) (if (= Tm12824 ()) (let Tm12825 (shen.lazyderef V13017 V13019) (let GoTo12826 (lambda Hyp (lambda Hyps (let PHyps (shen.newpv V13019) (shen.gc V13019 (do (shen.incinfs) (bind Hyp (cons P (cons (intern ":") (cons A ()))) V13019 V13020 K12808 (freeze (shen.p-hyps P PHyps V13019 V13020 K12808 (freeze (shen.cut V13019 V13020 K12808 (freeze (shen.system-S-h P A PHyps V13019 V13020 K12808 (freeze (shen.cut V13019 V13020 K12808 (freeze (shen.t*-integrity Ps B Hyps V13018 V13019 V13020 K12808 V13022)))))))))))))))) (if (cons? Tm12825) (let Hyp (hd Tm12825) (let Hyps (tl Tm12825) ((GoTo12826 Hyp) Hyps))) (if (shen.pvar? Tm12825) (let Hyp (shen.newpv V13019) (shen.gc V13019 (let Hyps (shen.newpv V13019) (shen.gc V13019 (shen.bind! Tm12825 (cons Hyp Hyps) V13019 (freeze ((GoTo12826 Hyp) Hyps))))))) false)))) false))) false)) false)) false))) false)))) false)) false) (if (= C12818 false) (shen.unlock V13020 K12808) C12818)) C12814))))

(defun shen.p-hyps (V13023 V13024 V13025 V13026 V13027 V13028) (let K12829 (+ V13027 1) (let C12833 (if (shen.unlocked? V13026) (let A (shen.newpv V13025) (shen.gc V13025 (do (shen.incinfs) (when (shen.freshterm? (shen.deref V13023 V13025)) V13025 V13026 K12829 (freeze (shen.cut V13025 V13026 K12829 (freeze (bind V13024 (cons (cons V13023 (cons (intern ":") (cons A ()))) ()) V13025 V13026 K12829 V13028)))))))) false) (if (= C12833 false) (let C12834 (if (shen.unlocked? V13026) (let Tm12835 (shen.lazyderef V13023 V13025) (if (cons? Tm12835) (let X (hd Tm12835) (let Y (tl Tm12835) (let XHyps (shen.newpv V13025) (shen.gc V13025 (let YHyps (shen.newpv V13025) (shen.gc V13025 (do (shen.incinfs) (shen.cut V13025 V13026 K12829 (freeze (shen.p-hyps X XHyps V13025 V13026 K12829 (freeze (shen.p-hyps Y YHyps V13025 V13026 K12829 (freeze (shen.join XHyps YHyps V13024 V13025 V13026 K12829 V13028)))))))))))))) false)) false) (if (= C12834 false) (let C12836 (if (shen.unlocked? V13026) (do (shen.incinfs) (bind V13024 () V13025 V13026 K12829 V13028)) false) (if (= C12836 false) (shen.unlock V13026 K12829) C12836)) C12834)) C12833))))

(defun shen.freshterm? (V13029) (and (absvector? V13029) (and (not (string? V13029)) (= (<-address V13029 0) shen.print-freshterm))))

(defun shen.join (V13030 V13031 V13032 V13033 V13034 V13035 V13036) (let C12844 (if (shen.unlocked? V13034) (let Tm12845 (shen.lazyderef V13030 V13033) (if (= Tm12845 ()) (do (shen.incinfs) (bind V13032 V13031 V13033 V13034 V13035 V13036)) false)) false) (if (= C12844 false) (if (shen.unlocked? V13034) (let Tm12846 (shen.lazyderef V13030 V13033) (if (cons? Tm12846) (let X (hd Tm12846) (let Y (tl Tm12846) (let Tm12847 (shen.lazyderef V13032 V13033) (let GoTo12848 (lambda X* (lambda Z (do (shen.incinfs) (bind X* X V13033 V13034 V13035 (freeze (shen.join Y V13031 Z V13033 V13034 V13035 V13036)))))) (if (cons? Tm12847) (let X* (hd Tm12847) (let Z (tl Tm12847) ((GoTo12848 X*) Z))) (if (shen.pvar? Tm12847) (let X* (shen.newpv V13033) (shen.gc V13033 (let Z (shen.newpv V13033) (shen.gc V13033 (shen.bind! Tm12847 (cons X* Z) V13033 (freeze ((GoTo12848 X*) Z))))))) false)))))) false)) false) C12844)))

