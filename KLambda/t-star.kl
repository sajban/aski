(defun shen.typecheck (V4266 V4267) (let Vs (shen.extract-vars V4267) (let A* (shen.rectify-type V4267) (let Curried (shen.curry V4266) (((((lambda V3668 (lambda L3669 (lambda K3670 (lambda C3671 (let Out (shen.newpv V3668) (shen.gc V3668 (do (shen.incinfs) (shen.insert-prolog-variables (receive (shen.deref Vs V3668)) (receive (shen.deref A* V3668)) Out V3668 L3669 K3670 (freeze (shen.toplevel-forms (receive (shen.deref Curried V3668)) Out V3668 L3669 K3670 (freeze (return Out V3668 L3669 K3670 C3671)))))))))))) (shen.reset-prolog-vector)) (@v true (@v 0 (vector 0)))) 0) (freeze true))))))

(defun shen.insert-prolog-variables (V4268 V4269 V4270 V4271 V4272 V4273 V4274) (let C3680 (if (shen.unlocked? V4272) (let Tm3681 (shen.lazyderef V4268 V4271) (if (= Tm3681 ()) (do (shen.incinfs) (is! V4269 V4270 V4271 V4272 V4273 V4274)) false)) false) (if (= C3680 false) (if (shen.unlocked? V4272) (let Tm3682 (shen.lazyderef V4268 V4271) (if (cons? Tm3682) (let V (hd Tm3682) (let Vs (tl Tm3682) (let X (shen.newpv V4271) (shen.gc V4271 (do (shen.incinfs) (shen.insert-prolog-variables Vs (subst (shen.deref X V4271) V V4269) V4270 V4271 V4272 V4273 V4274)))))) false)) false) C3680)))

(defun shen.toplevel-forms (V4275 V4276 V4277 V4278 V4279 V4280) (let K3685 (+ V4279 1) (let C3689 (if (shen.unlocked? V4278) (let Tm3690 (shen.lazyderef V4275 V4277) (if (cons? Tm3690) (let Tm3691 (shen.lazyderef (hd Tm3690) V4277) (if (= Tm3691 define) (let Tm3692 (shen.lazyderef (tl Tm3690) V4277) (if (cons? Tm3692) (let F (hd Tm3692) (let X (tl Tm3692) (do (shen.incinfs) (shen.cut V4277 V4278 K3685 (freeze (shen.signal-def (value shen.*spy*) F V4277 V4278 K3685 (freeze (shen.t* (cons define (cons F X)) V4276 V4277 V4278 K3685 V4280)))))))) false)) false)) false)) false) (if (= C3689 false) (let C3693 (if (shen.unlocked? V4278) (do (shen.incinfs) (shen.system-S (cons V4275 (cons (intern ":") (cons V4276 ()))) () V4277 V4278 K3685 V4280)) false) (if (= C3693 false) (shen.unlock V4278 K3685) C3693)) C3689))))

(defun shen.signal-def (V4281 V4282 V4283 V4284 V4285 V4286) (let C3700 (if (shen.unlocked? V4284) (let Tm3701 (shen.lazyderef V4281 V4283) (if (= Tm3701 false) (do (shen.incinfs) (thaw V4286)) false)) false) (if (= C3700 false) (if (shen.unlocked? V4284) (let Tm3702 (shen.lazyderef V4281 V4283) (if (= Tm3702 true) (let ShowF (shen.newpv V4283) (shen.gc V4283 (do (shen.incinfs) (is ShowF (pr (cn "
typechecking (fn " (shen.app (shen.deref V4282 V4283) ")
" shen.a)) (stoutput)) V4283 V4284 V4285 V4286)))) false)) false) C3700)))

(defun shen.rectify-type (V4287) (shen.demodulate (shen.curry-type V4287)))

(defun shen.demodulate (V4288) (trap-error (let Demod (shen.walk (lambda Y (shen.demod Y)) V4288) (if (= Demod V4288) V4288 (shen.demodulate Demod))) (lambda E V4288)))

(defun shen.curry-type (V4289) (cond ((and (cons? V4289) (and (cons? (tl V4289)) (and (= --> (hd (tl V4289))) (and (cons? (tl (tl V4289))) (and (cons? (tl (tl (tl V4289)))) (= --> (hd (tl (tl (tl V4289)))))))))) (shen.curry-type (cons (hd V4289) (cons --> (cons (tl (tl V4289)) ()))))) ((and (cons? V4289) (and (cons? (tl V4289)) (and (= ==> (hd (tl V4289))) (and (cons? (tl (tl V4289))) (= () (tl (tl (tl V4289)))))))) (shen.curry-type (cons (cons (hd V4289) (cons * (cons (protect A) ()))) (cons --> (cons (cons (cons vector (cons boolean ())) (cons --> (cons (cons (hd V4289) (cons * (tl (tl V4289)))) ()))) ()))))) ((and (cons? V4289) (and (cons? (tl V4289)) (and (= * (hd (tl V4289))) (and (cons? (tl (tl V4289))) (and (cons? (tl (tl (tl V4289)))) (= * (hd (tl (tl (tl V4289)))))))))) (shen.curry-type (cons (hd V4289) (cons * (cons (tl (tl V4289)) ()))))) ((cons? V4289) (map (lambda Z (shen.curry-type Z)) V4289)) (true V4289)))

(defun shen.curry (V4290) (cond ((and (cons? V4290) (and (= define (hd V4290)) (cons? (tl V4290)))) V4290) ((and (cons? V4290) (and (= type (hd V4290)) (and (cons? (tl V4290)) (and (cons? (tl (tl V4290))) (= () (tl (tl (tl V4290)))))))) (cons type (cons (shen.curry (hd (tl V4290))) (tl (tl V4290))))) ((and (cons? V4290) (and (= input+ (hd V4290)) (and (cons? (tl V4290)) (and (cons? (tl (tl V4290))) (= () (tl (tl (tl V4290)))))))) (cons input+ (cons (hd (tl V4290)) (cons (shen.curry (hd (tl (tl V4290)))) ())))) ((and (cons? V4290) (shen.special? (hd V4290))) (cons (hd V4290) (map (lambda Y (shen.curry Y)) (tl V4290)))) ((and (cons? V4290) (shen.extraspecial? (hd V4290))) V4290) ((and (cons? V4290) (and (cons? (tl V4290)) (cons? (tl (tl V4290))))) (shen.curry (cons (cons (hd V4290) (cons (hd (tl V4290)) ())) (tl (tl V4290))))) ((and (cons? V4290) (and (cons? (tl V4290)) (= () (tl (tl V4290))))) (cons (shen.curry (hd V4290)) (cons (shen.curry (hd (tl V4290))) ()))) (true V4290)))

(defun shen.special? (V4291) (element? V4291 (value shen.*special*)))

(defun shen.extraspecial? (V4292) (element? V4292 (value shen.*extraspecial*)))

(defun shen.system-S (V4293 V4294 V4295 V4296 V4297 V4298) (let K3705 (+ V4297 1) (let C3709 (if (shen.unlocked? V4296) (do (shen.incinfs) (when (shen.maxinfexceeded?) V4295 V4296 K3705 V4298)) false) (if (= C3709 false) (let C3710 (if (shen.unlocked? V4296) (let Tm3711 (shen.lazyderef V4293 V4295) (if (cons? Tm3711) (let X (hd Tm3711) (let Tm3712 (shen.lazyderef (tl Tm3711) V4295) (if (cons? Tm3712) (let Colon (hd Tm3712) (let Tm3713 (shen.lazyderef (tl Tm3712) V4295) (if (cons? Tm3713) (let A (hd Tm3713) (let Tm3714 (shen.lazyderef (tl Tm3713) V4295) (if (= Tm3714 ()) (do (shen.incinfs) (when (= (shen.deref Colon V4295) (intern ":")) V4295 V4296 K3705 (freeze (when (shen.type-theory-enabled?) V4295 V4296 K3705 (freeze (shen.cut V4295 V4296 K3705 (freeze (shen.system-S-h X A V4294 V4295 V4296 K3705 V4298)))))))) false))) false))) false))) false)) false) (if (= C3710 false) (let C3715 (if (shen.unlocked? V4296) (do (shen.incinfs) (when (value shen.*spy*) V4295 V4296 K3705 (freeze (shen.show V4293 V4294 V4295 V4296 K3705 V4298)))) false) (if (= C3715 false) (let C3716 (if (shen.unlocked? V4296) (do (shen.incinfs) (shen.search-user-datatypes V4293 V4294 (value shen.*datatypes*) V4295 V4296 K3705 V4298)) false) (if (= C3716 false) (shen.unlock V4296 K3705) C3716)) C3715)) C3710)) C3709))))

(defun shen.show (V4305 V4306 V4307 V4308 V4309 V4310) (do (shen.line) (do (shen.show-p (shen.deref V4305 V4307)) (do (nl 2) (do (shen.show-assumptions (shen.deref V4306 V4307) 1) (do (shen.pause-for-user) false))))))

(defun shen.line () (let Infs (inferences) (pr (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V4311) (cond ((and (cons? V4311) (and (cons? (tl V4311)) (and (cons? (tl (tl V4311))) (and (= () (tl (tl (tl V4311)))) (= (hd (tl V4311)) (intern ":")))))) (do (shen.prterm (hd V4311)) (do (pr " : " (stoutput)) (pr (shen.app (hd (tl (tl V4311))) "" shen.r) (stoutput))))) (true (shen.prterm V4311))))

(defun shen.prterm (V4312) (cond ((and (cons? V4312) (and (= cons (hd V4312)) (and (cons? (tl V4312)) (and (cons? (tl (tl V4312))) (= () (tl (tl (tl V4312)))))))) (do (pr "[" (stoutput)) (do (shen.prterm (hd (tl V4312))) (do (shen.prtl (hd (tl (tl V4312)))) (pr "]" (stoutput)))))) ((cons? V4312) (do (pr "(" (stoutput)) (do (shen.prterm (hd V4312)) (do (map (lambda Y (do (pr " " (stoutput)) (shen.prterm Y))) (tl V4312)) (pr ")" (stoutput)))))) (true (print V4312))))

(defun shen.prtl (V4313) (cond ((= () V4313) "") ((and (cons? V4313) (and (= cons (hd V4313)) (and (cons? (tl V4313)) (and (cons? (tl (tl V4313))) (= () (tl (tl (tl V4313)))))))) (do (pr " " (stoutput)) (do (shen.prterm (hd (tl V4313))) (shen.prtl (hd (tl (tl V4313))))))) (true (do (pr " | " (stoutput)) (shen.prterm V4313)))))

(defun shen.show-assumptions (V4320 V4321) (cond ((= () V4320) (pr "
> " (stoutput))) ((cons? V4320) (do (pr (shen.app V4321 ". " shen.a) (stoutput)) (do (shen.show-p (hd V4320)) (do (nl 1) (shen.show-assumptions (tl V4320) (+ V4321 1)))))) (true (simple-error "implementation error in shen.show-assumptions"))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun shen.maxinfexceeded? () (if (> (inferences) (value shen.*maxinferences*)) (simple-error "maximum inferences exceeded") false))

(defun shen.system-S-h (V4322 V4323 V4324 V4325 V4326 V4327 V4328) (let K3720 (+ V4327 1) (let C3725 (if (shen.unlocked? V4326) (do (shen.incinfs) (when (value shen.*spy*) V4325 V4326 K3720 (freeze (shen.show (cons V4322 (cons (intern ":") (cons V4323 ()))) V4324 V4325 V4326 K3720 V4328)))) false) (if (= C3725 false) (let C3726 (if (shen.unlocked? V4326) (do (shen.incinfs) (when (not (cons? (shen.lazyderef V4322 V4325))) V4325 V4326 K3720 (freeze (shen.primitive V4322 V4323 V4325 V4326 K3720 V4328)))) false) (if (= C3726 false) (let C3727 (if (shen.unlocked? V4326) (do (shen.incinfs) (shen.by-hypothesis V4322 V4323 V4324 V4325 V4326 K3720 V4328)) false) (if (= C3727 false) (let C3728 (if (shen.unlocked? V4326) (let Tm3729 (shen.lazyderef V4322 V4325) (if (cons? Tm3729) (let F (hd Tm3729) (let Tm3730 (shen.lazyderef (tl Tm3729) V4325) (if (= Tm3730 ()) (do (shen.incinfs) (shen.lookupsig F (cons --> (cons V4323 ())) V4325 V4326 K3720 V4328)) false))) false)) false) (if (= C3728 false) (let C3731 (if (shen.unlocked? V4326) (let Tm3732 (shen.lazyderef V4322 V4325) (if (cons? Tm3732) (let Tm3733 (shen.lazyderef (hd Tm3732) V4325) (if (= Tm3733 fn) (let Tm3734 (shen.lazyderef (tl Tm3732) V4325) (if (cons? Tm3734) (let F (hd Tm3734) (let Tm3735 (shen.lazyderef (tl Tm3734) V4325) (if (= Tm3735 ()) (do (shen.incinfs) (shen.lookupsig F V4323 V4325 V4326 K3720 V4328)) false))) false)) false)) false)) false) (if (= C3731 false) (let C3736 (if (shen.unlocked? V4326) (let Tm3737 (shen.lazyderef V4322 V4325) (if (cons? Tm3737) (let F (hd Tm3737) (let Tm3738 (shen.lazyderef (tl Tm3737) V4325) (if (cons? Tm3738) (let X (hd Tm3738) (let Tm3739 (shen.lazyderef (tl Tm3738) V4325) (if (= Tm3739 ()) (let B (shen.newpv V4325) (shen.gc V4325 (do (shen.incinfs) (when (not (cons? (shen.lazyderef F V4325))) V4325 V4326 K3720 (freeze (shen.lookupsig F (cons B (cons --> (cons V4323 ()))) V4325 V4326 K3720 (freeze (shen.system-S-h X B V4324 V4325 V4326 K3720 V4328)))))))) false))) false))) false)) false) (if (= C3736 false) (let C3740 (if (shen.unlocked? V4326) (let Tm3741 (shen.lazyderef V4322 V4325) (if (cons? Tm3741) (let F (hd Tm3741) (let Tm3742 (shen.lazyderef (tl Tm3741) V4325) (if (cons? Tm3742) (let X (hd Tm3742) (let Tm3743 (shen.lazyderef (tl Tm3742) V4325) (if (= Tm3743 ()) (let B (shen.newpv V4325) (shen.gc V4325 (do (shen.incinfs) (shen.system-S-h F (cons B (cons --> (cons V4323 ()))) V4324 V4325 V4326 K3720 (freeze (shen.system-S-h X B V4324 V4325 V4326 K3720 V4328)))))) false))) false))) false)) false) (if (= C3740 false) (let C3744 (if (shen.unlocked? V4326) (let Tm3745 (shen.lazyderef V4322 V4325) (if (cons? Tm3745) (let Tm3746 (shen.lazyderef (hd Tm3745) V4325) (if (= Tm3746 cons) (let Tm3747 (shen.lazyderef (tl Tm3745) V4325) (if (cons? Tm3747) (let X (hd Tm3747) (let Tm3748 (shen.lazyderef (tl Tm3747) V4325) (if (cons? Tm3748) (let Y (hd Tm3748) (let Tm3749 (shen.lazyderef (tl Tm3748) V4325) (if (= Tm3749 ()) (let Tm3750 (shen.lazyderef V4323 V4325) (let GoTo3751 (lambda A (do (shen.incinfs) (shen.system-S-h X A V4324 V4325 V4326 K3720 (freeze (shen.system-S-h Y (cons list (cons A ())) V4324 V4325 V4326 K3720 V4328))))) (if (cons? Tm3750) (let Tm3752 (shen.lazyderef (hd Tm3750) V4325) (let GoTo3753 (freeze (let Tm3754 (shen.lazyderef (tl Tm3750) V4325) (let GoTo3755 (lambda A (GoTo3751 A)) (if (cons? Tm3754) (let A (hd Tm3754) (let Tm3756 (shen.lazyderef (tl Tm3754) V4325) (let GoTo3757 (freeze (GoTo3755 A)) (if (= Tm3756 ()) (thaw GoTo3757) (if (shen.pvar? Tm3756) (shen.bind! Tm3756 () V4325 GoTo3757) false))))) (if (shen.pvar? Tm3754) (let A (shen.newpv V4325) (shen.gc V4325 (shen.bind! Tm3754 (cons A ()) V4325 (freeze (GoTo3755 A))))) false))))) (if (= Tm3752 list) (thaw GoTo3753) (if (shen.pvar? Tm3752) (shen.bind! Tm3752 list V4325 GoTo3753) false)))) (if (shen.pvar? Tm3750) (let A (shen.newpv V4325) (shen.gc V4325 (shen.bind! Tm3750 (cons list (cons A ())) V4325 (freeze (GoTo3751 A))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3744 false) (let C3758 (if (shen.unlocked? V4326) (let Tm3759 (shen.lazyderef V4322 V4325) (if (cons? Tm3759) (let Tm3760 (shen.lazyderef (hd Tm3759) V4325) (if (= Tm3760 @p) (let Tm3761 (shen.lazyderef (tl Tm3759) V4325) (if (cons? Tm3761) (let X (hd Tm3761) (let Tm3762 (shen.lazyderef (tl Tm3761) V4325) (if (cons? Tm3762) (let Y (hd Tm3762) (let Tm3763 (shen.lazyderef (tl Tm3762) V4325) (if (= Tm3763 ()) (let Tm3764 (shen.lazyderef V4323 V4325) (let GoTo3765 (lambda A (lambda B (do (shen.incinfs) (shen.system-S-h X A V4324 V4325 V4326 K3720 (freeze (shen.system-S-h Y B V4324 V4325 V4326 K3720 V4328)))))) (if (cons? Tm3764) (let A (hd Tm3764) (let Tm3766 (shen.lazyderef (tl Tm3764) V4325) (let GoTo3767 (lambda B ((GoTo3765 A) B)) (if (cons? Tm3766) (let Tm3768 (shen.lazyderef (hd Tm3766) V4325) (let GoTo3769 (freeze (let Tm3770 (shen.lazyderef (tl Tm3766) V4325) (let GoTo3771 (lambda B (GoTo3767 B)) (if (cons? Tm3770) (let B (hd Tm3770) (let Tm3772 (shen.lazyderef (tl Tm3770) V4325) (let GoTo3773 (freeze (GoTo3771 B)) (if (= Tm3772 ()) (thaw GoTo3773) (if (shen.pvar? Tm3772) (shen.bind! Tm3772 () V4325 GoTo3773) false))))) (if (shen.pvar? Tm3770) (let B (shen.newpv V4325) (shen.gc V4325 (shen.bind! Tm3770 (cons B ()) V4325 (freeze (GoTo3771 B))))) false))))) (if (= Tm3768 *) (thaw GoTo3769) (if (shen.pvar? Tm3768) (shen.bind! Tm3768 * V4325 GoTo3769) false)))) (if (shen.pvar? Tm3766) (let B (shen.newpv V4325) (shen.gc V4325 (shen.bind! Tm3766 (cons * (cons B ())) V4325 (freeze (GoTo3767 B))))) false))))) (if (shen.pvar? Tm3764) (let A (shen.newpv V4325) (shen.gc V4325 (let B (shen.newpv V4325) (shen.gc V4325 (shen.bind! Tm3764 (cons A (cons * (cons B ()))) V4325 (freeze ((GoTo3765 A) B))))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3758 false) (let C3774 (if (shen.unlocked? V4326) (let Tm3775 (shen.lazyderef V4322 V4325) (if (cons? Tm3775) (let Tm3776 (shen.lazyderef (hd Tm3775) V4325) (if (= Tm3776 @v) (let Tm3777 (shen.lazyderef (tl Tm3775) V4325) (if (cons? Tm3777) (let X (hd Tm3777) (let Tm3778 (shen.lazyderef (tl Tm3777) V4325) (if (cons? Tm3778) (let Y (hd Tm3778) (let Tm3779 (shen.lazyderef (tl Tm3778) V4325) (if (= Tm3779 ()) (let Tm3780 (shen.lazyderef V4323 V4325) (let GoTo3781 (lambda A (do (shen.incinfs) (shen.system-S-h X A V4324 V4325 V4326 K3720 (freeze (shen.system-S-h Y (cons vector (cons A ())) V4324 V4325 V4326 K3720 V4328))))) (if (cons? Tm3780) (let Tm3782 (shen.lazyderef (hd Tm3780) V4325) (let GoTo3783 (freeze (let Tm3784 (shen.lazyderef (tl Tm3780) V4325) (let GoTo3785 (lambda A (GoTo3781 A)) (if (cons? Tm3784) (let A (hd Tm3784) (let Tm3786 (shen.lazyderef (tl Tm3784) V4325) (let GoTo3787 (freeze (GoTo3785 A)) (if (= Tm3786 ()) (thaw GoTo3787) (if (shen.pvar? Tm3786) (shen.bind! Tm3786 () V4325 GoTo3787) false))))) (if (shen.pvar? Tm3784) (let A (shen.newpv V4325) (shen.gc V4325 (shen.bind! Tm3784 (cons A ()) V4325 (freeze (GoTo3785 A))))) false))))) (if (= Tm3782 vector) (thaw GoTo3783) (if (shen.pvar? Tm3782) (shen.bind! Tm3782 vector V4325 GoTo3783) false)))) (if (shen.pvar? Tm3780) (let A (shen.newpv V4325) (shen.gc V4325 (shen.bind! Tm3780 (cons vector (cons A ())) V4325 (freeze (GoTo3781 A))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3774 false) (let C3788 (if (shen.unlocked? V4326) (let Tm3789 (shen.lazyderef V4322 V4325) (if (cons? Tm3789) (let Tm3790 (shen.lazyderef (hd Tm3789) V4325) (if (= Tm3790 @s) (let Tm3791 (shen.lazyderef (tl Tm3789) V4325) (if (cons? Tm3791) (let X (hd Tm3791) (let Tm3792 (shen.lazyderef (tl Tm3791) V4325) (if (cons? Tm3792) (let Y (hd Tm3792) (let Tm3793 (shen.lazyderef (tl Tm3792) V4325) (if (= Tm3793 ()) (let Tm3794 (shen.lazyderef V4323 V4325) (let GoTo3795 (freeze (do (shen.incinfs) (shen.system-S-h X string V4324 V4325 V4326 K3720 (freeze (shen.system-S-h Y string V4324 V4325 V4326 K3720 V4328))))) (if (= Tm3794 string) (thaw GoTo3795) (if (shen.pvar? Tm3794) (shen.bind! Tm3794 string V4325 GoTo3795) false)))) false))) false))) false)) false)) false)) false) (if (= C3788 false) (let C3796 (if (shen.unlocked? V4326) (let Tm3797 (shen.lazyderef V4322 V4325) (if (cons? Tm3797) (let Tm3798 (shen.lazyderef (hd Tm3797) V4325) (if (= Tm3798 lambda) (let Tm3799 (shen.lazyderef (tl Tm3797) V4325) (if (cons? Tm3799) (let X (hd Tm3799) (let Tm3800 (shen.lazyderef (tl Tm3799) V4325) (if (cons? Tm3800) (let Y (hd Tm3800) (let Tm3801 (shen.lazyderef (tl Tm3800) V4325) (if (= Tm3801 ()) (let Tm3802 (shen.lazyderef V4323 V4325) (let GoTo3803 (lambda A (lambda B (let Z (shen.newpv V4325) (shen.gc V4325 (let New (shen.newpv V4325) (shen.gc V4325 (do (shen.incinfs) (bind New (shen.freshterm (shen.lazyderef X V4325)) V4325 V4326 K3720 (freeze (bind Z (shen.beta (shen.lazyderef X V4325) (shen.deref New V4325) (shen.deref Y V4325)) V4325 V4326 K3720 (freeze (shen.system-S-h Z B (cons (cons New (cons (intern ":") (cons A ()))) V4324) V4325 V4326 K3720 V4328)))))))))))) (if (cons? Tm3802) (let A (hd Tm3802) (let Tm3804 (shen.lazyderef (tl Tm3802) V4325) (let GoTo3805 (lambda B ((GoTo3803 A) B)) (if (cons? Tm3804) (let Tm3806 (shen.lazyderef (hd Tm3804) V4325) (let GoTo3807 (freeze (let Tm3808 (shen.lazyderef (tl Tm3804) V4325) (let GoTo3809 (lambda B (GoTo3805 B)) (if (cons? Tm3808) (let B (hd Tm3808) (let Tm3810 (shen.lazyderef (tl Tm3808) V4325) (let GoTo3811 (freeze (GoTo3809 B)) (if (= Tm3810 ()) (thaw GoTo3811) (if (shen.pvar? Tm3810) (shen.bind! Tm3810 () V4325 GoTo3811) false))))) (if (shen.pvar? Tm3808) (let B (shen.newpv V4325) (shen.gc V4325 (shen.bind! Tm3808 (cons B ()) V4325 (freeze (GoTo3809 B))))) false))))) (if (= Tm3806 -->) (thaw GoTo3807) (if (shen.pvar? Tm3806) (shen.bind! Tm3806 --> V4325 GoTo3807) false)))) (if (shen.pvar? Tm3804) (let B (shen.newpv V4325) (shen.gc V4325 (shen.bind! Tm3804 (cons --> (cons B ())) V4325 (freeze (GoTo3805 B))))) false))))) (if (shen.pvar? Tm3802) (let A (shen.newpv V4325) (shen.gc V4325 (let B (shen.newpv V4325) (shen.gc V4325 (shen.bind! Tm3802 (cons A (cons --> (cons B ()))) V4325 (freeze ((GoTo3803 A) B))))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3796 false) (let C3812 (if (shen.unlocked? V4326) (let Tm3813 (shen.lazyderef V4322 V4325) (if (cons? Tm3813) (let Tm3814 (shen.lazyderef (hd Tm3813) V4325) (if (= Tm3814 let) (let Tm3815 (shen.lazyderef (tl Tm3813) V4325) (if (cons? Tm3815) (let X (hd Tm3815) (let Tm3816 (shen.lazyderef (tl Tm3815) V4325) (if (cons? Tm3816) (let Y (hd Tm3816) (let Tm3817 (shen.lazyderef (tl Tm3816) V4325) (if (cons? Tm3817) (let Z (hd Tm3817) (let Tm3818 (shen.lazyderef (tl Tm3817) V4325) (if (= Tm3818 ()) (let W (shen.newpv V4325) (shen.gc V4325 (let New (shen.newpv V4325) (shen.gc V4325 (let B (shen.newpv V4325) (shen.gc V4325 (do (shen.incinfs) (shen.system-S-h Y B V4324 V4325 V4326 K3720 (freeze (bind New (shen.freshterm (shen.lazyderef X V4325)) V4325 V4326 K3720 (freeze (bind W (shen.beta (shen.lazyderef X V4325) (shen.lazyderef New V4325) (shen.lazyderef Z V4325)) V4325 V4326 K3720 (freeze (shen.system-S-h W V4323 (cons (cons New (cons (intern ":") (cons B ()))) V4324) V4325 V4326 K3720 V4328)))))))))))))) false))) false))) false))) false)) false)) false)) false) (if (= C3812 false) (let C3819 (if (shen.unlocked? V4326) (let Tm3820 (shen.lazyderef V4322 V4325) (if (cons? Tm3820) (let Tm3821 (shen.lazyderef (hd Tm3820) V4325) (if (= Tm3821 open) (let Tm3822 (shen.lazyderef (tl Tm3820) V4325) (if (cons? Tm3822) (let File (hd Tm3822) (let Tm3823 (shen.lazyderef (tl Tm3822) V4325) (if (cons? Tm3823) (let V3717 (hd Tm3823) (let Tm3824 (shen.lazyderef (tl Tm3823) V4325) (if (= Tm3824 ()) (let Tm3825 (shen.lazyderef V4323 V4325) (let GoTo3826 (lambda D (do (shen.incinfs) (is! V3717 D V4325 V4326 K3720 (freeze (when (element? (shen.lazyderef D V4325) (cons in (cons out ()))) V4325 V4326 K3720 (freeze (shen.system-S-h File string V4324 V4325 V4326 K3720 V4328))))))) (if (cons? Tm3825) (let Tm3827 (shen.lazyderef (hd Tm3825) V4325) (let GoTo3828 (freeze (let Tm3829 (shen.lazyderef (tl Tm3825) V4325) (let GoTo3830 (lambda D (GoTo3826 D)) (if (cons? Tm3829) (let D (hd Tm3829) (let Tm3831 (shen.lazyderef (tl Tm3829) V4325) (let GoTo3832 (freeze (GoTo3830 D)) (if (= Tm3831 ()) (thaw GoTo3832) (if (shen.pvar? Tm3831) (shen.bind! Tm3831 () V4325 GoTo3832) false))))) (if (shen.pvar? Tm3829) (let D (shen.newpv V4325) (shen.gc V4325 (shen.bind! Tm3829 (cons D ()) V4325 (freeze (GoTo3830 D))))) false))))) (if (= Tm3827 stream) (thaw GoTo3828) (if (shen.pvar? Tm3827) (shen.bind! Tm3827 stream V4325 GoTo3828) false)))) (if (shen.pvar? Tm3825) (let D (shen.newpv V4325) (shen.gc V4325 (shen.bind! Tm3825 (cons stream (cons D ())) V4325 (freeze (GoTo3826 D))))) false)))) false))) false))) false)) false)) false)) false) (if (= C3819 false) (let C3833 (if (shen.unlocked? V4326) (let Tm3834 (shen.lazyderef V4322 V4325) (if (cons? Tm3834) (let Tm3835 (shen.lazyderef (hd Tm3834) V4325) (if (= Tm3835 type) (let Tm3836 (shen.lazyderef (tl Tm3834) V4325) (if (cons? Tm3836) (let X (hd Tm3836) (let Tm3837 (shen.lazyderef (tl Tm3836) V4325) (if (cons? Tm3837) (let A (hd Tm3837) (let Tm3838 (shen.lazyderef (tl Tm3837) V4325) (if (= Tm3838 ()) (do (shen.incinfs) (shen.cut V4325 V4326 K3720 (freeze (is! (shen.rectify-type (shen.deref A V4325)) V4323 V4325 V4326 K3720 (freeze (shen.system-S-h X V4323 V4324 V4325 V4326 K3720 V4328)))))) false))) false))) false)) false)) false)) false) (if (= C3833 false) (let C3839 (if (shen.unlocked? V4326) (let Tm3840 (shen.lazyderef V4322 V4325) (if (cons? Tm3840) (let Tm3841 (shen.lazyderef (hd Tm3840) V4325) (if (= Tm3841 input+) (let Tm3842 (shen.lazyderef (tl Tm3840) V4325) (if (cons? Tm3842) (let A (hd Tm3842) (let Tm3843 (shen.lazyderef (tl Tm3842) V4325) (if (cons? Tm3843) (let Stream (hd Tm3843) (let Tm3844 (shen.lazyderef (tl Tm3843) V4325) (if (= Tm3844 ()) (do (shen.incinfs) (is! V4323 (shen.rectify-type (shen.deref A V4325)) V4325 V4326 K3720 (freeze (shen.system-S-h Stream (cons stream (cons in ())) V4324 V4325 V4326 K3720 V4328)))) false))) false))) false)) false)) false)) false) (if (= C3839 false) (let C3845 (if (shen.unlocked? V4326) (let Tm3846 (shen.lazyderef V4322 V4325) (if (cons? Tm3846) (let Tm3847 (shen.lazyderef (hd Tm3846) V4325) (if (= Tm3847 set) (let Tm3848 (shen.lazyderef (tl Tm3846) V4325) (if (cons? Tm3848) (let Var (hd Tm3848) (let Tm3849 (shen.lazyderef (tl Tm3848) V4325) (if (cons? Tm3849) (let Val (hd Tm3849) (let Tm3850 (shen.lazyderef (tl Tm3849) V4325) (if (= Tm3850 ()) (do (shen.incinfs) (shen.system-S-h Var symbol V4324 V4325 V4326 K3720 (freeze (shen.system-S-h (cons value (cons Var ())) V4323 V4324 V4325 V4326 K3720 (freeze (shen.system-S-h Val V4323 V4324 V4325 V4326 K3720 V4328)))))) false))) false))) false)) false)) false)) false) (if (= C3845 false) (let C3851 (if (shen.unlocked? V4326) (let Normalised (shen.newpv V4325) (shen.gc V4325 (do (shen.incinfs) (shen.l-rules V4324 Normalised false V4325 V4326 K3720 (freeze (shen.cut V4325 V4326 K3720 (freeze (shen.system-S-h V4322 V4323 Normalised V4325 V4326 K3720 V4328)))))))) false) (if (= C3851 false) (let C3852 (if (shen.unlocked? V4326) (do (shen.incinfs) (shen.search-user-datatypes (cons V4322 (cons (intern ":") (cons V4323 ()))) V4324 (value shen.*datatypes*) V4325 V4326 K3720 V4328)) false) (if (= C3852 false) (shen.unlock V4326 K3720) C3852)) C3851)) C3845)) C3839)) C3833)) C3819)) C3812)) C3796)) C3788)) C3774)) C3758)) C3744)) C3740)) C3736)) C3731)) C3728)) C3727)) C3726)) C3725))))

(defun shen.primitive (V4329 V4330 V4331 V4332 V4333 V4334) (let C3859 (if (shen.unlocked? V4332) (let Tm3860 (shen.lazyderef V4330 V4331) (let GoTo3861 (freeze (do (shen.incinfs) (when (number? (shen.lazyderef V4329 V4331)) V4331 V4332 V4333 V4334))) (if (= Tm3860 number) (thaw GoTo3861) (if (shen.pvar? Tm3860) (shen.bind! Tm3860 number V4331 GoTo3861) false)))) false) (if (= C3859 false) (let C3862 (if (shen.unlocked? V4332) (let Tm3863 (shen.lazyderef V4330 V4331) (let GoTo3864 (freeze (do (shen.incinfs) (when (boolean? (shen.lazyderef V4329 V4331)) V4331 V4332 V4333 V4334))) (if (= Tm3863 boolean) (thaw GoTo3864) (if (shen.pvar? Tm3863) (shen.bind! Tm3863 boolean V4331 GoTo3864) false)))) false) (if (= C3862 false) (let C3865 (if (shen.unlocked? V4332) (let Tm3866 (shen.lazyderef V4330 V4331) (let GoTo3867 (freeze (do (shen.incinfs) (when (string? (shen.lazyderef V4329 V4331)) V4331 V4332 V4333 V4334))) (if (= Tm3866 string) (thaw GoTo3867) (if (shen.pvar? Tm3866) (shen.bind! Tm3866 string V4331 GoTo3867) false)))) false) (if (= C3865 false) (let C3868 (if (shen.unlocked? V4332) (let Tm3869 (shen.lazyderef V4330 V4331) (let GoTo3870 (freeze (do (shen.incinfs) (when (symbol? (shen.lazyderef V4329 V4331)) V4331 V4332 V4333 V4334))) (if (= Tm3869 symbol) (thaw GoTo3870) (if (shen.pvar? Tm3869) (shen.bind! Tm3869 symbol V4331 GoTo3870) false)))) false) (if (= C3868 false) (if (shen.unlocked? V4332) (let Tm3871 (shen.lazyderef V4329 V4331) (if (= Tm3871 ()) (let Tm3872 (shen.lazyderef V4330 V4331) (let GoTo3873 (lambda A (do (shen.incinfs) (thaw V4334))) (if (cons? Tm3872) (let Tm3874 (shen.lazyderef (hd Tm3872) V4331) (let GoTo3875 (freeze (let Tm3876 (shen.lazyderef (tl Tm3872) V4331) (let GoTo3877 (lambda A (GoTo3873 A)) (if (cons? Tm3876) (let A (hd Tm3876) (let Tm3878 (shen.lazyderef (tl Tm3876) V4331) (let GoTo3879 (freeze (GoTo3877 A)) (if (= Tm3878 ()) (thaw GoTo3879) (if (shen.pvar? Tm3878) (shen.bind! Tm3878 () V4331 GoTo3879) false))))) (if (shen.pvar? Tm3876) (let A (shen.newpv V4331) (shen.gc V4331 (shen.bind! Tm3876 (cons A ()) V4331 (freeze (GoTo3877 A))))) false))))) (if (= Tm3874 list) (thaw GoTo3875) (if (shen.pvar? Tm3874) (shen.bind! Tm3874 list V4331 GoTo3875) false)))) (if (shen.pvar? Tm3872) (let A (shen.newpv V4331) (shen.gc V4331 (shen.bind! Tm3872 (cons list (cons A ())) V4331 (freeze (GoTo3873 A))))) false)))) false)) false) C3868)) C3865)) C3862)) C3859)))

(defun shen.by-hypothesis (V4335 V4336 V4337 V4338 V4339 V4340 V4341) (let C3887 (if (shen.unlocked? V4339) (let Tm3888 (shen.lazyderef V4337 V4338) (if (cons? Tm3888) (let Tm3889 (shen.lazyderef (hd Tm3888) V4338) (if (cons? Tm3889) (let Y (hd Tm3889) (let Tm3890 (shen.lazyderef (tl Tm3889) V4338) (if (cons? Tm3890) (let Colon (hd Tm3890) (let Tm3891 (shen.lazyderef (tl Tm3890) V4338) (if (cons? Tm3891) (let B (hd Tm3891) (let Tm3892 (shen.lazyderef (tl Tm3891) V4338) (if (= Tm3892 ()) (do (shen.incinfs) (when (= (shen.deref Colon V4338) (intern ":")) V4338 V4339 V4340 (freeze (when (= (shen.deref V4335 V4338) (shen.deref Y V4338)) V4338 V4339 V4340 (freeze (is! V4336 B V4338 V4339 V4340 V4341)))))) false))) false))) false))) false)) false)) false) (if (= C3887 false) (if (shen.unlocked? V4339) (let Tm3893 (shen.lazyderef V4337 V4338) (if (cons? Tm3893) (let Hyp (tl Tm3893) (do (shen.incinfs) (shen.by-hypothesis V4335 V4336 Hyp V4338 V4339 V4340 V4341))) false)) false) C3887)))

(defun shen.lookupsig (V4342 V4343 V4344 V4345 V4346 V4347) (if (shen.unlocked? V4345) (do (shen.incinfs) (shen.sigf (assoc V4342 (value shen.*sigf*)) V4343 V4344 V4345 V4346 V4347)) false))

(defun shen.sigf (V4362 V4363 V4364 V4365 V4366 V4367) (cond ((cons? V4362) ((((((tl V4362) V4363) V4364) V4365) V4366) V4367)) (true false)))

(defun shen.freshterm (V4368) (let V (absvector 3) (let V0 (address-> V 0 shen.print-freshterm) (let V1 (address-> V0 1 V4368) (let V2 (address-> V1 2 (set shen.*gensym* (+ 1 (value shen.*gensym*)))) V2)))))

(defun shen.print-freshterm (V4369) (cn "&&" (str (<-address V4369 1))))

(defun shen.search-user-datatypes (V4370 V4371 V4372 V4373 V4374 V4375 V4376) (let C3907 (if (shen.unlocked? V4374) (let Tm3908 (shen.lazyderef V4372 V4373) (if (cons? Tm3908) (let Tm3909 (shen.lazyderef (hd Tm3908) V4373) (if (cons? Tm3909) (let Fn (tl Tm3909) (do (shen.incinfs) (call (((shen.deref Fn V4373) (shen.deref V4370 V4373)) (shen.deref V4371 V4373)) V4373 V4374 V4375 V4376))) false)) false)) false) (if (= C3907 false) (if (shen.unlocked? V4374) (let Tm3910 (shen.lazyderef V4372 V4373) (if (cons? Tm3910) (let Ds (tl Tm3910) (do (shen.incinfs) (shen.search-user-datatypes V4370 V4371 Ds V4373 V4374 V4375 V4376))) false)) false) C3907)))

(defun shen.l-rules (V4377 V4378 V4379 V4380 V4381 V4382 V4383) (let K3913 (+ V4382 1) (let C3918 (if (shen.unlocked? V4381) (let Tm3919 (shen.lazyderef V4377 V4380) (if (= Tm3919 ()) (let Tm3920 (shen.lazyderef V4379 V4380) (if (= Tm3920 true) (do (shen.incinfs) (shen.cut V4380 V4381 K3913 (freeze (bind V4378 () V4380 V4381 K3913 V4383)))) false)) false)) false) (if (= C3918 false) (let C3921 (if (shen.unlocked? V4381) (let Tm3922 (shen.lazyderef V4377 V4380) (if (cons? Tm3922) (let Tm3923 (shen.lazyderef (hd Tm3922) V4380) (if (cons? Tm3923) (let Tm3924 (shen.lazyderef (hd Tm3923) V4380) (if (cons? Tm3924) (let Tm3925 (shen.lazyderef (hd Tm3924) V4380) (if (= Tm3925 cons) (let Tm3926 (shen.lazyderef (tl Tm3924) V4380) (if (cons? Tm3926) (let X (hd Tm3926) (let Tm3927 (shen.lazyderef (tl Tm3926) V4380) (if (cons? Tm3927) (let Y (hd Tm3927) (let Tm3928 (shen.lazyderef (tl Tm3927) V4380) (if (= Tm3928 ()) (let Tm3929 (shen.lazyderef (tl Tm3923) V4380) (if (cons? Tm3929) (let Colon (hd Tm3929) (let Tm3930 (shen.lazyderef (tl Tm3929) V4380) (if (cons? Tm3930) (let Tm3931 (shen.lazyderef (hd Tm3930) V4380) (if (cons? Tm3931) (let Tm3932 (shen.lazyderef (hd Tm3931) V4380) (if (= Tm3932 list) (let Tm3933 (shen.lazyderef (tl Tm3931) V4380) (if (cons? Tm3933) (let A (hd Tm3933) (let Tm3934 (shen.lazyderef (tl Tm3933) V4380) (if (= Tm3934 ()) (let Tm3935 (shen.lazyderef (tl Tm3930) V4380) (if (= Tm3935 ()) (let Hyp (tl Tm3922) (do (shen.incinfs) (when (= (shen.deref Colon V4380) (intern ":")) V4380 V4381 K3913 (freeze (shen.cut V4380 V4381 K3913 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons (cons list (cons A ())) ()))) Hyp)) V4378 true V4380 V4381 K3913 V4383))))))) false)) false))) false)) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C3921 false) (let C3936 (if (shen.unlocked? V4381) (let Tm3937 (shen.lazyderef V4377 V4380) (if (cons? Tm3937) (let Tm3938 (shen.lazyderef (hd Tm3937) V4380) (if (cons? Tm3938) (let Tm3939 (shen.lazyderef (hd Tm3938) V4380) (if (cons? Tm3939) (let Tm3940 (shen.lazyderef (hd Tm3939) V4380) (if (= Tm3940 @p) (let Tm3941 (shen.lazyderef (tl Tm3939) V4380) (if (cons? Tm3941) (let X (hd Tm3941) (let Tm3942 (shen.lazyderef (tl Tm3941) V4380) (if (cons? Tm3942) (let Y (hd Tm3942) (let Tm3943 (shen.lazyderef (tl Tm3942) V4380) (if (= Tm3943 ()) (let Tm3944 (shen.lazyderef (tl Tm3938) V4380) (if (cons? Tm3944) (let Colon (hd Tm3944) (let Tm3945 (shen.lazyderef (tl Tm3944) V4380) (if (cons? Tm3945) (let Tm3946 (shen.lazyderef (hd Tm3945) V4380) (if (cons? Tm3946) (let A (hd Tm3946) (let Tm3947 (shen.lazyderef (tl Tm3946) V4380) (if (cons? Tm3947) (let Tm3948 (shen.lazyderef (hd Tm3947) V4380) (if (= Tm3948 *) (let Tm3949 (shen.lazyderef (tl Tm3947) V4380) (if (cons? Tm3949) (let B (hd Tm3949) (let Tm3950 (shen.lazyderef (tl Tm3949) V4380) (if (= Tm3950 ()) (let Tm3951 (shen.lazyderef (tl Tm3945) V4380) (if (= Tm3951 ()) (let Hyp (tl Tm3937) (do (shen.incinfs) (when (= (shen.deref Colon V4380) (intern ":")) V4380 V4381 K3913 (freeze (shen.cut V4380 V4381 K3913 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons B ()))) Hyp)) V4378 true V4380 V4381 K3913 V4383))))))) false)) false))) false)) false)) false))) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C3936 false) (let C3952 (if (shen.unlocked? V4381) (let Tm3953 (shen.lazyderef V4377 V4380) (if (cons? Tm3953) (let Tm3954 (shen.lazyderef (hd Tm3953) V4380) (if (cons? Tm3954) (let Tm3955 (shen.lazyderef (hd Tm3954) V4380) (if (cons? Tm3955) (let Tm3956 (shen.lazyderef (hd Tm3955) V4380) (if (= Tm3956 @s) (let Tm3957 (shen.lazyderef (tl Tm3955) V4380) (if (cons? Tm3957) (let X (hd Tm3957) (let Tm3958 (shen.lazyderef (tl Tm3957) V4380) (if (cons? Tm3958) (let Y (hd Tm3958) (let Tm3959 (shen.lazyderef (tl Tm3958) V4380) (if (= Tm3959 ()) (let Tm3960 (shen.lazyderef (tl Tm3954) V4380) (if (cons? Tm3960) (let Colon (hd Tm3960) (let Tm3961 (shen.lazyderef (tl Tm3960) V4380) (if (cons? Tm3961) (let Tm3962 (shen.lazyderef (hd Tm3961) V4380) (if (= Tm3962 string) (let Tm3963 (shen.lazyderef (tl Tm3961) V4380) (if (= Tm3963 ()) (let Hyp (tl Tm3953) (do (shen.incinfs) (when (= (shen.deref Colon V4380) (intern ":")) V4380 V4381 K3913 (freeze (shen.cut V4380 V4381 K3913 (freeze (shen.l-rules (cons (cons X (cons Colon (cons string ()))) (cons (cons Y (cons Colon (cons string ()))) Hyp)) V4378 true V4380 V4381 K3913 V4383))))))) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C3952 false) (let C3964 (if (shen.unlocked? V4381) (let Tm3965 (shen.lazyderef V4377 V4380) (if (cons? Tm3965) (let Tm3966 (shen.lazyderef (hd Tm3965) V4380) (if (cons? Tm3966) (let Tm3967 (shen.lazyderef (hd Tm3966) V4380) (if (cons? Tm3967) (let Tm3968 (shen.lazyderef (hd Tm3967) V4380) (if (= Tm3968 @v) (let Tm3969 (shen.lazyderef (tl Tm3967) V4380) (if (cons? Tm3969) (let X (hd Tm3969) (let Tm3970 (shen.lazyderef (tl Tm3969) V4380) (if (cons? Tm3970) (let Y (hd Tm3970) (let Tm3971 (shen.lazyderef (tl Tm3970) V4380) (if (= Tm3971 ()) (let Tm3972 (shen.lazyderef (tl Tm3966) V4380) (if (cons? Tm3972) (let Colon (hd Tm3972) (let Tm3973 (shen.lazyderef (tl Tm3972) V4380) (if (cons? Tm3973) (let Tm3974 (shen.lazyderef (hd Tm3973) V4380) (if (cons? Tm3974) (let Tm3975 (shen.lazyderef (hd Tm3974) V4380) (if (= Tm3975 vector) (let Tm3976 (shen.lazyderef (tl Tm3974) V4380) (if (cons? Tm3976) (let A (hd Tm3976) (let Tm3977 (shen.lazyderef (tl Tm3976) V4380) (if (= Tm3977 ()) (let Tm3978 (shen.lazyderef (tl Tm3973) V4380) (if (= Tm3978 ()) (let Hyp (tl Tm3965) (do (shen.incinfs) (when (= (shen.deref Colon V4380) (intern ":")) V4380 V4381 K3913 (freeze (shen.cut V4380 V4381 K3913 (freeze (shen.l-rules (cons (cons X (cons Colon (cons A ()))) (cons (cons Y (cons Colon (cons (cons vector (cons A ())) ()))) Hyp)) V4378 true V4380 V4381 K3913 V4383))))))) false)) false))) false)) false)) false)) false))) false)) false))) false))) false)) false)) false)) false)) false)) false) (if (= C3964 false) (let C3979 (if (shen.unlocked? V4381) (let Tm3980 (shen.lazyderef V4377 V4380) (if (cons? Tm3980) (let P (hd Tm3980) (let Hyp (tl Tm3980) (let Tm3981 (shen.lazyderef V4378 V4380) (let GoTo3982 (lambda Q (lambda Normalised (do (shen.incinfs) (bind Q P V4380 V4381 K3913 (freeze (shen.l-rules Hyp Normalised V4379 V4380 V4381 K3913 V4383)))))) (if (cons? Tm3981) (let Q (hd Tm3981) (let Normalised (tl Tm3981) ((GoTo3982 Q) Normalised))) (if (shen.pvar? Tm3981) (let Q (shen.newpv V4380) (shen.gc V4380 (let Normalised (shen.newpv V4380) (shen.gc V4380 (shen.bind! Tm3981 (cons Q Normalised) V4380 (freeze ((GoTo3982 Q) Normalised))))))) false)))))) false)) false) (if (= C3979 false) (shen.unlock V4381 K3913) C3979)) C3964)) C3952)) C3936)) C3921)) C3918))))

(defun shen.t* (V4384 V4385 V4386 V4387 V4388 V4389) (let K3985 (+ V4388 1) (let C3989 (if (shen.unlocked? V4387) (let Tm3990 (shen.lazyderef V4384 V4386) (if (cons? Tm3990) (let Tm3991 (shen.lazyderef (hd Tm3990) V4386) (if (= Tm3991 define) (let Tm3992 (shen.lazyderef (tl Tm3990) V4386) (if (cons? Tm3992) (let F (hd Tm3992) (let X (tl Tm3992) (let SigxRules (shen.newpv V4386) (shen.gc V4386 (let Rules (shen.newpv V4386) (shen.gc V4386 (let FreshSig (shen.newpv V4386) (shen.gc V4386 (let Sig (shen.newpv V4386) (shen.gc V4386 (do (shen.incinfs) (shen.cut V4386 V4387 K3985 (freeze (bind SigxRules (shen.sigxrules (cons F X)) V4386 V4387 K3985 (freeze (bind Sig (fst (shen.lazyderef SigxRules V4386)) V4386 V4387 K3985 (freeze (bind Rules (snd (shen.lazyderef SigxRules V4386)) V4386 V4387 K3985 (freeze (bind FreshSig (shen.freshen-sig (shen.deref Sig V4386)) V4386 V4387 K3985 (freeze (shen.t*-rules F Rules FreshSig 1 V4386 V4387 K3985 (freeze (is Sig V4385 V4386 V4387 K3985 V4389)))))))))))))))))))))))) false)) false)) false)) false) (if (= C3989 false) (shen.unlock V4387 K3985) C3989))))

(defun shen.sigxrules (V4390) (compile (lambda X (shen.<sig*rules> X)) V4390))

(defun shen.<sig*rules> (V4391) (let Result (if (shen.non-empty-stream? V4391) (let F (shen.hds V4391) (let News3994 (shen.tls V4391) (if (shen.=hd? News3994 {) (let News3995 (shen.tls News3994) (let Parseshen.<signature> (shen.<signature> News3995) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (shen.=hd? Parseshen.<signature> }) (let News3996 (shen.tls Parseshen.<signature>) (let Parseshen.<rules*> (shen.<rules*> News3996) (if (shen.parse-failure? Parseshen.<rules*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules*>) (let Rectified (shen.rectify-type (shen.<-out Parseshen.<signature>)) (@p Rectified (shen.<-out Parseshen.<rules*>))))))) (shen.parse-failure))))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.freshen-sig (V4392) (let Vs (shen.extract-vars V4392) (let Assoc (map (lambda V (cons V (shen.freshterm (concat & V)))) Vs) (shen.freshen-type Assoc V4392))))

(defun shen.freshen-type (V4393 V4394) (cond ((= () V4393) V4394) ((and (cons? V4393) (cons? (hd V4393))) (shen.freshen-type (tl V4393) (subst (tl (hd V4393)) (hd (hd V4393)) V4394))) (true (shen.f-error shen.freshen-type))))

(defun shen.<rules*> (V4395) (let Result (let Parseshen.<rule*> (shen.<rule*> V4395) (if (shen.parse-failure? Parseshen.<rule*>) (shen.parse-failure) (let Parseshen.<rules*> (shen.<rules*> Parseshen.<rule*>) (if (shen.parse-failure? Parseshen.<rules*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules*>) (cons (shen.linearise (shen.<-out Parseshen.<rule*>)) (shen.<-out Parseshen.<rules*>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<rule*> (shen.<rule*> V4395) (if (shen.parse-failure? Parseshen.<rule*>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rule*>) (cons (shen.linearise (shen.<-out Parseshen.<rule*>)) ())))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<rule*> (V4396) (let Result (let Parseshen.<patterns> (shen.<patterns> V4396) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News3999 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News3999) (let Action (shen.hds News3999) (let News4000 (shen.tls News3999) (if (shen.=hd? News4000 where) (let News4001 (shen.tls News4000) (if (shen.non-empty-stream? News4001) (let Guard (shen.hds News4001) (let News4002 (shen.tls News4001) (shen.comb (shen.in-> News4002) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons Action ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V4396) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News4003 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News4003) (let Action (shen.hds News4003) (let News4004 (shen.tls News4003) (if (shen.=hd? News4004 where) (let News4005 (shen.tls News4004) (if (shen.non-empty-stream? News4005) (let Guard (shen.hds News4005) (let News4006 (shen.tls News4005) (shen.comb (shen.in-> News4006) (@p (shen.<-out Parseshen.<patterns>) (shen.correct (cons where (cons Guard (cons Action ())))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V4396) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News4007 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News4007) (let Action (shen.hds News4007) (let News4008 (shen.tls News4007) (shen.comb (shen.in-> News4008) (@p (shen.<-out Parseshen.<patterns>) (shen.correct Action))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V4396) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News4009 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News4009) (let Action (shen.hds News4009) (let News4010 (shen.tls News4009) (shen.comb (shen.in-> News4010) (@p (shen.<-out Parseshen.<patterns>) Action)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.correct (V4397) (cond ((and (cons? V4397) (and (= where (hd V4397)) (and (cons? (tl V4397)) (and (cons? (tl (tl V4397))) (and (cons? (hd (tl (tl V4397)))) (and (= fail-if (hd (hd (tl (tl V4397))))) (and (cons? (tl (hd (tl (tl V4397))))) (and (cons? (tl (tl (hd (tl (tl V4397)))))) (and (= () (tl (tl (tl (hd (tl (tl V4397))))))) (= () (tl (tl (tl V4397))))))))))))) (cons where (cons (cons and (cons (hd (tl V4397)) (cons (cons not (cons (tl (hd (tl (tl V4397)))) ())) ()))) (tl (tl (hd (tl (tl V4397)))))))) ((and (cons? V4397) (and (= where (hd V4397)) (and (cons? (tl V4397)) (and (cons? (tl (tl V4397))) (= () (tl (tl (tl V4397)))))))) (cons where (cons (cons and (cons (hd (tl V4397)) (cons (cons not (cons (cons = (cons (hd (tl (tl V4397))) (cons (cons fail ()) ()))) ())) ()))) (tl (tl V4397))))) ((and (cons? V4397) (and (= fail-if (hd V4397)) (and (cons? (tl V4397)) (and (cons? (tl (tl V4397))) (= () (tl (tl (tl V4397)))))))) (cons where (cons (cons not (cons (tl V4397) ())) (tl (tl V4397))))) (true (cons where (cons (cons not (cons (cons = (cons V4397 (cons (cons fail ()) ()))) ())) (cons V4397 ()))))))

(defun shen.t*-rules (V4398 V4399 V4400 V4401 V4402 V4403 V4404 V4405) (let K4013 (+ V4404 1) (let C4019 (if (shen.unlocked? V4403) (let Tm4020 (shen.lazyderef V4399 V4402) (if (= Tm4020 ()) (do (shen.incinfs) (thaw V4405)) false)) false) (if (= C4019 false) (let C4021 (if (shen.unlocked? V4403) (let Tm4022 (shen.lazyderef V4399 V4402) (if (cons? Tm4022) (let Rule (hd Tm4022) (let Rules (tl Tm4022) (let Fresh (shen.newpv V4402) (shen.gc V4402 (do (shen.incinfs) (bind Fresh (shen.freshen-rule (shen.deref Rule V4402)) V4402 V4403 K4013 (freeze (shen.t*-rule V4398 V4401 (fst (shen.lazyderef Fresh V4402)) (snd (shen.lazyderef Fresh V4402)) V4400 V4402 V4403 K4013 (freeze (shen.cut V4402 V4403 K4013 (freeze (shen.t*-rules V4398 Rules V4400 (+ V4401 1) V4402 V4403 K4013 V4405)))))))))))) false)) false) (if (= C4021 false) (shen.unlock V4403 K4013) C4021)) C4019))))

(defun shen.freshen-rule (V4406) (cond ((tuple? V4406) (let Vs (shen.extract-vars (fst V4406)) (let Assoc (map (lambda V (cons V (shen.freshterm V))) Vs) (@p (shen.freshen Assoc (fst V4406)) (shen.freshen Assoc (snd V4406)))))) (true (shen.f-error shen.freshen-rule))))

(defun shen.freshen (V4407 V4408) (cond ((= () V4407) V4408) ((and (cons? V4407) (cons? (hd V4407))) (shen.freshen (tl V4407) (shen.beta (hd (hd V4407)) (tl (hd V4407)) V4408))) (true (shen.f-error shen.freshen))))

(defun shen.t*-rule (V4409 V4410 V4411 V4412 V4413 V4414 V4415 V4416 V4417) (let C4032 (if (shen.unlocked? V4415) (do (shen.incinfs) (shen.t*-rule-h V4411 V4412 V4413 V4414 V4415 V4416 V4417)) false) (if (= C4032 false) (if (shen.unlocked? V4415) (let Err (shen.newpv V4414) (shen.gc V4414 (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app V4410 (cn " of " (shen.app V4409 "
" shen.a)) shen.a))) V4414 V4415 V4416 V4417)))) false) C4032)))

(defun shen.t*-rule-h (V4418 V4419 V4420 V4421 V4422 V4423 V4424) (let K4035 (+ V4423 1) (let C4040 (if (shen.unlocked? V4422) (let Tm4041 (shen.lazyderef V4418 V4421) (if (= Tm4041 ()) (let Tm4042 (shen.lazyderef V4420 V4421) (if (cons? Tm4042) (let Tm4043 (shen.lazyderef (hd Tm4042) V4421) (if (= Tm4043 -->) (let Tm4044 (shen.lazyderef (tl Tm4042) V4421) (if (cons? Tm4044) (let A (hd Tm4044) (let Tm4045 (shen.lazyderef (tl Tm4044) V4421) (if (= Tm4045 ()) (do (shen.incinfs) (shen.cut V4421 V4422 K4035 (freeze (shen.t*-correct V4419 A () V4421 V4422 K4035 V4424)))) false))) false)) false)) false)) false)) false) (if (= C4040 false) (let C4046 (if (shen.unlocked? V4422) (let B (shen.newpv V4421) (shen.gc V4421 (let Hyps (shen.newpv V4421) (shen.gc V4421 (do (shen.incinfs) (shen.t*-integrity V4418 V4420 Hyps B V4421 V4422 K4035 (freeze (shen.cut V4421 V4422 K4035 (freeze (shen.t*-correct V4419 B Hyps V4421 V4422 K4035 V4424)))))))))) false) (if (= C4046 false) (shen.unlock V4422 K4035) C4046)) C4040))))

(defun shen.t*-correct (V4425 V4426 V4427 V4428 V4429 V4430 V4431) (let K4049 (+ V4430 1) (let C4054 (if (shen.unlocked? V4429) (let Tm4055 (shen.lazyderef V4425 V4428) (if (cons? Tm4055) (let Tm4056 (shen.lazyderef (hd Tm4055) V4428) (if (= Tm4056 where) (let Tm4057 (shen.lazyderef (tl Tm4055) V4428) (if (cons? Tm4057) (let G (hd Tm4057) (let Tm4058 (shen.lazyderef (tl Tm4057) V4428) (if (cons? Tm4058) (let R (hd Tm4058) (let Tm4059 (shen.lazyderef (tl Tm4058) V4428) (if (= Tm4059 ()) (let CurryG (shen.newpv V4428) (shen.gc V4428 (do (shen.incinfs) (shen.cut V4428 V4429 K4049 (freeze (bind CurryG (shen.curry G) V4428 V4429 K4049 (freeze (shen.system-S-h CurryG boolean V4427 V4428 V4429 K4049 (freeze (shen.cut V4428 V4429 K4049 (freeze (shen.t*-correct R V4426 (cons (cons CurryG (cons (intern ":") (cons verified ()))) V4427) V4428 V4429 K4049 V4431)))))))))))) false))) false))) false)) false)) false)) false) (if (= C4054 false) (let C4060 (if (shen.unlocked? V4429) (do (shen.incinfs) (shen.system-S-h (shen.curry V4425) V4426 V4427 V4428 V4429 K4049 V4431)) false) (if (= C4060 false) (shen.unlock V4429 K4049) C4060)) C4054))))

(defun shen.t*-integrity (V4432 V4433 V4434 V4435 V4436 V4437 V4438 V4439) (let K4064 (+ V4438 1) (let C4070 (if (shen.unlocked? V4437) (let Tm4071 (shen.lazyderef V4432 V4436) (if (= Tm4071 ()) (let Tm4072 (shen.lazyderef V4434 V4436) (let GoTo4073 (freeze (do (shen.incinfs) (is! V4433 V4435 V4436 V4437 K4064 V4439))) (if (= Tm4072 ()) (thaw GoTo4073) (if (shen.pvar? Tm4072) (shen.bind! Tm4072 () V4436 GoTo4073) false)))) false)) false) (if (= C4070 false) (let C4074 (if (shen.unlocked? V4437) (let Tm4075 (shen.lazyderef V4432 V4436) (if (cons? Tm4075) (let P (hd Tm4075) (let Ps (tl Tm4075) (let Tm4076 (shen.lazyderef V4433 V4436) (if (cons? Tm4076) (let A (hd Tm4076) (let Tm4077 (shen.lazyderef (tl Tm4076) V4436) (if (cons? Tm4077) (let Tm4078 (shen.lazyderef (hd Tm4077) V4436) (if (= Tm4078 -->) (let Tm4079 (shen.lazyderef (tl Tm4077) V4436) (if (cons? Tm4079) (let B (hd Tm4079) (let Tm4080 (shen.lazyderef (tl Tm4079) V4436) (if (= Tm4080 ()) (let Tm4081 (shen.lazyderef V4434 V4436) (let GoTo4082 (lambda Hyp (lambda Hyps (let PHyps (shen.newpv V4436) (shen.gc V4436 (do (shen.incinfs) (bind Hyp (cons P (cons (intern ":") (cons A ()))) V4436 V4437 K4064 (freeze (shen.p-hyps P PHyps V4436 V4437 K4064 (freeze (shen.cut V4436 V4437 K4064 (freeze (shen.system-S-h P A PHyps V4436 V4437 K4064 (freeze (shen.cut V4436 V4437 K4064 (freeze (shen.t*-integrity Ps B Hyps V4435 V4436 V4437 K4064 V4439)))))))))))))))) (if (cons? Tm4081) (let Hyp (hd Tm4081) (let Hyps (tl Tm4081) ((GoTo4082 Hyp) Hyps))) (if (shen.pvar? Tm4081) (let Hyp (shen.newpv V4436) (shen.gc V4436 (let Hyps (shen.newpv V4436) (shen.gc V4436 (shen.bind! Tm4081 (cons Hyp Hyps) V4436 (freeze ((GoTo4082 Hyp) Hyps))))))) false)))) false))) false)) false)) false))) false)))) false)) false) (if (= C4074 false) (shen.unlock V4437 K4064) C4074)) C4070))))

(defun shen.p-hyps (V4440 V4441 V4442 V4443 V4444 V4445) (let K4085 (+ V4444 1) (let C4089 (if (shen.unlocked? V4443) (let A (shen.newpv V4442) (shen.gc V4442 (do (shen.incinfs) (when (shen.freshterm? (shen.deref V4440 V4442)) V4442 V4443 K4085 (freeze (shen.cut V4442 V4443 K4085 (freeze (bind V4441 (cons (cons V4440 (cons (intern ":") (cons A ()))) ()) V4442 V4443 K4085 V4445)))))))) false) (if (= C4089 false) (let C4090 (if (shen.unlocked? V4443) (let Tm4091 (shen.lazyderef V4440 V4442) (if (cons? Tm4091) (let X (hd Tm4091) (let Y (tl Tm4091) (let XHyps (shen.newpv V4442) (shen.gc V4442 (let YHyps (shen.newpv V4442) (shen.gc V4442 (do (shen.incinfs) (shen.cut V4442 V4443 K4085 (freeze (shen.p-hyps X XHyps V4442 V4443 K4085 (freeze (shen.p-hyps Y YHyps V4442 V4443 K4085 (freeze (shen.join XHyps YHyps V4441 V4442 V4443 K4085 V4445)))))))))))))) false)) false) (if (= C4090 false) (let C4092 (if (shen.unlocked? V4443) (do (shen.incinfs) (bind V4441 () V4442 V4443 K4085 V4445)) false) (if (= C4092 false) (shen.unlock V4443 K4085) C4092)) C4090)) C4089))))

(defun shen.freshterm? (V4446) (and (absvector? V4446) (and (not (string? V4446)) (= (<-address V4446 0) shen.print-freshterm))))

(defun shen.join (V4447 V4448 V4449 V4450 V4451 V4452 V4453) (let C4100 (if (shen.unlocked? V4451) (let Tm4101 (shen.lazyderef V4447 V4450) (if (= Tm4101 ()) (do (shen.incinfs) (bind V4449 V4448 V4450 V4451 V4452 V4453)) false)) false) (if (= C4100 false) (if (shen.unlocked? V4451) (let Tm4102 (shen.lazyderef V4447 V4450) (if (cons? Tm4102) (let X (hd Tm4102) (let Y (tl Tm4102) (let Tm4103 (shen.lazyderef V4449 V4450) (let GoTo4104 (lambda X* (lambda Z (do (shen.incinfs) (bind X* X V4450 V4451 V4452 (freeze (shen.join Y V4448 Z V4450 V4451 V4452 V4453)))))) (if (cons? Tm4103) (let X* (hd Tm4103) (let Z (tl Tm4103) ((GoTo4104 X*) Z))) (if (shen.pvar? Tm4103) (let X* (shen.newpv V4450) (shen.gc V4450 (let Z (shen.newpv V4450) (shen.gc V4450 (shen.bind! Tm4103 (cons X* Z) V4450 (freeze ((GoTo4104 X*) Z))))))) false)))))) false)) false) C4100)))

