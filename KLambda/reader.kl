(defun read-file (V7831) (let Bytelist (read-file-as-bytelist V7831) (let S-exprs (trap-error (compile (lambda X (shen.<s-exprs> X)) Bytelist) (lambda E (shen.print-residue (value shen.*residue*)))) (let Process (shen.process-sexprs S-exprs) Process))))

(defun shen.print-residue (V7832) (let Err (pr "syntax error here:
" (stoutput)) (shen.nchars 50 V7832)))

(defun shen.nchars (V7837 V7838) (cond ((= 0 V7837) (do (pr " ..." (stoutput)) (abort))) ((= () V7838) (do (pr " ..." (stoutput)) (abort))) ((cons? V7838) (do (pr (n->string (hd V7838)) (stoutput)) (shen.nchars (- V7837 1) (tl V7838)))) (true (shen.f-error shen.nchars))))

(defun it () (value shen.*it*))

(defun read-file-as-bytelist (V7839) (let Stream (open V7839 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V7840 V7841 V7842) (cond ((= -1 V7841) V7842) (true (shen.read-file-as-bytelist-help V7840 (read-byte V7840) (cons V7841 V7842)))))

(defun read-file-as-string (V7843) (let Stream (open V7843 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V7844 V7845 V7846) (cond ((= -1 V7845) (do (close V7844) V7846)) (true (shen.rfas-h V7844 (read-byte V7844) (cn V7846 (n->string V7845))))))

(defun input (V7847) (eval-kl (read V7847)))

(defun input+ (V7848 V7849) (let Mono? (shen.monotype V7848) (let Input (read V7849) (if (= false (shen.typecheck Input (shen.rectify-type V7848))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V7848 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V7850) (cond ((cons? V7850) (map (lambda Z (shen.monotype Z)) V7850)) (true (if (variable? V7850) (simple-error (cn "input+ expects a monotype: not " (shen.app V7850 "
" shen.a))) V7850))))

(defun lineread (V7851) (shen.read-loop V7851 (shen.my-read-byte V7851) () (lambda X (shen.return? X))))

(defun read-from-string (V7852) (let Bytelist (shen.str->bytes V7852) (let S-exprs (compile (lambda X (shen.<s-exprs> X)) Bytelist) (let Process (shen.process-sexprs S-exprs) Process))))

(defun read-from-string-unprocessed (V7853) (let Bytelist (shen.str->bytes V7853) (let S-exprs (compile (lambda X (shen.<s-exprs> X)) Bytelist) S-exprs)))

(defun shen.str->bytes (V7854) (cond ((= "" V7854) ()) ((shen.+string? V7854) (cons (string->n (hdstr V7854)) (shen.str->bytes (tlstr V7854)))) (true (shen.f-error shen.str->bytes))))

(defun read (V7855) (hd (shen.read-loop V7855 (shen.my-read-byte V7855) () (lambda X (shen.whitespace? X)))))

(defun shen.my-read-byte (V7856) (if (shen.char-stinput? V7856) (string->n (shen.read-unit-string V7856)) (read-byte V7856)))

(defun shen.read-loop (V7861 V7862 V7863 V7864) (cond ((= 94 V7862) (simple-error "read aborted")) ((= -1 V7862) (if (empty? V7863) (simple-error "error: empty stream") (compile (lambda X (shen.<s-exprs> X)) V7863))) ((= 0 V7862) (shen.read-loop V7861 (shen.my-read-byte V7861) V7863 V7864)) (true (if (V7864 V7862) (let Parse (shen.try-parse V7863) (if (shen.nothing-doing? Parse) (shen.read-loop V7861 (shen.my-read-byte V7861) (append V7863 (cons V7862 ())) V7864) (do (shen.record-it V7863) Parse))) (shen.read-loop V7861 (shen.my-read-byte V7861) (append V7863 (cons V7862 ())) V7864)))))

(defun shen.try-parse (V7865) (let S-exprs (trap-error (compile (lambda X (shen.<s-exprs> X)) V7865) (lambda E shen.i-failed!)) (if (shen.nothing-doing? S-exprs) shen.i-failed! (shen.process-sexprs S-exprs))))

(defun shen.nothing-doing? (V7868) (cond ((= shen.i-failed! V7868) true) ((= () V7868) true) (true false)))

(defun shen.record-it (V7869) (set shen.*it* (shen.bytes->string V7869)))

(defun shen.bytes->string (V7870) (cond ((= () V7870) "") ((cons? V7870) (cn (n->string (hd V7870)) (shen.bytes->string (tl V7870)))) (true (shen.f-error shen.bytes->string))))

(defun shen.process-sexprs (V7871) (let Unpack&Expand (shen.unpackage&macroexpand V7871) (let FindArities (shen.find-arities Unpack&Expand) (let Types (shen.find-types Unpack&Expand) (map (lambda X (shen.process-applications X Types)) Unpack&Expand)))))

(defun shen.find-types (V7872) (cond ((and (cons? V7872) (and (cons? (tl V7872)) (= (hd V7872) (intern ":")))) (cons (hd (tl V7872)) (shen.find-types (tl (tl V7872))))) ((cons? V7872) (append (shen.find-types (hd V7872)) (shen.find-types (tl V7872)))) (true ())))

(defun shen.find-arities (V7875) (cond ((and (cons? V7875) (and (= define (hd V7875)) (and (cons? (tl V7875)) (and (cons? (tl (tl V7875))) (= { (hd (tl (tl V7875)))))))) (shen.store-arity (hd (tl V7875)) (shen.find-arity (hd (tl V7875)) 1 (tl (tl (tl V7875)))))) ((and (cons? V7875) (and (= define (hd V7875)) (cons? (tl V7875)))) (shen.store-arity (hd (tl V7875)) (shen.find-arity (hd (tl V7875)) 0 (tl (tl V7875))))) ((cons? V7875) (map (lambda Z (shen.find-arities Z)) V7875)) (true shen.skip)))

(defun shen.store-arity (V7876 V7877) (let ArityF (arity V7876) (if (= ArityF -1) (shen.execute-store-arity V7876 V7877) (if (= ArityF V7877) shen.skip (if (shen.sysfunc? V7876) (simple-error (shen.app V7876 " is a system function
" shen.a)) (do (pr (cn "changing the arity of " (shen.app V7876 " may cause errors
" shen.a)) (stoutput)) (shen.execute-store-arity V7876 V7877)))))))

(defun shen.execute-store-arity (V7878 V7879) (cond ((= 0 V7879) (put V7878 arity 0 (value *property-vector*))) (true (do (put V7878 arity V7879 (value *property-vector*)) (shen.update-lambdatable V7878 V7879)))))

(defun shen.update-lambdatable (V7880 V7881) (let LambdaTable (value shen.*lambdatable*) (let Lambda (eval-kl (shen.lambda-function (cons V7880 ()) V7881)) (let Insert (shen.assoc-> V7880 Lambda LambdaTable) (let Reset (set shen.*lambdatable* Insert) Reset)))))

(defun shen.lambda-function (V7884 V7885) (cond ((= 0 V7885) shen.skip) ((= 1 V7885) (let X (gensym Y) (cons lambda (cons X (cons (append V7884 (cons X ())) ()))))) (true (let X (gensym Y) (cons lambda (cons X (cons (shen.lambda-function (append V7884 (cons X ())) (- V7885 1)) ())))))))

(defun shen.assoc-> (V7895 V7896 V7897) (cond ((= () V7897) (cons (cons V7895 V7896) ())) ((and (cons? V7897) (and (cons? (hd V7897)) (= V7895 (hd (hd V7897))))) (cons (cons (hd (hd V7897)) V7896) (tl V7897))) ((cons? V7897) (cons (hd V7897) (shen.assoc-> V7895 V7896 (tl V7897)))) (true (simple-error "implementation error in shen.assoc->"))))

(defun shen.find-arity (V7912 V7913 V7914) (cond ((and (= 0 V7913) (and (cons? V7914) (= (hd V7914) ->))) 0) ((and (= 0 V7913) (and (cons? V7914) (= (hd V7914) <-))) 0) ((and (= 0 V7913) (cons? V7914)) (+ 1 (shen.find-arity V7912 0 (tl V7914)))) ((and (= 1 V7913) (and (cons? V7914) (= } (hd V7914)))) (shen.find-arity V7912 0 (tl V7914))) ((and (= 1 V7913) (cons? V7914)) (shen.find-arity V7912 1 (tl V7914))) ((= 1 V7913) (simple-error (cn "syntax error in " (shen.app V7912 " definition: missing }
" shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V7912 " definition: missing -> or <-
" shen.a))))))

(defun shen.<s-exprs> (V7915) (let Result (let Parseshen.<lsb> (shen.<lsb> V7915) (if (shen.parse-failure? Parseshen.<lsb>) (shen.parse-failure) (let Parseshen.<s-exprs1> (shen.<s-exprs1> Parseshen.<lsb>) (if (shen.parse-failure? Parseshen.<s-exprs1>) (shen.parse-failure) (let Parseshen.<rsb> (shen.<rsb> Parseshen.<s-exprs1>) (if (shen.parse-failure? Parseshen.<rsb>) (shen.parse-failure) (let Parseshen.<s-exprs2> (shen.<s-exprs2> Parseshen.<rsb>) (if (shen.parse-failure? Parseshen.<s-exprs2>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs2>) (cons (shen.cons-form (shen.<-out Parseshen.<s-exprs1>)) (shen.<-out Parseshen.<s-exprs2>))))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<lrb> (shen.<lrb> V7915) (if (shen.parse-failure? Parseshen.<lrb>) (shen.parse-failure) (let Parseshen.<s-exprs1> (shen.<s-exprs1> Parseshen.<lrb>) (if (shen.parse-failure? Parseshen.<s-exprs1>) (shen.parse-failure) (let Parseshen.<rrb> (shen.<rrb> Parseshen.<s-exprs1>) (if (shen.parse-failure? Parseshen.<rrb>) (shen.parse-failure) (let Parseshen.<s-exprs2> (shen.<s-exprs2> Parseshen.<rrb>) (if (shen.parse-failure? Parseshen.<s-exprs2>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs2>) (shen.add-sexpr (shen.<-out Parseshen.<s-exprs1>) (shen.<-out Parseshen.<s-exprs2>))))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<lcurly> (shen.<lcurly> V7915) (if (shen.parse-failure? Parseshen.<lcurly>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<lcurly>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons { (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<rcurly> (shen.<rcurly> V7915) (if (shen.parse-failure? Parseshen.<rcurly>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<rcurly>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons } (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<bar> (shen.<bar> V7915) (if (shen.parse-failure? Parseshen.<bar>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<bar>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons bar! (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<semicolon> (shen.<semicolon> V7915) (if (shen.parse-failure? Parseshen.<semicolon>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<semicolon>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ";") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon> (shen.<colon> V7915) (if (shen.parse-failure? Parseshen.<colon>) (shen.parse-failure) (let Parseshen.<equal> (shen.<equal> Parseshen.<colon>) (if (shen.parse-failure? Parseshen.<equal>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<equal>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ":=") (shen.<-out Parseshen.<s-exprs>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<colon> (shen.<colon> V7915) (if (shen.parse-failure? Parseshen.<colon>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<colon>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ":") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<comma> (shen.<comma> V7915) (if (shen.parse-failure? Parseshen.<comma>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<comma>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (intern ",") (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<comment> (shen.<comment> V7915) (if (shen.parse-failure? Parseshen.<comment>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<comment>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<atom> (shen.<atom> V7915) (if (shen.parse-failure? Parseshen.<atom>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<atom>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (cons (shen.<-out Parseshen.<atom>) (shen.<-out Parseshen.<s-exprs>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<whitespaces> (shen.<whitespaces> V7915) (if (shen.parse-failure? Parseshen.<whitespaces>) (shen.parse-failure) (let Parseshen.<s-exprs> (shen.<s-exprs> Parseshen.<whitespaces>) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7915) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.add-sexpr (V7916 V7917) (cond ((and (cons? V7916) (and (= $ (hd V7916)) (and (cons? (tl V7916)) (= () (tl (tl V7916)))))) (append (explode (hd (tl V7916))) V7917)) (true (cons V7916 V7917))))

(defun shen.<lsb> (V7918) (let Result (if (shen.=hd? V7918 91) (let News7600 (shen.tls V7918) (shen.comb (shen.in-> News7600) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rsb> (V7919) (let Result (if (shen.=hd? V7919 93) (let News7602 (shen.tls V7919) (shen.comb (shen.in-> News7602) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<s-exprs1> (V7920) (let Result (let Parseshen.<s-exprs> (shen.<s-exprs> V7920) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<s-exprs2> (V7921) (let Result (let Parseshen.<s-exprs> (shen.<s-exprs> V7921) (if (shen.parse-failure? Parseshen.<s-exprs>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<s-exprs>) (shen.<-out Parseshen.<s-exprs>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.cons-form (V7923) (cond ((= () V7923) ()) ((and (cons? V7923) (and (cons? (tl V7923)) (and (cons? (tl (tl V7923))) (and (= () (tl (tl (tl V7923)))) (= (hd (tl V7923)) bar!))))) (cons cons (cons (hd V7923) (tl (tl V7923))))) ((and (cons? V7923) (and (cons? (tl V7923)) (and (cons? (tl (tl V7923))) (and (cons? (tl (tl (tl V7923)))) (= (hd (tl V7923)) bar!))))) (simple-error "misapplication of |
")) ((cons? V7923) (cons cons (cons (hd V7923) (cons (shen.cons-form (tl V7923)) ())))) (true (shen.f-error shen.cons-form))))

(defun shen.<lrb> (V7924) (let Result (if (shen.=hd? V7924 40) (let News7606 (shen.tls V7924) (shen.comb (shen.in-> News7606) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rrb> (V7925) (let Result (if (shen.=hd? V7925 41) (let News7608 (shen.tls V7925) (shen.comb (shen.in-> News7608) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<lcurly> (V7926) (let Result (if (shen.=hd? V7926 123) (let News7610 (shen.tls V7926) (shen.comb (shen.in-> News7610) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<rcurly> (V7927) (let Result (if (shen.=hd? V7927 125) (let News7612 (shen.tls V7927) (shen.comb (shen.in-> News7612) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<bar> (V7928) (let Result (if (shen.=hd? V7928 124) (let News7614 (shen.tls V7928) (shen.comb (shen.in-> News7614) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<semicolon> (V7929) (let Result (if (shen.=hd? V7929 59) (let News7616 (shen.tls V7929) (shen.comb (shen.in-> News7616) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<colon> (V7930) (let Result (if (shen.=hd? V7930 58) (let News7618 (shen.tls V7930) (shen.comb (shen.in-> News7618) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<comma> (V7931) (let Result (if (shen.=hd? V7931 44) (let News7620 (shen.tls V7931) (shen.comb (shen.in-> News7620) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<equal> (V7932) (let Result (if (shen.=hd? V7932 61) (let News7622 (shen.tls V7932) (shen.comb (shen.in-> News7622) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<comment> (V7933) (let Result (let Parseshen.<singleline> (shen.<singleline> V7933) (if (shen.parse-failure? Parseshen.<singleline>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<singleline>) shen.skip))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<multiline> (shen.<multiline> V7933) (if (shen.parse-failure? Parseshen.<multiline>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<multiline>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<singleline> (V7934) (let Result (let Parseshen.<backslash> (shen.<backslash> V7934) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<backslash> (shen.<backslash> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<shortnatters> (shen.<shortnatters> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<shortnatters>) (shen.parse-failure) (let Parseshen.<returns> (shen.<returns> Parseshen.<shortnatters>) (if (shen.parse-failure? Parseshen.<returns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<returns>) shen.skip))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<backslash> (V7935) (let Result (if (shen.=hd? V7935 92) (let News7626 (shen.tls V7935) (shen.comb (shen.in-> News7626) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<shortnatters> (V7936) (let Result (let Parseshen.<shortnatter> (shen.<shortnatter> V7936) (if (shen.parse-failure? Parseshen.<shortnatter>) (shen.parse-failure) (let Parseshen.<shortnatters> (shen.<shortnatters> Parseshen.<shortnatter>) (if (shen.parse-failure? Parseshen.<shortnatters>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<shortnatters>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7936) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<shortnatter> (V7937) (let Result (if (shen.non-empty-stream? V7937) (let Byte (shen.hds V7937) (let News7629 (shen.tls V7937) (if (not (shen.return? Byte)) (shen.comb (shen.in-> News7629) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<returns> (V7938) (let Result (let Parseshen.<return> (shen.<return> V7938) (if (shen.parse-failure? Parseshen.<return>) (shen.parse-failure) (let Parseshen.<returns> (shen.<returns> Parseshen.<return>) (if (shen.parse-failure? Parseshen.<returns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<returns>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<return> (shen.<return> V7938) (if (shen.parse-failure? Parseshen.<return>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<return>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<return> (V7939) (let Result (if (shen.non-empty-stream? V7939) (let Byte (shen.hds V7939) (let News7632 (shen.tls V7939) (if (shen.return? Byte) (shen.comb (shen.in-> News7632) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.return? (V7940) (element? V7940 (cons 9 (cons 10 (cons 13 ())))))

(defun shen.<multiline> (V7941) (let Result (let Parseshen.<backslash> (shen.<backslash> V7941) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (let Parseshen.<times> (shen.<times> Parseshen.<backslash>) (if (shen.parse-failure? Parseshen.<times>) (shen.parse-failure) (let Parseshen.<longnatter> (shen.<longnatter> Parseshen.<times>) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<times> (V7942) (let Result (if (shen.=hd? V7942 42) (let News7635 (shen.tls V7942) (shen.comb (shen.in-> News7635) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<longnatter> (V7943) (let Result (let Parseshen.<comment> (shen.<comment> V7943) (if (shen.parse-failure? Parseshen.<comment>) (shen.parse-failure) (let Parseshen.<longnatter> (shen.<longnatter> Parseshen.<comment>) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<times> (shen.<times> V7943) (if (shen.parse-failure? Parseshen.<times>) (shen.parse-failure) (let Parseshen.<backslash> (shen.<backslash> Parseshen.<times>) (if (shen.parse-failure? Parseshen.<backslash>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<backslash>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V7943) (let News7637 (shen.tls V7943) (let Parseshen.<longnatter> (shen.<longnatter> News7637) (if (shen.parse-failure? Parseshen.<longnatter>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<longnatter>) shen.skip)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<atom> (V7944) (let Result (let Parseshen.<str> (shen.<str> V7944) (if (shen.parse-failure? Parseshen.<str>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<str>) (shen.<-out Parseshen.<str>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<number> (shen.<number> V7944) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (shen.<-out Parseshen.<number>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<sym> (shen.<sym> V7944) (if (shen.parse-failure? Parseshen.<sym>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sym>) (if (= (shen.<-out Parseshen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.<-out Parseshen.<sym>)))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<sym> (V7945) (let Result (let Parseshen.<alpha> (shen.<alpha> V7945) (if (shen.parse-failure? Parseshen.<alpha>) (shen.parse-failure) (let Parseshen.<alphanums> (shen.<alphanums> Parseshen.<alpha>) (if (shen.parse-failure? Parseshen.<alphanums>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alphanums>) (cn (shen.<-out Parseshen.<alpha>) (shen.<-out Parseshen.<alphanums>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<alpha> (V7946) (let Result (if (shen.non-empty-stream? V7946) (let Byte (shen.hds V7946) (let News7641 (shen.tls V7946) (if (shen.alpha? Byte) (shen.comb (shen.in-> News7641) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.alpha? (V7947) (or (shen.lowercase? V7947) (or (shen.uppercase? V7947) (shen.misc? V7947))))

(defun shen.lowercase? (V7948) (and (>= V7948 97) (<= V7948 122)))

(defun shen.uppercase? (V7949) (and (>= V7949 65) (<= V7949 90)))

(defun shen.misc? (V7950) (element? V7950 (cons 61 (cons 45 (cons 42 (cons 47 (cons 43 (cons 95 (cons 63 (cons 36 (cons 33 (cons 64 (cons 126 (cons 46 (cons 62 (cons 60 (cons 38 (cons 37 (cons 39 (cons 35 (cons 96 ())))))))))))))))))))))

(defun shen.<alphanums> (V7951) (let Result (let Parseshen.<alphanum> (shen.<alphanum> V7951) (if (shen.parse-failure? Parseshen.<alphanum>) (shen.parse-failure) (let Parseshen.<alphanums> (shen.<alphanums> Parseshen.<alphanum>) (if (shen.parse-failure? Parseshen.<alphanums>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alphanums>) (cn (shen.<-out Parseshen.<alphanum>) (shen.<-out Parseshen.<alphanums>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7951) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ""))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<alphanum> (V7952) (let Result (let Parseshen.<alpha> (shen.<alpha> V7952) (if (shen.parse-failure? Parseshen.<alpha>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<alpha>) (shen.<-out Parseshen.<alpha>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<numeral> (shen.<numeral> V7952) (if (shen.parse-failure? Parseshen.<numeral>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<numeral>) (shen.<-out Parseshen.<numeral>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<numeral> (V7953) (let Result (if (shen.non-empty-stream? V7953) (let Byte (shen.hds V7953) (let News7645 (shen.tls V7953) (if (shen.digit? Byte) (shen.comb (shen.in-> News7645) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.digit? (V7954) (and (>= V7954 48) (<= V7954 57)))

(defun shen.<str> (V7955) (let Result (let Parseshen.<dbq> (shen.<dbq> V7955) (if (shen.parse-failure? Parseshen.<dbq>) (shen.parse-failure) (let Parseshen.<strcontents> (shen.<strcontents> Parseshen.<dbq>) (if (shen.parse-failure? Parseshen.<strcontents>) (shen.parse-failure) (let Parseshen.<dbq> (shen.<dbq> Parseshen.<strcontents>) (if (shen.parse-failure? Parseshen.<dbq>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<dbq>) (shen.<-out Parseshen.<strcontents>)))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<dbq> (V7956) (let Result (if (shen.=hd? V7956 34) (let News7648 (shen.tls V7956) (shen.comb (shen.in-> News7648) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<strcontents> (V7957) (let Result (let Parseshen.<strc> (shen.<strc> V7957) (if (shen.parse-failure? Parseshen.<strc>) (shen.parse-failure) (let Parseshen.<strcontents> (shen.<strcontents> Parseshen.<strc>) (if (shen.parse-failure? Parseshen.<strcontents>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<strcontents>) (cn (shen.<-out Parseshen.<strc>) (shen.<-out Parseshen.<strcontents>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V7957) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ""))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<strc> (V7958) (let Result (let Parseshen.<control> (shen.<control> V7958) (if (shen.parse-failure? Parseshen.<control>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<control>) (shen.<-out Parseshen.<control>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<notdbq> (shen.<notdbq> V7958) (if (shen.parse-failure? Parseshen.<notdbq>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<notdbq>) (shen.<-out Parseshen.<notdbq>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<control> (V7959) (let Result (let Parseshen.<lowC> (shen.<lowC> V7959) (if (shen.parse-failure? Parseshen.<lowC>) (shen.parse-failure) (let Parseshen.<hash> (shen.<hash> Parseshen.<lowC>) (if (shen.parse-failure? Parseshen.<hash>) (shen.parse-failure) (let Parseshen.<integer> (shen.<integer> Parseshen.<hash>) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<semicolon> (shen.<semicolon> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<semicolon>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<semicolon>) (n->string (shen.<-out Parseshen.<integer>))))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<notdbq> (V7960) (let Result (if (shen.non-empty-stream? V7960) (let Byte (shen.hds V7960) (let News7653 (shen.tls V7960) (if (not (= Byte 34)) (shen.comb (shen.in-> News7653) (n->string Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<lowC> (V7961) (let Result (if (shen.=hd? V7961 99) (let News7655 (shen.tls V7961) (shen.comb (shen.in-> News7655) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<hash> (V7962) (let Result (if (shen.=hd? V7962 35) (let News7657 (shen.tls V7962) (shen.comb (shen.in-> News7657) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<number> (V7963) (let Result (let Parseshen.<minus> (shen.<minus> V7963) (if (shen.parse-failure? Parseshen.<minus>) (shen.parse-failure) (let Parseshen.<number> (shen.<number> Parseshen.<minus>) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (- 0 (shen.<-out Parseshen.<number>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<plus> (shen.<plus> V7963) (if (shen.parse-failure? Parseshen.<plus>) (shen.parse-failure) (let Parseshen.<number> (shen.<number> Parseshen.<plus>) (if (shen.parse-failure? Parseshen.<number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<number>) (shen.<-out Parseshen.<number>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<e-number> (shen.<e-number> V7963) (if (shen.parse-failure? Parseshen.<e-number>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<e-number>) (shen.<-out Parseshen.<e-number>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<float> (shen.<float> V7963) (if (shen.parse-failure? Parseshen.<float>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<float>) (shen.<-out Parseshen.<float>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V7963) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<integer>) (shen.<-out Parseshen.<integer>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)) Result)))

(defun shen.<minus> (V7964) (let Result (if (shen.=hd? V7964 45) (let News7660 (shen.tls V7964) (shen.comb (shen.in-> News7660) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<plus> (V7965) (let Result (if (shen.=hd? V7965 43) (let News7662 (shen.tls V7965) (shen.comb (shen.in-> News7662) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<integer> (V7966) (let Result (let Parseshen.<digits> (shen.<digits> V7966) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (shen.compute-integer (shen.<-out Parseshen.<digits>))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<digits> (V7967) (let Result (let Parseshen.<digit> (shen.<digit> V7967) (if (shen.parse-failure? Parseshen.<digit>) (shen.parse-failure) (let Parseshen.<digits> (shen.<digits> Parseshen.<digit>) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (cons (shen.<-out Parseshen.<digit>) (shen.<-out Parseshen.<digits>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<digit> (shen.<digit> V7967) (if (shen.parse-failure? Parseshen.<digit>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digit>) (cons (shen.<-out Parseshen.<digit>) ())))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<digit> (V7968) (let Result (if (shen.non-empty-stream? V7968) (let Byte (shen.hds V7968) (let News7666 (shen.tls V7968) (if (shen.digit? Byte) (shen.comb (shen.in-> News7666) (shen.byte->digit Byte)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.byte->digit (V7969) (- V7969 48))

(defun shen.compute-integer (V7970) (shen.compute-integer-h (reverse V7970) 0))

(defun shen.compute-integer-h (V7973 V7974) (cond ((= () V7973) 0) ((cons? V7973) (+ (* (shen.expt 10 V7974) (hd V7973)) (shen.compute-integer-h (tl V7973) (+ V7974 1)))) (true (shen.f-error shen.compute-integer-h))))

(defun shen.expt (V7977 V7978) (cond ((= 0 V7978) 1) ((> V7978 0) (* V7977 (shen.expt V7977 (- V7978 1)))) (true (/ (shen.expt V7977 (+ V7978 1)) V7977))))

(defun shen.<float> (V7979) (let Result (let Parseshen.<integer> (shen.<integer> V7979) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<stop> (shen.<stop> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<stop>) (shen.parse-failure) (let Parseshen.<fraction> (shen.<fraction> Parseshen.<stop>) (if (shen.parse-failure? Parseshen.<fraction>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<fraction>) (+ (shen.<-out Parseshen.<integer>) (shen.<-out Parseshen.<fraction>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<stop> (shen.<stop> V7979) (if (shen.parse-failure? Parseshen.<stop>) (shen.parse-failure) (let Parseshen.<fraction> (shen.<fraction> Parseshen.<stop>) (if (shen.parse-failure? Parseshen.<fraction>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<fraction>) (shen.<-out Parseshen.<fraction>)))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<stop> (V7980) (let Result (if (shen.=hd? V7980 46) (let News7669 (shen.tls V7980) (shen.comb (shen.in-> News7669) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<fraction> (V7981) (let Result (let Parseshen.<digits> (shen.<digits> V7981) (if (shen.parse-failure? Parseshen.<digits>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<digits>) (shen.compute-fraction (shen.<-out Parseshen.<digits>))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.compute-fraction (V7982) (shen.compute-fraction-h V7982 -1))

(defun shen.compute-fraction-h (V7985 V7986) (cond ((= () V7985) 0) ((cons? V7985) (+ (* (shen.expt 10 V7986) (hd V7985)) (shen.compute-fraction-h (tl V7985) (- V7986 1)))) (true (shen.f-error shen.compute-fraction-h))))

(defun shen.<e-number> (V7987) (let Result (let Parseshen.<float> (shen.<float> V7987) (if (shen.parse-failure? Parseshen.<float>) (shen.parse-failure) (let Parseshen.<lowE> (shen.<lowE> Parseshen.<float>) (if (shen.parse-failure? Parseshen.<lowE>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<lowE>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.compute-E (shen.<-out Parseshen.<float>) (shen.<-out Parseshen.<log10>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V7987) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (let Parseshen.<lowE> (shen.<lowE> Parseshen.<integer>) (if (shen.parse-failure? Parseshen.<lowE>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<lowE>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.compute-E (shen.<-out Parseshen.<integer>) (shen.<-out Parseshen.<log10>))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<log10> (V7988) (let Result (let Parseshen.<plus> (shen.<plus> V7988) (if (shen.parse-failure? Parseshen.<plus>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<plus>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (shen.<-out Parseshen.<log10>)))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<minus> (shen.<minus> V7988) (if (shen.parse-failure? Parseshen.<minus>) (shen.parse-failure) (let Parseshen.<log10> (shen.<log10> Parseshen.<minus>) (if (shen.parse-failure? Parseshen.<log10>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<log10>) (- 0 (shen.<-out Parseshen.<log10>))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<integer> (shen.<integer> V7988) (if (shen.parse-failure? Parseshen.<integer>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<integer>) (shen.<-out Parseshen.<integer>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<lowE> (V7989) (let Result (if (shen.=hd? V7989 101) (let News7674 (shen.tls V7989) (shen.comb (shen.in-> News7674) shen.skip)) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.compute-E (V7990 V7991) (* V7990 (shen.expt 10 V7991)))

(defun shen.<whitespaces> (V7992) (let Result (let Parseshen.<whitespace> (shen.<whitespace> V7992) (if (shen.parse-failure? Parseshen.<whitespace>) (shen.parse-failure) (let Parseshen.<whitespaces> (shen.<whitespaces> Parseshen.<whitespace>) (if (shen.parse-failure? Parseshen.<whitespaces>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<whitespaces>) shen.skip))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<whitespace> (shen.<whitespace> V7992) (if (shen.parse-failure? Parseshen.<whitespace>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<whitespace>) shen.skip))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<whitespace> (V7993) (let Result (if (shen.non-empty-stream? V7993) (let Byte (shen.hds V7993) (let News7677 (shen.tls V7993) (if (shen.whitespace? Byte) (shen.comb (shen.in-> News7677) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.whitespace? (V7996) (cond ((= 32 V7996) true) ((= 13 V7996) true) ((= 10 V7996) true) ((= 9 V7996) true) (true false)))

(defun shen.unpackage&macroexpand (V7997) (cond ((= () V7997) ()) ((and (cons? V7997) (shen.packaged? (hd V7997))) (shen.unpackage&macroexpand (append (shen.unpackage (hd V7997)) (tl V7997)))) ((cons? V7997) (let M (macroexpand (hd V7997)) (if (shen.packaged? M) (shen.unpackage&macroexpand (cons M (tl V7997))) (cons M (shen.unpackage&macroexpand (tl V7997)))))) (true (shen.f-error shen.unpackage&macroexpand))))

(defun shen.packaged? (V8000) (cond ((and (cons? V8000) (and (= package (hd V8000)) (and (cons? (tl V8000)) (cons? (tl (tl V8000)))))) true) (true false)))

(defun shen.unpackage (V8003) (cond ((and (cons? V8003) (and (= package (hd V8003)) (and (cons? (tl V8003)) (and (= null (hd (tl V8003))) (cons? (tl (tl V8003))))))) (tl (tl (tl V8003)))) ((and (cons? V8003) (and (= package (hd V8003)) (and (cons? (tl V8003)) (cons? (tl (tl V8003)))))) (let External! (eval (hd (tl (tl V8003)))) (let Package (shen.package-symbols (str (hd (tl V8003))) External! (tl (tl (tl V8003)))) (let RecordExternal (shen.record-external (hd (tl V8003)) External!) Package)))) (true (shen.f-error shen.unpackage))))

(defun shen.record-external (V8004 V8005) (let External (trap-error (get V8004 shen.external-symbols (value *property-vector*)) (lambda E ())) (put V8004 shen.external-symbols (union V8005 External) (value *property-vector*))))

(defun shen.package-symbols (V8010 V8011 V8012) (cond ((cons? V8012) (map (lambda X (shen.package-symbols V8010 V8011 X)) V8012)) ((shen.internal? V8012 V8010 V8011) (shen.intern-in-package V8010 V8012)) (true V8012)))

(defun shen.intern-in-package (V8013 V8014) (intern (@s V8013 (@s "." (str V8014)))))

(defun shen.internal? (V8015 V8016 V8017) (and (not (element? V8015 V8017)) (and (not (shen.sng? V8015)) (and (not (shen.dbl? V8015)) (and (symbol? V8015) (and (not (shen.sysfunc? V8015)) (and (not (variable? V8015)) (and (not (shen.internal-to-shen? (str V8015))) (not (shen.internal-to-P? V8016 (str V8015)))))))))))

(defun shen.internal-to-shen? (V8022) (cond ((and (shen.+string? V8022) (and (= "s" (hdstr V8022)) (and (shen.+string? (tlstr V8022)) (and (= "h" (hdstr (tlstr V8022))) (and (shen.+string? (tlstr (tlstr V8022))) (and (= "e" (hdstr (tlstr (tlstr V8022)))) (and (shen.+string? (tlstr (tlstr (tlstr V8022)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V8022))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V8022))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V8022))))))))))))))) true) (true false)))

(defun shen.sysfunc? (V8023) (element? V8023 (get shen shen.external-symbols (value *property-vector*))))

(defun shen.internal-to-P? (V8031 V8032) (cond ((and (= "" V8031) (and (shen.+string? V8032) (= "." (hdstr V8032)))) true) ((and (shen.+string? V8031) (and (shen.+string? V8032) (= (hdstr V8031) (hdstr V8032)))) (shen.internal-to-P? (tlstr V8031) (tlstr V8032))) (true false)))

(defun shen.process-applications (V8035 V8036) (cond ((element? V8035 V8036) V8035) ((and (cons? V8035) (shen.non-application? (hd V8035))) (shen.special-case (hd V8035) V8035 V8036)) ((cons? V8035) (shen.process-application (map (lambda Y (shen.process-applications Y V8036)) V8035) V8036)) (true V8035)))

(defun shen.non-application? (V8039) (cond ((= define V8039) true) ((= defun V8039) true) ((= synonyms V8039) true) ((shen.special? V8039) true) ((shen.extraspecial? V8039) true) (true false)))

(defun shen.special-case (V8044 V8045 V8046) (cond ((and (= lambda V8044) (and (cons? V8045) (and (= lambda (hd V8045)) (and (cons? (tl V8045)) (and (cons? (tl (tl V8045))) (= () (tl (tl (tl V8045))))))))) (cons lambda (cons (hd (tl V8045)) (cons (shen.process-applications (hd (tl (tl V8045))) V8046) ())))) ((and (= let V8044) (and (cons? V8045) (and (= let (hd V8045)) (and (cons? (tl V8045)) (and (cons? (tl (tl V8045))) (and (cons? (tl (tl (tl V8045)))) (= () (tl (tl (tl (tl V8045))))))))))) (cons let (cons (hd (tl V8045)) (cons (shen.process-applications (hd (tl (tl V8045))) V8046) (cons (shen.process-applications (hd (tl (tl (tl V8045)))) V8046) ()))))) ((and (= defun V8044) (and (cons? V8045) (and (= defun (hd V8045)) (and (cons? (tl V8045)) (and (cons? (tl (tl V8045))) (and (cons? (tl (tl (tl V8045)))) (= () (tl (tl (tl (tl V8045))))))))))) V8045) ((and (= define V8044) (and (cons? V8045) (and (= define (hd V8045)) (and (cons? (tl V8045)) (and (cons? (tl (tl V8045))) (= { (hd (tl (tl V8045))))))))) (cons define (cons (hd (tl V8045)) (cons { (shen.process-after-type (hd (tl V8045)) (tl (tl (tl V8045))) V8046))))) ((and (= define V8044) (and (cons? V8045) (and (= define (hd V8045)) (cons? (tl V8045))))) (cons define (cons (hd (tl V8045)) (map (lambda Y (shen.process-applications Y V8046)) (tl (tl V8045)))))) ((= synonyms V8044) (cons synonyms V8045)) ((and (= type V8044) (and (cons? V8045) (and (= type (hd V8045)) (and (cons? (tl V8045)) (and (cons? (tl (tl V8045))) (= () (tl (tl (tl V8045))))))))) (cons type (cons (shen.process-applications (hd (tl V8045)) V8046) (tl (tl V8045))))) ((and (= input+ V8044) (and (cons? V8045) (and (= input+ (hd V8045)) (and (cons? (tl V8045)) (and (cons? (tl (tl V8045))) (= () (tl (tl (tl V8045))))))))) (cons input+ (cons (hd (tl V8045)) (cons (shen.process-applications (hd (tl (tl V8045))) V8046) ())))) ((and (cons? V8045) (shen.special? (hd V8045))) (cons (hd V8045) (map (lambda Y (shen.process-applications Y V8046)) (tl V8045)))) ((and (cons? V8045) (shen.extraspecial? (hd V8045))) V8045) (true (shen.f-error shen.special-case))))

(defun shen.process-after-type (V8049 V8050 V8051) (cond ((and (cons? V8050) (= } (hd V8050))) (cons } (map (lambda Y (shen.process-applications Y V8051)) (tl V8050)))) ((cons? V8050) (cons (hd V8050) (shen.process-after-type V8049 (tl V8050) V8051))) (true (simple-error (cn "missing } in " (shen.app V8049 "
" shen.a))))))

(defun shen.process-application (V8052 V8053) (cond ((cons? V8052) (let ArityF (arity (hd V8052)) (let N (length (tl V8052)) (if (element? V8052 V8053) V8052 (if (shen.shen-call? (hd V8052)) V8052 (if (shen.fn-call? V8052) (shen.fn-call V8052) (if (shen.zero-place? V8052) V8052 (if (shen.undefined-f? (hd V8052) ArityF) (shen.simple-curry (cons (cons fn (cons (hd V8052) ())) (tl V8052))) (if (variable? (hd V8052)) (shen.simple-curry V8052) (if (shen.application? (hd V8052)) (shen.simple-curry V8052) (if (shen.partial-application*? (hd V8052) ArityF N) (shen.lambda-function V8052 (- ArityF N)) (if (shen.overapplication? (hd V8052) ArityF N) (shen.simple-curry V8052) V8052)))))))))))) (true (shen.f-error shen.process-application))))

(defun shen.zero-place? (V8056) (cond ((and (cons? V8056) (= () (tl V8056))) true) (true false)))

(defun shen.shen-call? (V8057) (and (symbol? V8057) (shen.internal-to-shen? (str V8057))))

(defun shen.internal-to-shen? (V8062) (cond ((and (shen.+string? V8062) (and (= "s" (hdstr V8062)) (and (shen.+string? (tlstr V8062)) (and (= "h" (hdstr (tlstr V8062))) (and (shen.+string? (tlstr (tlstr V8062))) (and (= "e" (hdstr (tlstr (tlstr V8062)))) (and (shen.+string? (tlstr (tlstr (tlstr V8062)))) (and (= "n" (hdstr (tlstr (tlstr (tlstr V8062))))) (and (shen.+string? (tlstr (tlstr (tlstr (tlstr V8062))))) (= "." (hdstr (tlstr (tlstr (tlstr (tlstr V8062))))))))))))))) true) (true false)))

(defun shen.application? (V8065) (cond ((and (cons? V8065) (and (= protect (hd V8065)) (and (cons? (tl V8065)) (= () (tl (tl V8065)))))) false) (true (cons? V8065))))

(defun shen.undefined-f? (V8070 V8071) (cond ((= -1 V8071) (and (shen.lowercase-symbol? V8070) (not (element? V8070 (external shen))))) (true false)))

(defun shen.lowercase-symbol? (V8072) (and (symbol? V8072) (not (variable? V8072))))

(defun shen.simple-curry (V8073) (cond ((and (cons? V8073) (and (cons? (tl V8073)) (= () (tl (tl V8073))))) V8073) ((and (cons? V8073) (and (cons? (tl V8073)) (cons? (tl (tl V8073))))) (shen.simple-curry (cons (cons (hd V8073) (cons (hd (tl V8073)) ())) (tl (tl V8073))))) (true V8073)))

(defun function (V8074) (fn V8074))

(defun fn (V8075) (let LookUp (assoc V8075 (value shen.*lambdatable*)) (if (empty? LookUp) (simple-error (cn "fn: " (shen.app V8075 " is undefined
" shen.a))) (tl LookUp))))

(defun shen.fn-call? (V8078) (cond ((and (cons? V8078) (and (= fn (hd V8078)) (and (cons? (tl V8078)) (= () (tl (tl V8078)))))) true) ((and (cons? V8078) (and (= function (hd V8078)) (and (cons? (tl V8078)) (= () (tl (tl V8078)))))) true) (true false)))

(defun shen.fn-call (V8079) (cond ((and (cons? V8079) (and (= function (hd V8079)) (and (cons? (tl V8079)) (= () (tl (tl V8079)))))) (shen.fn-call (cons fn (tl V8079)))) ((and (cons? V8079) (and (= fn (hd V8079)) (and (cons? (tl V8079)) (= () (tl (tl V8079)))))) (let ArityF (arity (hd (tl V8079))) (if (= ArityF -1) V8079 (if (= ArityF 0) (simple-error "fn cannot be applied to a zero place function
") (shen.lambda-function (tl V8079) ArityF))))) (true (shen.f-error shen.fn-call))))

(defun shen.partial-application*? (V8080 V8081 V8082) (let Verdict (> V8081 V8082) (let Message (if (and Verdict (and (shen.loading?) (not (element? V8080 (cons + (cons - ())))))) (pr (cn "partial application of " (shen.app V8080 "
" shen.a)) (stoutput)) shen.skip) Verdict)))

(defun shen.loading? () (value shen.*loading?*))

(defun shen.overapplication? (V8087 V8088 V8089) (cond ((= -1 V8088) false) (true (let Verdict (< V8088 V8089) (let Message (if (and Verdict (shen.loading?)) (pr (shen.app V8087 (cn " might not like " (shen.app V8089 (cn " argument" (shen.app (if (= V8089 1) "" "s") "
" shen.a)) shen.a)) shen.a) (stoutput)) shen.skip) Verdict)))))

