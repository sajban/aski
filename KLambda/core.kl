(defun shen.shen->kl (V10729) (let KL (shen.shen->kl-h V10729) (shen.record-and-evaluate KL)))

(defun shen.record-and-evaluate (V10730) (cond ((and (cons? V10730) (and (= defun (hd V10730)) (and (cons? (tl V10730)) (and (cons? (tl (tl V10730))) (and (cons? (tl (tl (tl V10730)))) (= () (tl (tl (tl (tl V10730)))))))))) (let SysfuncChk (if (shen.sysfunc? (hd (tl V10730))) (simple-error (shen.app (hd (tl V10730)) " is not a legitimate function name
" shen.a)) shen.skip) (let Arity (shen.store-arity (hd (tl V10730)) (length (hd (tl (tl V10730))))) (let Record (shen.record-kl (hd (tl V10730)) V10730) (let Eval (eval-kl V10730) (shen.fn-print (hd (tl V10730)))))))) (true V10730)))

(defun shen.shen->kl-h (V10731) (cond ((and (cons? V10731) (and (= define (hd V10731)) (cons? (tl V10731)))) (shen.shendef->kldef (hd (tl V10731)) (tl (tl V10731)))) ((and (cons? V10731) (and (= defun (hd V10731)) (and (cons? (tl V10731)) (and (cons? (tl (tl V10731))) (and (cons? (tl (tl (tl V10731)))) (= () (tl (tl (tl (tl V10731)))))))))) V10731) ((and (cons? V10731) (and (= type (hd V10731)) (and (cons? (tl V10731)) (and (cons? (tl (tl V10731))) (= () (tl (tl (tl V10731)))))))) (cons type (cons (hd (tl V10731)) (cons (shen.rcons_form (hd (tl (tl V10731)))) ())))) ((and (cons? V10731) (and (= input+ (hd V10731)) (and (cons? (tl V10731)) (and (cons? (tl (tl V10731))) (= () (tl (tl (tl V10731)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V10731))) (tl (tl V10731))))) ((cons? V10731) (map (lambda Z (shen.shen->kl-h Z)) V10731)) (true V10731)))

(defun shen.shendef->kldef (V10732 V10733) (compile (lambda X (shen.<define> X)) (cons V10732 V10733)))

(defun shen.<define> (V10734) (let Result (let Parseshen.<name> (shen.<name> V10734) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (if (shen.=hd? Parseshen.<name> {) (let News10697 (shen.tls Parseshen.<name>) (let Parseshen.<signature> (shen.<signature> News10697) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (shen.=hd? Parseshen.<signature> }) (let News10698 (shen.tls Parseshen.<signature>) (let Parseshen.<rules> (shen.<rules> News10698) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>)))))) (shen.parse-failure))))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<name> (shen.<name> V10734) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<name>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.shendef->kldef-h (V10735 V10736) (let Ps (map (lambda X (fst X)) V10736) (let Arity (shen.arity-chk V10735 Ps) (let FreeVarChk (map (lambda R (shen.free-var-chk V10735 R)) V10736) (let KL (shen.factorise-code (shen.compile-to-kl V10735 V10736 Arity)) KL)))))

(defun shen.<name> (V10737) (let Result (if (shen.non-empty-stream? V10737) (let X (shen.hds V10737) (let News10700 (shen.tls V10737) (shen.comb (shen.in-> News10700) (if (and (symbol? X) (not (variable? X))) X (simple-error (shen.app X " is not a legitimate function name.
" shen.a)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<signature> (V10738) (let Result (if (shen.non-empty-stream? V10738) (let X (shen.hds V10738) (let News10702 (shen.tls V10738) (let Parseshen.<signature> (shen.<signature> News10702) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (not (element? X (cons { (cons } ())))) (shen.comb (shen.in-> Parseshen.<signature>) (cons X (shen.<-out Parseshen.<signature>))) (shen.parse-failure)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V10738) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<rules> (V10739) (let Result (let Parseshen.<rule> (shen.<rule> V10739) (if (shen.parse-failure? Parseshen.<rule>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<rule>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (cons (shen.linearise (shen.<-out Parseshen.<rule>)) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<!> (<!> V10739) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (shen.comb (shen.in-> Parse<!>) (if (empty? (shen.<-out Parse<!>)) () (simple-error (cn "Shen syntax error here:
 " (shen.app (shen.<-out Parse<!>) "
 ..." shen.r))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.linearise (V10742) (cond ((tuple? V10742) (shen.linearise-h (fst V10742) (fst V10742) () (snd V10742))) (true (simple-error "implementation error in shen.linearise"))))

(defun shen.linearise-h (V10755 V10756 V10757 V10758) (cond ((= () V10755) (@p V10756 V10758)) ((and (cons? V10755) (cons? (hd V10755))) (shen.linearise-h (append (hd V10755) (tl V10755)) V10756 V10757 V10758)) ((and (cons? V10755) (variable? (hd V10755))) (if (element? (hd V10755) V10757) (let Z (gensym (protect V)) (shen.linearise-h (tl V10755) (shen.rep-X (hd V10755) Z V10756) V10757 (cons where (cons (cons = (cons Z (cons (hd V10755) ()))) (cons V10758 ()))))) (shen.linearise-h (tl V10755) V10756 (cons (hd V10755) V10757) V10758))) ((cons? V10755) (shen.linearise-h (tl V10755) V10756 V10757 V10758)) (true (simple-error "implementation error in shen.linearise-h"))))

(defun shen.<rule> (V10759) (let Result (let Parseshen.<patterns> (shen.<patterns> V10759) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News10705 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News10705) (let Action (shen.hds News10705) (let News10706 (shen.tls News10705) (if (shen.=hd? News10706 where) (let News10707 (shen.tls News10706) (if (shen.non-empty-stream? News10707) (let Guard (shen.hds News10707) (let News10708 (shen.tls News10707) (shen.comb (shen.in-> News10708) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons Action ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V10759) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News10709 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News10709) (let Action (shen.hds News10709) (let News10710 (shen.tls News10709) (shen.comb (shen.in-> News10710) (@p (shen.<-out Parseshen.<patterns>) Action)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V10759) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News10711 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News10711) (let Action (shen.hds News10711) (let News10712 (shen.tls News10711) (if (shen.=hd? News10712 where) (let News10713 (shen.tls News10712) (if (shen.non-empty-stream? News10713) (let Guard (shen.hds News10713) (let News10714 (shen.tls News10713) (shen.comb (shen.in-> News10714) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons (cons shen.choicepoint! (cons Action ())) ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V10759) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News10715 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News10715) (let Action (shen.hds News10715) (let News10716 (shen.tls News10715) (shen.comb (shen.in-> News10716) (@p (shen.<-out Parseshen.<patterns>) (cons shen.choicepoint! (cons Action ())))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<patterns> (V10760) (let Result (let Parseshen.<pattern> (shen.<pattern> V10760) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (let Parseshen.<patterns> (shen.<patterns> Parseshen.<pattern>) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<patterns>) (cons (shen.<-out Parseshen.<pattern>) (shen.<-out Parseshen.<patterns>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V10760) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern> (V10761) (let Result (if (shen.ccons? V10761) (let SynCons (shen.comb (shen.hds V10761) (shen.<-out V10761)) (let Parseshen.<constructor> (shen.<constructor> SynCons) (if (shen.parse-failure? Parseshen.<constructor>) (shen.parse-failure) (let Parseshen.<pattern1> (shen.<pattern1> Parseshen.<constructor>) (if (shen.parse-failure? Parseshen.<pattern1>) (shen.parse-failure) (let Parseshen.<pattern2> (shen.<pattern2> Parseshen.<pattern1>) (if (shen.parse-failure? Parseshen.<pattern2>) (shen.parse-failure) (let Parseshen.<end> (shen.<end> Parseshen.<pattern2>) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V10761)) (cons (shen.<-out Parseshen.<constructor>) (cons (shen.<-out Parseshen.<pattern1>) (cons (shen.<-out Parseshen.<pattern2>) ()))))))))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V10761) (let SynCons (shen.comb (shen.hds V10761) (shen.<-out V10761)) (if (shen.=hd? SynCons vector) (let News10719 (shen.tls SynCons) (if (shen.=hd? News10719 0) (let News10720 (shen.tls News10719) (let Parseshen.<end> (shen.<end> News10720) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V10761)) (cons vector (cons 0 ())))))) (shen.parse-failure))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V10761) (let X (shen.hds V10761) (let News10721 (shen.tls V10761) (if (cons? X) (shen.comb (shen.in-> News10721) (shen.constructor-error X)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parseshen.<simple-pattern> (shen.<simple-pattern> V10761) (if (shen.parse-failure? Parseshen.<simple-pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<simple-pattern>) (shen.<-out Parseshen.<simple-pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<constructor> (V10762) (let Result (if (shen.non-empty-stream? V10762) (let C (shen.hds V10762) (let News10723 (shen.tls V10762) (if (shen.constructor? C) (shen.comb (shen.in-> News10723) C) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.constructor? (V10763) (element? V10763 (cons cons (cons @p (cons @s (cons @v ()))))))

(defun shen.constructor-error (V10764) (simple-error (shen.app V10764 " is not a legitimate constructor
" shen.r)))

(defun shen.<simple-pattern> (V10765) (let Result (if (shen.non-empty-stream? V10765) (let X (shen.hds V10765) (let News10725 (shen.tls V10765) (if (= X _) (shen.comb (shen.in-> News10725) (gensym (protect Y))) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V10765) (let X (shen.hds V10765) (let News10726 (shen.tls V10765) (if (not (element? X (cons -> (cons <- ())))) (shen.comb (shen.in-> News10726) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern1> (V10766) (let Result (let Parseshen.<pattern> (shen.<pattern> V10766) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<pattern2> (V10767) (let Result (let Parseshen.<pattern> (shen.<pattern> V10767) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.fn-print (V10768) (let V (absvector 2) (let Print (address-> V 0 shen.printF) (let Named (address-> Print 1 (@s "(" (@s "f" (@s "n" (@s " " (@s (str V10768) ")")))))) Named))))

(defun shen.printF (V10769) (<-address V10769 1))

(defun shen.arity-chk (V10774 V10775) (cond ((and (cons? V10775) (= () (tl V10775))) (length (hd V10775))) ((and (cons? V10775) (and (cons? (tl V10775)) (= (length (hd V10775)) (length (hd (tl V10775)))))) (shen.arity-chk V10774 (tl V10775))) (true (simple-error (cn "arity error in " (shen.app V10774 "
" shen.a))))))

(defun shen.free-var-chk (V10776 V10777) (cond ((tuple? V10777) (shen.free-variable-error-message V10776 (shen.find-free-vars (shen.extract-vars (fst V10777)) (snd V10777)))) (true (shen.f-error shen.free-var-chk))))

(defun shen.free-variable-error-message (V10778 V10779) (if (empty? V10779) shen.skip (do (pr (cn "free variables in " (shen.app V10778 ":" shen.a)) (stoutput)) (do (map (lambda X (pr (cn " " (shen.app X "" shen.a)) (stoutput))) V10779) (do (nl 1) (abort))))))

(defun shen.extract-vars (V10782) (cond ((variable? V10782) (cons V10782 ())) ((cons? V10782) (union (shen.extract-vars (hd V10782)) (shen.extract-vars (tl V10782)))) (true ())))

(defun shen.find-free-vars (V10787 V10788) (cond ((and (cons? V10788) (and (= protect (hd V10788)) (and (cons? (tl V10788)) (= () (tl (tl V10788)))))) ()) ((and (cons? V10788) (and (= let (hd V10788)) (and (cons? (tl V10788)) (and (cons? (tl (tl V10788))) (and (cons? (tl (tl (tl V10788)))) (= () (tl (tl (tl (tl V10788)))))))))) (union (shen.find-free-vars V10787 (hd (tl (tl V10788)))) (shen.find-free-vars (cons (hd (tl V10788)) V10787) (hd (tl (tl (tl V10788))))))) ((and (cons? V10788) (and (= lambda (hd V10788)) (and (cons? (tl V10788)) (and (cons? (tl (tl V10788))) (= () (tl (tl (tl V10788)))))))) (shen.find-free-vars (cons (hd (tl V10788)) V10787) (hd (tl (tl V10788))))) ((cons? V10788) (union (shen.find-free-vars V10787 (hd V10788)) (shen.find-free-vars V10787 (tl V10788)))) ((shen.free-variable? V10788 V10787) (cons V10788 ())) (true ())))

(defun shen.free-variable? (V10789 V10790) (and (variable? V10789) (not (element? V10789 V10790))))

(defun shen.record-kl (V10791 V10792) (put V10791 shen.source V10792 (value *property-vector*)))

(defun shen.compile-to-kl (V10793 V10794 V10795) (let Parameters (shen.parameters V10795) (let Body (shen.scan-body V10793 (shen.kl-body V10794 Parameters)) (let Defun (cons defun (cons V10793 (cons Parameters (cons (shen.cond-form Body) ())))) Defun))))

(defun shen.parameters (V10796) (cond ((= 0 V10796) ()) (true (cons (gensym (protect V)) (shen.parameters (- V10796 1))))))

(defun shen.cond-form (V10799) (cond ((and (cons? V10799) (and (cons? (hd V10799)) (and (= true (hd (hd V10799))) (and (cons? (tl (hd V10799))) (= () (tl (tl (hd V10799)))))))) (hd (tl (hd V10799)))) (true (cons cond V10799))))

(defun shen.scan-body (V10808 V10809) (cond ((= () V10809) (cons (cons true (cons (cons shen.f-error (cons V10808 ())) ())) ())) ((and (cons? V10809) (shen.choicepoint? (hd V10809))) (shen.choicepoint V10808 (gensym (protect Freeze)) (gensym (protect Result)) (hd V10809) (tl V10809))) ((and (cons? V10809) (and (cons? (hd V10809)) (and (= true (hd (hd V10809))) (and (cons? (tl (hd V10809))) (= () (tl (tl (hd V10809)))))))) (cons (hd V10809) ())) ((cons? V10809) (cons (hd V10809) (shen.scan-body V10808 (tl V10809)))) (true (simple-error "implementation error in shen.scan-body"))))

(defun shen.choicepoint? (V10816) (cond ((and (cons? V10816) (and (cons? (tl V10816)) (and (cons? (hd (tl V10816))) (and (= shen.choicepoint! (hd (hd (tl V10816)))) (and (cons? (tl (hd (tl V10816)))) (and (= () (tl (tl (hd (tl V10816))))) (= () (tl (tl V10816))))))))) true) (true false)))

(defun shen.choicepoint (V10832 V10833 V10834 V10835 V10836) (cond ((and (cons? V10835) (and (cons? (tl V10835)) (and (cons? (hd (tl V10835))) (and (cons? (tl (hd (tl V10835)))) (and (cons? (hd (tl (hd (tl V10835))))) (and (= fail-if (hd (hd (tl (hd (tl V10835)))))) (and (cons? (tl (hd (tl (hd (tl V10835)))))) (and (cons? (tl (tl (hd (tl (hd (tl V10835))))))) (and (= () (tl (tl (tl (hd (tl (hd (tl V10835)))))))) (and (= () (tl (tl (hd (tl V10835))))) (and (= () (tl (tl V10835))) (= V10832 (hd (tl (hd (tl (hd (tl V10835)))))))))))))))))) (cons (cons true (cons (cons let (cons V10833 (cons (cons freeze (cons (cons cond (shen.scan-body (hd (tl (hd (tl (hd (tl V10835)))))) V10836)) ())) (cons (cons if (cons (hd V10835) (cons (cons let (cons V10834 (cons (hd (tl (tl (hd (tl (hd (tl V10835))))))) (cons (cons if (cons (cons (hd (tl (hd (tl (hd (tl V10835)))))) (cons V10834 ())) (cons (cons thaw (cons V10833 ())) (cons V10834 ())))) ())))) (cons (cons thaw (cons V10833 ())) ())))) ())))) ())) ())) ((and (cons? V10835) (and (cons? (tl V10835)) (and (cons? (hd (tl V10835))) (and (cons? (tl (hd (tl V10835)))) (and (= () (tl (tl (hd (tl V10835))))) (= () (tl (tl V10835)))))))) (cons (cons true (cons (cons let (cons V10833 (cons (cons freeze (cons (cons cond (shen.scan-body V10832 V10836)) ())) (cons (cons if (cons (hd V10835) (cons (cons let (cons V10834 (cons (hd (tl (hd (tl V10835)))) (cons (cons if (cons (cons = (cons V10834 (cons (cons fail ()) ()))) (cons (cons thaw (cons V10833 ())) (cons V10834 ())))) ())))) (cons (cons thaw (cons V10833 ())) ())))) ())))) ())) ())) (true (simple-error "implementation error in shen.choicepoint"))))

(defun shen.rep-X (V10838 V10839 V10840) (cond ((= V10838 V10840) V10839) ((cons? V10840) (let Rep (shen.rep-X V10838 V10839 (hd V10840)) (if (= Rep (hd V10840)) (cons (hd V10840) (shen.rep-X V10838 V10839 (tl V10840))) (cons Rep (tl V10840))))) (true V10840)))

(defun shen.kl-body (V10841 V10842) (map (lambda R (shen.triple-stack () (fst R) V10842 (snd R))) V10841))

(defun shen.triple-stack (V10851 V10852 V10853 V10854) (cond ((and (= () V10852) (and (= () V10853) (and (cons? V10854) (and (= where (hd V10854)) (and (cons? (tl V10854)) (and (cons? (tl (tl V10854))) (= () (tl (tl (tl V10854)))))))))) (shen.triple-stack (cons (hd (tl V10854)) V10851) () () (hd (tl (tl V10854))))) ((and (= () V10852) (= () V10853)) (cons (shen.rectify-test (reverse V10851)) (cons V10854 ()))) ((and (cons? V10852) (and (cons? V10853) (variable? (hd V10852)))) (shen.triple-stack V10851 (tl V10852) (tl V10853) (shen.beta (hd V10852) (hd V10853) V10854))) ((and (cons? V10852) (and (cons? (hd V10852)) (and (cons? (tl (hd V10852))) (and (cons? (tl (tl (hd V10852)))) (and (= () (tl (tl (tl (hd V10852))))) (cons? V10853)))))) (shen.triple-stack (cons (cons (shen.op-test (hd (hd V10852))) (cons (hd V10853) ())) V10851) (cons (hd (tl (hd V10852))) (cons (hd (tl (tl (hd V10852)))) (tl V10852))) (cons (cons (shen.op1 (hd (hd V10852))) (cons (hd V10853) ())) (cons (cons (shen.op2 (hd (hd V10852))) (cons (hd V10853) ())) (tl V10853))) (shen.beta (hd V10852) (hd V10853) V10854))) ((and (cons? V10852) (cons? V10853)) (shen.triple-stack (cons (cons = (cons (hd V10852) (cons (hd V10853) ()))) V10851) (tl V10852) (tl V10853) V10854)) (true (simple-error "implementation error in shen.triple-stack"))))

(defun shen.rectify-test (V10857) (cond ((= () V10857) true) ((and (cons? V10857) (= () (tl V10857))) (hd V10857)) ((and (cons? V10857) (cons? (tl V10857))) (cons and (cons (hd V10857) (cons (shen.rectify-test (tl V10857)) ())))) (true (simple-error "implementation error in shen.rectify-test"))))

(defun shen.beta (V10867 V10868 V10869) (cond ((= V10867 V10869) V10868) ((and (cons? V10869) (and (= lambda (hd V10869)) (and (cons? (tl V10869)) (and (cons? (tl (tl V10869))) (and (= () (tl (tl (tl V10869)))) (= V10867 (hd (tl V10869)))))))) V10869) ((and (cons? V10869) (and (= let (hd V10869)) (and (cons? (tl V10869)) (and (cons? (tl (tl V10869))) (and (cons? (tl (tl (tl V10869)))) (and (= () (tl (tl (tl (tl V10869))))) (= V10867 (hd (tl V10869))))))))) (cons let (cons (hd (tl V10869)) (cons (shen.beta (hd (tl V10869)) V10868 (hd (tl (tl V10869)))) (tl (tl (tl V10869))))))) ((cons? V10869) (map (lambda V (shen.beta V10867 V10868 V)) V10869)) (true V10869)))

(defun shen.op1 (V10872) (cond ((= cons V10872) hd) ((= @s V10872) hdstr) ((= @p V10872) fst) ((= @v V10872) hdv) (true (simple-error "implementation error in shen.op1"))))

(defun shen.op2 (V10875) (cond ((= cons V10875) tl) ((= @s V10875) tlstr) ((= @p V10875) snd) ((= @v V10875) tlv) (true (simple-error "implementation error in shen.op2"))))

(defun shen.op-test (V10878) (cond ((= cons V10878) cons?) ((= @s V10878) shen.+string?) ((= @p V10878) tuple?) ((= @v V10878) shen.+vector?) (true (simple-error "implementation error in shen.op-test"))))

(defun shen.+string? (V10879) (cond ((= "" V10879) false) (true (string? V10879))))

(defun shen.+vector? (V10880) (cond ((= V10880 (vector 0)) false) (true (vector? V10880))))

(defun factorise (V10883) (cond ((= + V10883) (set shen.*factorise?* true)) ((= - V10883) (set shen.*factorise?* false)) (true (simple-error "factorise expects a + or a -
"))))

(defun shen.factorise-code (V10884) (cond ((and (cons? V10884) (and (= defun (hd V10884)) (and (cons? (tl V10884)) (and (cons? (tl (tl V10884))) (and (cons? (tl (tl (tl V10884)))) (and (cons? (hd (tl (tl (tl V10884))))) (and (= cond (hd (hd (tl (tl (tl V10884)))))) (and (= () (tl (tl (tl (tl V10884))))) (value shen.*factorise?*))))))))) (cons defun (cons (hd (tl V10884)) (cons (hd (tl (tl V10884))) (cons (shen.vertical (hd (tl (tl V10884))) (tl (hd (tl (tl (tl V10884))))) (cons shen.f-error (cons (hd (tl V10884)) ()))) ()))))) (true V10884)))

(defun shen.vertical (V10897 V10898 V10899) (cond ((and (cons? V10898) (and (cons? (hd V10898)) (and (= true (hd (hd V10898))) (and (cons? (tl (hd V10898))) (= () (tl (tl (hd V10898)))))))) (hd (tl (hd V10898)))) ((= () V10898) V10899) ((and (cons? V10898) (and (cons? (hd V10898)) (and (cons? (hd (hd V10898))) (and (= and (hd (hd (hd V10898)))) (and (cons? (tl (hd (hd V10898)))) (and (cons? (tl (tl (hd (hd V10898))))) (and (= () (tl (tl (tl (hd (hd V10898)))))) (and (cons? (tl (hd V10898))) (= () (tl (tl (hd V10898)))))))))))) (let Before+After (shen.split-cases (hd (tl (hd (hd V10898)))) V10898 ()) (shen.branch (hd (tl (hd (hd V10898)))) V10897 Before+After V10899))) ((and (cons? V10898) (and (cons? (hd V10898)) (and (cons? (tl (hd V10898))) (= () (tl (tl (hd V10898))))))) (cons if (cons (hd (hd V10898)) (cons (hd (tl (hd V10898))) (cons (shen.vertical V10897 (tl V10898) V10899) ()))))) (true (simple-error "implementation error in shen.vertical"))))

(defun shen.split-cases (V10904 V10905 V10906) (cond ((and (cons? V10905) (and (cons? (hd V10905)) (and (cons? (hd (hd V10905))) (and (= and (hd (hd (hd V10905)))) (and (cons? (tl (hd (hd V10905)))) (and (cons? (tl (tl (hd (hd V10905))))) (and (= () (tl (tl (tl (hd (hd V10905)))))) (and (cons? (tl (hd V10905))) (and (= () (tl (tl (hd V10905)))) (= V10904 (hd (tl (hd (hd V10905)))))))))))))) (shen.split-cases (hd (tl (hd (hd V10905)))) (tl V10905) (cons (cons (hd (tl (tl (hd (hd V10905))))) (tl (hd V10905))) V10906))) ((and (cons? V10905) (and (cons? (hd V10905)) (and (cons? (tl (hd V10905))) (and (= () (tl (tl (hd V10905)))) (= V10904 (hd (hd V10905))))))) (shen.split-cases (hd (hd V10905)) (tl V10905) (cons (cons true (tl (hd V10905))) V10906))) (true (cons (reverse V10906) (cons V10905 ())))))

(defun shen.branch (V10907 V10908 V10909 V10910) (cond ((and (cons? V10909) (and (cons? (tl V10909)) (= () (tl (tl V10909))))) (let Else (shen.else V10908 (hd (tl V10909)) V10910) (let Then (shen.then V10907 V10908 (hd V10909) Else) (cons if (cons V10907 (cons Then (cons Else ()))))))) (true (shen.f-error shen.branch))))

(defun shen.else (V10911 V10912 V10913) (let Else (shen.vertical V10911 V10912 V10913) (if (shen.inline? Else) Else (shen.procedure-call V10911 Else))))

(defun shen.procedure-call (V10914 V10915) (let F (gensym shen.else) (let Used (shen.remove-if-unused V10914 V10915) (let KL (cons defun (cons F (cons Used (cons V10915 ())))) (let EvalKL (eval-kl KL) (let Record (shen.record-kl F KL) (cons F Used)))))))

(defun shen.remove-if-unused (V10922 V10923) (cond ((= () V10922) ()) ((cons? V10922) (if (shen.occurs? (hd V10922) V10923) (cons (hd V10922) (shen.remove-if-unused (tl V10922) V10923)) (shen.remove-if-unused (tl V10922) V10923))) (true (simple-error "implementation error in shen.remove-if-unused"))))

(defun shen.then (V10924 V10925 V10926 V10927) (shen.horizontal (shen.selectors V10924 V10926) V10925 V10926 V10927))

(defun shen.horizontal (V10936 V10937 V10938 V10939) (cond ((= () V10936) (shen.vertical V10937 V10938 V10939)) ((cons? V10936) (let V (gensym (protect V)) (cons let (cons V (cons (hd V10936) (cons (shen.horizontal (tl V10936) (cons V V10937) (subst V (hd V10936) V10938) V10939) ())))))) (true (simple-error "implementation error in shen.horizontal"))))

(defun shen.selectors (V10944 V10945) (cond ((and (cons? V10944) (and (cons? (tl V10944)) (and (= () (tl (tl V10944))) (shen.constructor? (shen.op (hd V10944)))))) (let Op (shen.op (hd V10944)) (let Hd (cons (shen.op1 Op) (tl V10944)) (let Tl (cons (shen.op2 Op) (tl V10944)) (let RptedHd? (shen.rpted? Hd V10945) (let RptedTl? (shen.rpted? Tl V10945) (if (and RptedHd? RptedTl?) (cons Hd (cons Tl ())) (if RptedHd? (cons Hd ()) (if RptedTl? (cons Tl ()) ()))))))))) (true ())))

(defun shen.rpted? (V10946 V10947) (> (occurrences V10946 V10947) 1))

(defun shen.inline? (V10948) (cond ((cons? V10948) (and (atom? (hd V10948)) (shen.inline? (tl V10948)))) (true (atom? V10948))))

(defun shen.op (V10951) (cond ((= cons? V10951) cons) ((= shen.+string? V10951) @s) ((= shen.+vector? V10951) @v) ((= tuple? V10951) @p) (true shen.skip)))

