(defun shen.shen->kl (V1448) (let KL (shen.shen->kl-h V1448) (shen.record-and-evaluate KL)))

(defun shen.record-and-evaluate (V1449) (cond ((and (cons? V1449) (and (= defun (hd V1449)) (and (cons? (tl V1449)) (and (cons? (tl (tl V1449))) (and (cons? (tl (tl (tl V1449)))) (= () (tl (tl (tl (tl V1449)))))))))) (let SysfuncChk (if (shen.sysfunc? (hd (tl V1449))) (simple-error (shen.app (hd (tl V1449)) " is not a legitimate function name
" shen.a)) shen.skip) (let Arity (shen.store-arity (hd (tl V1449)) (length (hd (tl (tl V1449))))) (let Record (shen.record-kl (hd (tl V1449)) V1449) (let Eval (eval-kl V1449) (shen.fn-print (hd (tl V1449)))))))) (true V1449)))

(defun shen.shen->kl-h (V1450) (cond ((and (cons? V1450) (and (= define (hd V1450)) (cons? (tl V1450)))) (shen.shendef->kldef (hd (tl V1450)) (tl (tl V1450)))) ((and (cons? V1450) (and (= defun (hd V1450)) (and (cons? (tl V1450)) (and (cons? (tl (tl V1450))) (and (cons? (tl (tl (tl V1450)))) (= () (tl (tl (tl (tl V1450)))))))))) V1450) ((and (cons? V1450) (and (= type (hd V1450)) (and (cons? (tl V1450)) (and (cons? (tl (tl V1450))) (= () (tl (tl (tl V1450)))))))) (cons type (cons (hd (tl V1450)) (cons (shen.rcons_form (hd (tl (tl V1450)))) ())))) ((and (cons? V1450) (and (= input+ (hd V1450)) (and (cons? (tl V1450)) (and (cons? (tl (tl V1450))) (= () (tl (tl (tl V1450)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V1450))) (tl (tl V1450))))) ((cons? V1450) (map (lambda Z (shen.shen->kl-h Z)) V1450)) (true V1450)))

(defun shen.shendef->kldef (V1451 V1452) (compile (lambda X (shen.<define> X)) (cons V1451 V1452)))

(defun shen.<define> (V1453) (let Result (let Parseshen.<name> (shen.<name> V1453) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (if (shen.=hd? Parseshen.<name> {) (let News1313 (shen.tls Parseshen.<name>) (let Parseshen.<signature> (shen.<signature> News1313) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (shen.=hd? Parseshen.<signature> }) (let News1314 (shen.tls Parseshen.<signature>) (let Parseshen.<rules> (shen.<rules> News1314) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>)))))) (shen.parse-failure))))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<name> (shen.<name> V1453) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<name>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.shendef->kldef-h (V1454 V1455) (let Ps (map (lambda X (fst X)) V1455) (let Arity (shen.arity-chk V1454 Ps) (let FreeVarChk (map (lambda R (shen.free-var-chk V1454 R)) V1455) (let Unprotect (shen.unprotect V1455) (let KL (shen.factorise-code (shen.compile-to-kl V1454 Unprotect Arity)) KL))))))

(defun shen.unprotect (V1456) (cond ((tuple? V1456) (@p (shen.unprotect (fst V1456)) (shen.unprotect (snd V1456)))) ((and (cons? V1456) (and (= protect (hd V1456)) (and (cons? (tl V1456)) (= () (tl (tl V1456)))))) (shen.unprotect (hd (tl V1456)))) ((cons? V1456) (map (lambda Z (shen.unprotect Z)) V1456)) (true V1456)))

(defun shen.<name> (V1457) (let Result (if (shen.non-empty-stream? V1457) (let X (shen.hds V1457) (let News1316 (shen.tls V1457) (shen.comb (shen.in-> News1316) (if (and (symbol? X) (not (variable? X))) X (simple-error (shen.app X " is not a legitimate function name.
" shen.a)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<signature> (V1458) (let Result (if (shen.non-empty-stream? V1458) (let X (shen.hds V1458) (let News1318 (shen.tls V1458) (let Parseshen.<signature> (shen.<signature> News1318) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (not (element? X (cons { (cons } ())))) (shen.comb (shen.in-> Parseshen.<signature>) (cons X (shen.<-out Parseshen.<signature>))) (shen.parse-failure)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V1458) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<rules> (V1459) (let Result (let Parseshen.<rule> (shen.<rule> V1459) (if (shen.parse-failure? Parseshen.<rule>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<rule>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (cons (shen.linearise (shen.<-out Parseshen.<rule>)) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<!> (<!> V1459) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (shen.comb (shen.in-> Parse<!>) (if (empty? (shen.<-out Parse<!>)) () (simple-error (cn "Shen syntax error here:
 " (shen.app (shen.<-out Parse<!>) "
 ..." shen.r))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.linearise (V1462) (cond ((tuple? V1462) (shen.linearise-h (fst V1462) (fst V1462) () (snd V1462))) (true (simple-error "implementation error in shen.linearise"))))

(defun shen.linearise-h (V1475 V1476 V1477 V1478) (cond ((= () V1475) (@p V1476 V1478)) ((and (cons? V1475) (cons? (hd V1475))) (shen.linearise-h (append (hd V1475) (tl V1475)) V1476 V1477 V1478)) ((and (cons? V1475) (variable? (hd V1475))) (if (element? (hd V1475) V1477) (let Z (gensym V) (shen.linearise-h (tl V1475) (shen.rep-X (hd V1475) Z V1476) V1477 (cons where (cons (cons = (cons Z (cons (hd V1475) ()))) (cons V1478 ()))))) (shen.linearise-h (tl V1475) V1476 (cons (hd V1475) V1477) V1478))) ((cons? V1475) (shen.linearise-h (tl V1475) V1476 V1477 V1478)) (true (simple-error "implementation error in shen.linearise-h"))))

(defun shen.<rule> (V1479) (let Result (let Parseshen.<patterns> (shen.<patterns> V1479) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News1321 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News1321) (let Action (shen.hds News1321) (let News1322 (shen.tls News1321) (if (shen.=hd? News1322 where) (let News1323 (shen.tls News1322) (if (shen.non-empty-stream? News1323) (let Guard (shen.hds News1323) (let News1324 (shen.tls News1323) (shen.comb (shen.in-> News1324) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons Action ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V1479) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News1325 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News1325) (let Action (shen.hds News1325) (let News1326 (shen.tls News1325) (shen.comb (shen.in-> News1326) (@p (shen.<-out Parseshen.<patterns>) Action)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V1479) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News1327 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News1327) (let Action (shen.hds News1327) (let News1328 (shen.tls News1327) (if (shen.=hd? News1328 where) (let News1329 (shen.tls News1328) (if (shen.non-empty-stream? News1329) (let Guard (shen.hds News1329) (let News1330 (shen.tls News1329) (shen.comb (shen.in-> News1330) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons (cons shen.choicepoint! (cons Action ())) ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V1479) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News1331 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News1331) (let Action (shen.hds News1331) (let News1332 (shen.tls News1331) (shen.comb (shen.in-> News1332) (@p (shen.<-out Parseshen.<patterns>) (cons shen.choicepoint! (cons Action ())))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<patterns> (V1480) (let Result (let Parseshen.<pattern> (shen.<pattern> V1480) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (let Parseshen.<patterns> (shen.<patterns> Parseshen.<pattern>) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<patterns>) (cons (shen.<-out Parseshen.<pattern>) (shen.<-out Parseshen.<patterns>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V1480) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern> (V1481) (let Result (if (shen.ccons? V1481) (let SynCons (shen.comb (shen.hds V1481) (shen.<-out V1481)) (let Parseshen.<constructor> (shen.<constructor> SynCons) (if (shen.parse-failure? Parseshen.<constructor>) (shen.parse-failure) (let Parseshen.<pattern1> (shen.<pattern1> Parseshen.<constructor>) (if (shen.parse-failure? Parseshen.<pattern1>) (shen.parse-failure) (let Parseshen.<pattern2> (shen.<pattern2> Parseshen.<pattern1>) (if (shen.parse-failure? Parseshen.<pattern2>) (shen.parse-failure) (let Parseshen.<end> (shen.<end> Parseshen.<pattern2>) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V1481)) (cons (shen.<-out Parseshen.<constructor>) (cons (shen.<-out Parseshen.<pattern1>) (cons (shen.<-out Parseshen.<pattern2>) ()))))))))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V1481) (let SynCons (shen.comb (shen.hds V1481) (shen.<-out V1481)) (if (shen.=hd? SynCons vector) (let News1335 (shen.tls SynCons) (if (shen.=hd? News1335 0) (let News1336 (shen.tls News1335) (let Parseshen.<end> (shen.<end> News1336) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V1481)) (cons vector (cons 0 ())))))) (shen.parse-failure))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V1481) (let X (shen.hds V1481) (let News1337 (shen.tls V1481) (if (cons? X) (shen.comb (shen.in-> News1337) (shen.constructor-error X)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parseshen.<simple-pattern> (shen.<simple-pattern> V1481) (if (shen.parse-failure? Parseshen.<simple-pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<simple-pattern>) (shen.<-out Parseshen.<simple-pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<constructor> (V1482) (let Result (if (shen.non-empty-stream? V1482) (let C (shen.hds V1482) (let News1339 (shen.tls V1482) (if (shen.constructor? C) (shen.comb (shen.in-> News1339) C) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.constructor? (V1483) (element? V1483 (cons cons (cons @p (cons @s (cons @v ()))))))

(defun shen.constructor-error (V1484) (simple-error (shen.app V1484 " is not a legitimate constructor
" shen.r)))

(defun shen.<simple-pattern> (V1485) (let Result (if (shen.non-empty-stream? V1485) (let X (shen.hds V1485) (let News1341 (shen.tls V1485) (if (= X _) (shen.comb (shen.in-> News1341) (gensym Y)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V1485) (let X (shen.hds V1485) (let News1342 (shen.tls V1485) (if (not (element? X (cons -> (cons <- ())))) (shen.comb (shen.in-> News1342) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern1> (V1486) (let Result (let Parseshen.<pattern> (shen.<pattern> V1486) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<pattern2> (V1487) (let Result (let Parseshen.<pattern> (shen.<pattern> V1487) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.fn-print (V1488) (let V (absvector 2) (let Print (address-> V 0 shen.printF) (let Named (address-> Print 1 (@s "(" (@s "f" (@s "n" (@s " " (@s (str V1488) ")")))))) Named))))

(defun shen.printF (V1489) (<-address V1489 1))

(defun shen.arity-chk (V1494 V1495) (cond ((and (cons? V1495) (= () (tl V1495))) (length (hd V1495))) ((and (cons? V1495) (and (cons? (tl V1495)) (= (length (hd V1495)) (length (hd (tl V1495)))))) (shen.arity-chk V1494 (tl V1495))) (true (simple-error (cn "arity error in " (shen.app V1494 "
" shen.a))))))

(defun shen.free-var-chk (V1496 V1497) (cond ((tuple? V1497) (shen.free-variable-error-message V1496 (shen.find-free-vars (shen.extract-vars (fst V1497)) (snd V1497)))) (true (shen.f-error shen.free-var-chk))))

(defun shen.free-variable-error-message (V1498 V1499) (if (empty? V1499) shen.skip (do (pr (cn "free variables in " (shen.app V1498 ":" shen.a)) (stoutput)) (do (map (lambda X (pr (cn " " (shen.app X "" shen.a)) (stoutput))) V1499) (do (nl 1) (abort))))))

(defun shen.extract-vars (V1502) (cond ((variable? V1502) (cons V1502 ())) ((cons? V1502) (union (shen.extract-vars (hd V1502)) (shen.extract-vars (tl V1502)))) (true ())))

(defun shen.find-free-vars (V1507 V1508) (cond ((and (cons? V1508) (and (= protect (hd V1508)) (and (cons? (tl V1508)) (= () (tl (tl V1508)))))) ()) ((and (cons? V1508) (and (= let (hd V1508)) (and (cons? (tl V1508)) (and (cons? (tl (tl V1508))) (and (cons? (tl (tl (tl V1508)))) (= () (tl (tl (tl (tl V1508)))))))))) (union (shen.find-free-vars V1507 (hd (tl (tl V1508)))) (shen.find-free-vars (cons (hd (tl V1508)) V1507) (hd (tl (tl (tl V1508))))))) ((and (cons? V1508) (and (= lambda (hd V1508)) (and (cons? (tl V1508)) (and (cons? (tl (tl V1508))) (= () (tl (tl (tl V1508)))))))) (shen.find-free-vars (cons (hd (tl V1508)) V1507) (hd (tl (tl V1508))))) ((cons? V1508) (union (shen.find-free-vars V1507 (hd V1508)) (shen.find-free-vars V1507 (tl V1508)))) ((shen.free-variable? V1508 V1507) (cons V1508 ())) (true ())))

(defun shen.free-variable? (V1509 V1510) (and (variable? V1509) (not (element? V1509 V1510))))

(defun shen.record-kl (V1511 V1512) (put V1511 shen.source V1512 (value *property-vector*)))

(defun shen.compile-to-kl (V1513 V1514 V1515) (let Parameters (shen.parameters V1515) (let Body (shen.scan-body V1513 (shen.kl-body V1514 Parameters)) (let Defun (cons defun (cons V1513 (cons Parameters (cons (shen.cond-form Body) ())))) Defun))))

(defun shen.parameters (V1516) (cond ((= 0 V1516) ()) (true (cons (gensym V) (shen.parameters (- V1516 1))))))

(defun shen.cond-form (V1519) (cond ((and (cons? V1519) (and (cons? (hd V1519)) (and (= true (hd (hd V1519))) (and (cons? (tl (hd V1519))) (= () (tl (tl (hd V1519)))))))) (hd (tl (hd V1519)))) (true (cons cond V1519))))

(defun shen.scan-body (V1528 V1529) (cond ((= () V1529) (cons (cons true (cons (cons shen.f-error (cons V1528 ())) ())) ())) ((and (cons? V1529) (shen.choicepoint? (hd V1529))) (shen.choicepoint V1528 (gensym Freeze) (gensym Result) (hd V1529) (tl V1529))) ((and (cons? V1529) (and (cons? (hd V1529)) (and (= true (hd (hd V1529))) (and (cons? (tl (hd V1529))) (= () (tl (tl (hd V1529)))))))) (cons (hd V1529) ())) ((cons? V1529) (cons (hd V1529) (shen.scan-body V1528 (tl V1529)))) (true (simple-error "implementation error in shen.scan-body"))))

(defun shen.choicepoint? (V1536) (cond ((and (cons? V1536) (and (cons? (tl V1536)) (and (cons? (hd (tl V1536))) (and (= shen.choicepoint! (hd (hd (tl V1536)))) (and (cons? (tl (hd (tl V1536)))) (and (= () (tl (tl (hd (tl V1536))))) (= () (tl (tl V1536))))))))) true) (true false)))

(defun shen.choicepoint (V1552 V1553 V1554 V1555 V1556) (cond ((and (cons? V1555) (and (cons? (tl V1555)) (and (cons? (hd (tl V1555))) (and (cons? (tl (hd (tl V1555)))) (and (cons? (hd (tl (hd (tl V1555))))) (and (= fail-if (hd (hd (tl (hd (tl V1555)))))) (and (cons? (tl (hd (tl (hd (tl V1555)))))) (and (cons? (tl (tl (hd (tl (hd (tl V1555))))))) (and (= () (tl (tl (tl (hd (tl (hd (tl V1555)))))))) (and (= () (tl (tl (hd (tl V1555))))) (and (= () (tl (tl V1555))) (= V1552 (hd (tl (hd (tl (hd (tl V1555)))))))))))))))))) (cons (cons true (cons (cons let (cons V1553 (cons (cons freeze (cons (cons cond (shen.scan-body (hd (tl (hd (tl (hd (tl V1555)))))) V1556)) ())) (cons (cons if (cons (hd V1555) (cons (cons let (cons V1554 (cons (hd (tl (tl (hd (tl (hd (tl V1555))))))) (cons (cons if (cons (cons (hd (tl (hd (tl (hd (tl V1555)))))) (cons V1554 ())) (cons (cons thaw (cons V1553 ())) (cons V1554 ())))) ())))) (cons (cons thaw (cons V1553 ())) ())))) ())))) ())) ())) ((and (cons? V1555) (and (cons? (tl V1555)) (and (cons? (hd (tl V1555))) (and (cons? (tl (hd (tl V1555)))) (and (= () (tl (tl (hd (tl V1555))))) (= () (tl (tl V1555)))))))) (cons (cons true (cons (cons let (cons V1553 (cons (cons freeze (cons (cons cond (shen.scan-body V1552 V1556)) ())) (cons (cons if (cons (hd V1555) (cons (cons let (cons V1554 (cons (hd (tl (hd (tl V1555)))) (cons (cons if (cons (cons = (cons V1554 (cons (cons fail ()) ()))) (cons (cons thaw (cons V1553 ())) (cons V1554 ())))) ())))) (cons (cons thaw (cons V1553 ())) ())))) ())))) ())) ())) (true (simple-error "implementation error in shen.choicepoint"))))

(defun shen.rep-X (V1558 V1559 V1560) (cond ((= V1558 V1560) V1559) ((cons? V1560) (let Rep (shen.rep-X V1558 V1559 (hd V1560)) (if (= Rep (hd V1560)) (cons (hd V1560) (shen.rep-X V1558 V1559 (tl V1560))) (cons Rep (tl V1560))))) (true V1560)))

(defun shen.kl-body (V1561 V1562) (map (lambda R (shen.triple-stack () (fst R) V1562 (snd R))) V1561))

(defun shen.triple-stack (V1571 V1572 V1573 V1574) (cond ((and (= () V1572) (and (= () V1573) (and (cons? V1574) (and (= where (hd V1574)) (and (cons? (tl V1574)) (and (cons? (tl (tl V1574))) (= () (tl (tl (tl V1574)))))))))) (shen.triple-stack (cons (hd (tl V1574)) V1571) () () (hd (tl (tl V1574))))) ((and (= () V1572) (= () V1573)) (cons (shen.rectify-test (reverse V1571)) (cons V1574 ()))) ((and (cons? V1572) (and (cons? V1573) (variable? (hd V1572)))) (shen.triple-stack V1571 (tl V1572) (tl V1573) (shen.beta (hd V1572) (hd V1573) V1574))) ((and (cons? V1572) (and (cons? (hd V1572)) (and (cons? (tl (hd V1572))) (and (cons? (tl (tl (hd V1572)))) (and (= () (tl (tl (tl (hd V1572))))) (cons? V1573)))))) (shen.triple-stack (cons (cons (shen.op-test (hd (hd V1572))) (cons (hd V1573) ())) V1571) (cons (hd (tl (hd V1572))) (cons (hd (tl (tl (hd V1572)))) (tl V1572))) (cons (cons (shen.op1 (hd (hd V1572))) (cons (hd V1573) ())) (cons (cons (shen.op2 (hd (hd V1572))) (cons (hd V1573) ())) (tl V1573))) (shen.beta (hd V1572) (hd V1573) V1574))) ((and (cons? V1572) (cons? V1573)) (shen.triple-stack (cons (cons = (cons (hd V1572) (cons (hd V1573) ()))) V1571) (tl V1572) (tl V1573) V1574)) (true (simple-error "implementation error in shen.triple-stack"))))

(defun shen.rectify-test (V1577) (cond ((= () V1577) true) ((and (cons? V1577) (= () (tl V1577))) (hd V1577)) ((and (cons? V1577) (cons? (tl V1577))) (cons and (cons (hd V1577) (cons (shen.rectify-test (tl V1577)) ())))) (true (simple-error "implementation error in shen.rectify-test"))))

(defun shen.beta (V1587 V1588 V1589) (cond ((= V1587 V1589) V1588) ((and (cons? V1589) (and (= lambda (hd V1589)) (and (cons? (tl V1589)) (and (cons? (tl (tl V1589))) (and (= () (tl (tl (tl V1589)))) (= V1587 (hd (tl V1589)))))))) V1589) ((and (cons? V1589) (and (= let (hd V1589)) (and (cons? (tl V1589)) (and (cons? (tl (tl V1589))) (and (cons? (tl (tl (tl V1589)))) (and (= () (tl (tl (tl (tl V1589))))) (= V1587 (hd (tl V1589))))))))) (cons let (cons (hd (tl V1589)) (cons (shen.beta (hd (tl V1589)) V1588 (hd (tl (tl V1589)))) (tl (tl (tl V1589))))))) ((cons? V1589) (map (lambda V (shen.beta V1587 V1588 V)) V1589)) (true V1589)))

(defun shen.op1 (V1592) (cond ((= cons V1592) hd) ((= @s V1592) hdstr) ((= @p V1592) fst) ((= @v V1592) hdv) (true (simple-error "implementation error in shen.op1"))))

(defun shen.op2 (V1595) (cond ((= cons V1595) tl) ((= @s V1595) tlstr) ((= @p V1595) snd) ((= @v V1595) tlv) (true (simple-error "implementation error in shen.op2"))))

(defun shen.op-test (V1598) (cond ((= cons V1598) cons?) ((= @s V1598) shen.+string?) ((= @p V1598) tuple?) ((= @v V1598) shen.+vector?) (true (simple-error "implementation error in shen.op-test"))))

(defun shen.+string? (V1599) (cond ((= "" V1599) false) (true (string? V1599))))

(defun shen.+vector? (V1600) (cond ((= V1600 (vector 0)) false) (true (vector? V1600))))

(defun factorise (V1603) (cond ((= + V1603) (set shen.*factorise?* true)) ((= - V1603) (set shen.*factorise?* false)) (true (simple-error "factorise expects a + or a -
"))))

(defun shen.factorise-code (V1604) (cond ((and (cons? V1604) (and (= defun (hd V1604)) (and (cons? (tl V1604)) (and (cons? (tl (tl V1604))) (and (cons? (tl (tl (tl V1604)))) (and (cons? (hd (tl (tl (tl V1604))))) (and (= cond (hd (hd (tl (tl (tl V1604)))))) (and (= () (tl (tl (tl (tl V1604))))) (value shen.*factorise?*))))))))) (cons defun (cons (hd (tl V1604)) (cons (hd (tl (tl V1604))) (cons (shen.vertical (hd (tl (tl V1604))) (tl (hd (tl (tl (tl V1604))))) (cons shen.f-error (cons (hd (tl V1604)) ()))) ()))))) (true V1604)))

(defun shen.vertical (V1617 V1618 V1619) (cond ((and (cons? V1618) (and (cons? (hd V1618)) (and (= true (hd (hd V1618))) (and (cons? (tl (hd V1618))) (= () (tl (tl (hd V1618)))))))) (hd (tl (hd V1618)))) ((= () V1618) V1619) ((and (cons? V1618) (and (cons? (hd V1618)) (and (cons? (hd (hd V1618))) (and (= and (hd (hd (hd V1618)))) (and (cons? (tl (hd (hd V1618)))) (and (cons? (tl (tl (hd (hd V1618))))) (and (= () (tl (tl (tl (hd (hd V1618)))))) (and (cons? (tl (hd V1618))) (= () (tl (tl (hd V1618)))))))))))) (let Before+After (shen.split-cases (hd (tl (hd (hd V1618)))) V1618 ()) (shen.branch (hd (tl (hd (hd V1618)))) V1617 Before+After V1619))) ((and (cons? V1618) (and (cons? (hd V1618)) (and (cons? (tl (hd V1618))) (= () (tl (tl (hd V1618))))))) (cons if (cons (hd (hd V1618)) (cons (hd (tl (hd V1618))) (cons (shen.vertical V1617 (tl V1618) V1619) ()))))) (true (simple-error "implementation error in shen.vertical"))))

(defun shen.split-cases (V1624 V1625 V1626) (cond ((and (cons? V1625) (and (cons? (hd V1625)) (and (cons? (hd (hd V1625))) (and (= and (hd (hd (hd V1625)))) (and (cons? (tl (hd (hd V1625)))) (and (cons? (tl (tl (hd (hd V1625))))) (and (= () (tl (tl (tl (hd (hd V1625)))))) (and (cons? (tl (hd V1625))) (and (= () (tl (tl (hd V1625)))) (= V1624 (hd (tl (hd (hd V1625)))))))))))))) (shen.split-cases (hd (tl (hd (hd V1625)))) (tl V1625) (cons (cons (hd (tl (tl (hd (hd V1625))))) (tl (hd V1625))) V1626))) ((and (cons? V1625) (and (cons? (hd V1625)) (and (cons? (tl (hd V1625))) (and (= () (tl (tl (hd V1625)))) (= V1624 (hd (hd V1625))))))) (shen.split-cases (hd (hd V1625)) (tl V1625) (cons (cons true (tl (hd V1625))) V1626))) (true (cons (reverse V1626) (cons V1625 ())))))

(defun shen.branch (V1627 V1628 V1629 V1630) (cond ((and (cons? V1629) (and (cons? (tl V1629)) (= () (tl (tl V1629))))) (let Else (shen.else V1628 (hd (tl V1629)) V1630) (let Then (shen.then V1627 V1628 (hd V1629) Else) (cons if (cons V1627 (cons Then (cons Else ()))))))) (true (shen.f-error shen.branch))))

(defun shen.else (V1631 V1632 V1633) (let Else (shen.vertical V1631 V1632 V1633) (if (shen.inline? Else) Else (shen.procedure-call V1631 Else))))

(defun shen.procedure-call (V1634 V1635) (let F (gensym shen.else) (let Used (shen.remove-if-unused V1634 V1635) (let KL (cons defun (cons F (cons Used (cons V1635 ())))) (let EvalKL (eval-kl KL) (let Record (shen.record-kl F KL) (cons F Used)))))))

(defun shen.remove-if-unused (V1642 V1643) (cond ((= () V1642) ()) ((cons? V1642) (if (shen.occurs? (hd V1642) V1643) (cons (hd V1642) (shen.remove-if-unused (tl V1642) V1643)) (shen.remove-if-unused (tl V1642) V1643))) (true (simple-error "implementation error in shen.remove-if-unused"))))

(defun shen.then (V1644 V1645 V1646 V1647) (shen.horizontal (shen.selectors V1644 V1646) V1645 V1646 V1647))

(defun shen.horizontal (V1656 V1657 V1658 V1659) (cond ((= () V1656) (shen.vertical V1657 V1658 V1659)) ((cons? V1656) (let V (gensym V) (cons let (cons V (cons (hd V1656) (cons (shen.horizontal (tl V1656) (cons V V1657) (subst V (hd V1656) V1658) V1659) ())))))) (true (simple-error "implementation error in shen.horizontal"))))

(defun shen.selectors (V1664 V1665) (cond ((and (cons? V1664) (and (cons? (tl V1664)) (and (= () (tl (tl V1664))) (shen.constructor? (shen.op (hd V1664)))))) (let Op (shen.op (hd V1664)) (let Hd (cons (shen.op1 Op) (tl V1664)) (let Tl (cons (shen.op2 Op) (tl V1664)) (let RptedHd? (shen.rpted? Hd V1665) (let RptedTl? (shen.rpted? Tl V1665) (if (and RptedHd? RptedTl?) (cons Hd (cons Tl ())) (if RptedHd? (cons Hd ()) (if RptedTl? (cons Tl ()) ()))))))))) (true ())))

(defun shen.rpted? (V1666 V1667) (> (occurrences V1666 V1667) 1))

(defun shen.inline? (V1668) (cond ((cons? V1668) (and (atom? (hd V1668)) (shen.inline? (tl V1668)))) (true (atom? V1668))))

(defun shen.op (V1671) (cond ((= cons? V1671) cons) ((= shen.+string? V1671) @s) ((= shen.+vector? V1671) @v) ((= tuple? V1671) @p) (true shen.skip)))

