(defun shen.shen->kl (V6551) (let KL (shen.shen->kl-h V6551) (shen.record-and-evaluate KL)))

(defun shen.record-and-evaluate (V6552) (cond ((and (cons? V6552) (and (= defun (hd V6552)) (and (cons? (tl V6552)) (and (cons? (tl (tl V6552))) (and (cons? (tl (tl (tl V6552)))) (= () (tl (tl (tl (tl V6552)))))))))) (let SysfuncChk (if (shen.sysfunc? (hd (tl V6552))) (simple-error (shen.app (hd (tl V6552)) " is not a legitimate function name
" shen.a)) shen.skip) (let Arity (shen.store-arity (hd (tl V6552)) (length (hd (tl (tl V6552))))) (let Record (shen.record-kl (hd (tl V6552)) V6552) (let Eval (eval-kl V6552) (shen.fn-print (hd (tl V6552)))))))) (true V6552)))

(defun shen.shen->kl-h (V6553) (cond ((and (cons? V6553) (and (= define (hd V6553)) (cons? (tl V6553)))) (shen.shendef->kldef (hd (tl V6553)) (tl (tl V6553)))) ((and (cons? V6553) (and (= defun (hd V6553)) (and (cons? (tl V6553)) (and (cons? (tl (tl V6553))) (and (cons? (tl (tl (tl V6553)))) (= () (tl (tl (tl (tl V6553)))))))))) V6553) ((and (cons? V6553) (and (= type (hd V6553)) (and (cons? (tl V6553)) (and (cons? (tl (tl V6553))) (= () (tl (tl (tl V6553)))))))) (cons type (cons (hd (tl V6553)) (cons (shen.rcons_form (hd (tl (tl V6553)))) ())))) ((and (cons? V6553) (and (= input+ (hd V6553)) (and (cons? (tl V6553)) (and (cons? (tl (tl V6553))) (= () (tl (tl (tl V6553)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V6553))) (tl (tl V6553))))) ((cons? V6553) (map (lambda Z (shen.shen->kl-h Z)) V6553)) (true V6553)))

(defun shen.shendef->kldef (V6554 V6555) (compile (lambda X (shen.<define> X)) (cons V6554 V6555)))

(defun shen.<define> (V6556) (let Result (let Parseshen.<name> (shen.<name> V6556) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (if (shen.=hd? Parseshen.<name> {) (let News6416 (shen.tls Parseshen.<name>) (let Parseshen.<signature> (shen.<signature> News6416) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (shen.=hd? Parseshen.<signature> }) (let News6417 (shen.tls Parseshen.<signature>) (let Parseshen.<rules> (shen.<rules> News6417) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>)))))) (shen.parse-failure))))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<name> (shen.<name> V6556) (if (shen.parse-failure? Parseshen.<name>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<name>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (shen.shendef->kldef-h (shen.<-out Parseshen.<name>) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.shendef->kldef-h (V6557 V6558) (let Ps (map (lambda X (fst X)) V6558) (let Arity (shen.arity-chk V6557 Ps) (let FreeVarChk (map (lambda R (shen.free-var-chk V6557 R)) V6558) (let Unprotect (shen.unprotect V6558) (let KL (shen.factorise-code (shen.compile-to-kl V6557 Unprotect Arity)) KL))))))

(defun shen.unprotect (V6559) (cond ((tuple? V6559) (@p (shen.unprotect (fst V6559)) (shen.unprotect (snd V6559)))) ((and (cons? V6559) (and (= protect (hd V6559)) (and (cons? (tl V6559)) (= () (tl (tl V6559)))))) (shen.unprotect (hd (tl V6559)))) ((cons? V6559) (map (lambda Z (shen.unprotect Z)) V6559)) (true V6559)))

(defun shen.<name> (V6560) (let Result (if (shen.non-empty-stream? V6560) (let X (shen.hds V6560) (let News6419 (shen.tls V6560) (shen.comb (shen.in-> News6419) (if (and (symbol? X) (not (variable? X))) X (simple-error (shen.app X " is not a legitimate function name.
" shen.a)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<signature> (V6561) (let Result (if (shen.non-empty-stream? V6561) (let X (shen.hds V6561) (let News6421 (shen.tls V6561) (let Parseshen.<signature> (shen.<signature> News6421) (if (shen.parse-failure? Parseshen.<signature>) (shen.parse-failure) (if (not (element? X (cons { (cons } ())))) (shen.comb (shen.in-> Parseshen.<signature>) (cons X (shen.<-out Parseshen.<signature>))) (shen.parse-failure)))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V6561) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<rules> (V6562) (let Result (let Parseshen.<rule> (shen.<rule> V6562) (if (shen.parse-failure? Parseshen.<rule>) (shen.parse-failure) (let Parseshen.<rules> (shen.<rules> Parseshen.<rule>) (if (shen.parse-failure? Parseshen.<rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<rules>) (cons (shen.linearise (shen.<-out Parseshen.<rule>)) (shen.<-out Parseshen.<rules>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<!> (<!> V6562) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (shen.comb (shen.in-> Parse<!>) (if (empty? (shen.<-out Parse<!>)) () (simple-error (cn "Shen syntax error here:
 " (shen.app (shen.<-out Parse<!>) "
 ..." shen.r))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.linearise (V6565) (cond ((tuple? V6565) (shen.linearise-h (fst V6565) (fst V6565) () (snd V6565))) (true (simple-error "implementation error in shen.linearise"))))

(defun shen.linearise-h (V6578 V6579 V6580 V6581) (cond ((= () V6578) (@p V6579 V6581)) ((and (cons? V6578) (cons? (hd V6578))) (shen.linearise-h (append (hd V6578) (tl V6578)) V6579 V6580 V6581)) ((and (cons? V6578) (variable? (hd V6578))) (if (element? (hd V6578) V6580) (let Z (gensym V) (shen.linearise-h (tl V6578) (shen.rep-X (hd V6578) Z V6579) V6580 (cons where (cons (cons = (cons Z (cons (hd V6578) ()))) (cons V6581 ()))))) (shen.linearise-h (tl V6578) V6579 (cons (hd V6578) V6580) V6581))) ((cons? V6578) (shen.linearise-h (tl V6578) V6579 V6580 V6581)) (true (simple-error "implementation error in shen.linearise-h"))))

(defun shen.<rule> (V6582) (let Result (let Parseshen.<patterns> (shen.<patterns> V6582) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News6424 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News6424) (let Action (shen.hds News6424) (let News6425 (shen.tls News6424) (if (shen.=hd? News6425 where) (let News6426 (shen.tls News6425) (if (shen.non-empty-stream? News6426) (let Guard (shen.hds News6426) (let News6427 (shen.tls News6426) (shen.comb (shen.in-> News6427) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons Action ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V6582) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> ->) (let News6428 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News6428) (let Action (shen.hds News6428) (let News6429 (shen.tls News6428) (shen.comb (shen.in-> News6429) (@p (shen.<-out Parseshen.<patterns>) Action)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V6582) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News6430 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News6430) (let Action (shen.hds News6430) (let News6431 (shen.tls News6430) (if (shen.=hd? News6431 where) (let News6432 (shen.tls News6431) (if (shen.non-empty-stream? News6432) (let Guard (shen.hds News6432) (let News6433 (shen.tls News6432) (shen.comb (shen.in-> News6433) (@p (shen.<-out Parseshen.<patterns>) (cons where (cons Guard (cons (cons shen.choicepoint! (cons Action ())) ()))))))) (shen.parse-failure))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<patterns> (shen.<patterns> V6582) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (if (shen.=hd? Parseshen.<patterns> <-) (let News6434 (shen.tls Parseshen.<patterns>) (if (shen.non-empty-stream? News6434) (let Action (shen.hds News6434) (let News6435 (shen.tls News6434) (shen.comb (shen.in-> News6435) (@p (shen.<-out Parseshen.<patterns>) (cons shen.choicepoint! (cons Action ())))))) (shen.parse-failure))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<patterns> (V6583) (let Result (let Parseshen.<pattern> (shen.<pattern> V6583) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (let Parseshen.<patterns> (shen.<patterns> Parseshen.<pattern>) (if (shen.parse-failure? Parseshen.<patterns>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<patterns>) (cons (shen.<-out Parseshen.<pattern>) (shen.<-out Parseshen.<patterns>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V6583) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern> (V6584) (let Result (if (shen.ccons? V6584) (let SynCons (shen.comb (shen.hds V6584) (shen.<-out V6584)) (let Parseshen.<constructor> (shen.<constructor> SynCons) (if (shen.parse-failure? Parseshen.<constructor>) (shen.parse-failure) (let Parseshen.<pattern1> (shen.<pattern1> Parseshen.<constructor>) (if (shen.parse-failure? Parseshen.<pattern1>) (shen.parse-failure) (let Parseshen.<pattern2> (shen.<pattern2> Parseshen.<pattern1>) (if (shen.parse-failure? Parseshen.<pattern2>) (shen.parse-failure) (let Parseshen.<end> (shen.<end> Parseshen.<pattern2>) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V6584)) (cons (shen.<-out Parseshen.<constructor>) (cons (shen.<-out Parseshen.<pattern1>) (cons (shen.<-out Parseshen.<pattern2>) ()))))))))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.ccons? V6584) (let SynCons (shen.comb (shen.hds V6584) (shen.<-out V6584)) (if (shen.=hd? SynCons vector) (let News6438 (shen.tls SynCons) (if (shen.=hd? News6438 0) (let News6439 (shen.tls News6438) (let Parseshen.<end> (shen.<end> News6439) (if (shen.parse-failure? Parseshen.<end>) (shen.parse-failure) (shen.comb (shen.in-> (shen.tlstream V6584)) (cons vector (cons 0 ())))))) (shen.parse-failure))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V6584) (let X (shen.hds V6584) (let News6440 (shen.tls V6584) (if (cons? X) (shen.comb (shen.in-> News6440) (shen.constructor-error X)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parseshen.<simple-pattern> (shen.<simple-pattern> V6584) (if (shen.parse-failure? Parseshen.<simple-pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<simple-pattern>) (shen.<-out Parseshen.<simple-pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)) Result)))

(defun shen.<constructor> (V6585) (let Result (if (shen.non-empty-stream? V6585) (let C (shen.hds V6585) (let News6442 (shen.tls V6585) (if (shen.constructor? C) (shen.comb (shen.in-> News6442) C) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.constructor? (V6586) (element? V6586 (cons cons (cons @p (cons @s (cons @v ()))))))

(defun shen.constructor-error (V6587) (simple-error (shen.app V6587 " is not a legitimate constructor
" shen.r)))

(defun shen.<simple-pattern> (V6588) (let Result (if (shen.non-empty-stream? V6588) (let X (shen.hds V6588) (let News6444 (shen.tls V6588) (if (= X _) (shen.comb (shen.in-> News6444) (gensym Y)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.non-empty-stream? V6588) (let X (shen.hds V6588) (let News6445 (shen.tls V6588) (if (not (element? X (cons -> (cons <- ())))) (shen.comb (shen.in-> News6445) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<pattern1> (V6589) (let Result (let Parseshen.<pattern> (shen.<pattern> V6589) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<pattern2> (V6590) (let Result (let Parseshen.<pattern> (shen.<pattern> V6590) (if (shen.parse-failure? Parseshen.<pattern>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<pattern>) (shen.<-out Parseshen.<pattern>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.fn-print (V6591) (let V (absvector 2) (let Print (address-> V 0 shen.printF) (let Named (address-> Print 1 (@s "(" (@s "f" (@s "n" (@s " " (@s (str V6591) ")")))))) Named))))

(defun shen.printF (V6592) (<-address V6592 1))

(defun shen.arity-chk (V6597 V6598) (cond ((and (cons? V6598) (= () (tl V6598))) (length (hd V6598))) ((and (cons? V6598) (and (cons? (tl V6598)) (= (length (hd V6598)) (length (hd (tl V6598)))))) (shen.arity-chk V6597 (tl V6598))) (true (simple-error (cn "arity error in " (shen.app V6597 "
" shen.a))))))

(defun shen.free-var-chk (V6599 V6600) (cond ((tuple? V6600) (shen.free-variable-error-message V6599 (shen.find-free-vars (shen.extract-vars (fst V6600)) (snd V6600)))) (true (shen.f-error shen.free-var-chk))))

(defun shen.free-variable-error-message (V6601 V6602) (if (empty? V6602) shen.skip (do (pr (cn "free variables in " (shen.app V6601 ":" shen.a)) (stoutput)) (do (map (lambda X (pr (cn " " (shen.app X "" shen.a)) (stoutput))) V6602) (do (nl 1) (abort))))))

(defun shen.extract-vars (V6605) (cond ((variable? V6605) (cons V6605 ())) ((cons? V6605) (union (shen.extract-vars (hd V6605)) (shen.extract-vars (tl V6605)))) (true ())))

(defun shen.find-free-vars (V6610 V6611) (cond ((and (cons? V6611) (and (= protect (hd V6611)) (and (cons? (tl V6611)) (= () (tl (tl V6611)))))) ()) ((and (cons? V6611) (and (= let (hd V6611)) (and (cons? (tl V6611)) (and (cons? (tl (tl V6611))) (and (cons? (tl (tl (tl V6611)))) (= () (tl (tl (tl (tl V6611)))))))))) (union (shen.find-free-vars V6610 (hd (tl (tl V6611)))) (shen.find-free-vars (cons (hd (tl V6611)) V6610) (hd (tl (tl (tl V6611))))))) ((and (cons? V6611) (and (= lambda (hd V6611)) (and (cons? (tl V6611)) (and (cons? (tl (tl V6611))) (= () (tl (tl (tl V6611)))))))) (shen.find-free-vars (cons (hd (tl V6611)) V6610) (hd (tl (tl V6611))))) ((cons? V6611) (union (shen.find-free-vars V6610 (hd V6611)) (shen.find-free-vars V6610 (tl V6611)))) ((shen.free-variable? V6611 V6610) (cons V6611 ())) (true ())))

(defun shen.free-variable? (V6612 V6613) (and (variable? V6612) (not (element? V6612 V6613))))

(defun shen.record-kl (V6614 V6615) (put V6614 shen.source V6615 (value *property-vector*)))

(defun shen.compile-to-kl (V6616 V6617 V6618) (let Parameters (shen.parameters V6618) (let Body (shen.scan-body V6616 (shen.kl-body V6617 Parameters)) (let Defun (cons defun (cons V6616 (cons Parameters (cons (shen.cond-form Body) ())))) Defun))))

(defun shen.parameters (V6619) (cond ((= 0 V6619) ()) (true (cons (gensym V) (shen.parameters (- V6619 1))))))

(defun shen.cond-form (V6622) (cond ((and (cons? V6622) (and (cons? (hd V6622)) (and (= true (hd (hd V6622))) (and (cons? (tl (hd V6622))) (= () (tl (tl (hd V6622)))))))) (hd (tl (hd V6622)))) (true (cons cond V6622))))

(defun shen.scan-body (V6631 V6632) (cond ((= () V6632) (cons (cons true (cons (cons shen.f-error (cons V6631 ())) ())) ())) ((and (cons? V6632) (shen.choicepoint? (hd V6632))) (shen.choicepoint V6631 (gensym Freeze) (gensym Result) (hd V6632) (tl V6632))) ((and (cons? V6632) (and (cons? (hd V6632)) (and (= true (hd (hd V6632))) (and (cons? (tl (hd V6632))) (= () (tl (tl (hd V6632)))))))) (cons (hd V6632) ())) ((cons? V6632) (cons (hd V6632) (shen.scan-body V6631 (tl V6632)))) (true (simple-error "implementation error in shen.scan-body"))))

(defun shen.choicepoint? (V6639) (cond ((and (cons? V6639) (and (cons? (tl V6639)) (and (cons? (hd (tl V6639))) (and (= shen.choicepoint! (hd (hd (tl V6639)))) (and (cons? (tl (hd (tl V6639)))) (and (= () (tl (tl (hd (tl V6639))))) (= () (tl (tl V6639))))))))) true) (true false)))

(defun shen.choicepoint (V6655 V6656 V6657 V6658 V6659) (cond ((and (cons? V6658) (and (cons? (tl V6658)) (and (cons? (hd (tl V6658))) (and (cons? (tl (hd (tl V6658)))) (and (cons? (hd (tl (hd (tl V6658))))) (and (= fail-if (hd (hd (tl (hd (tl V6658)))))) (and (cons? (tl (hd (tl (hd (tl V6658)))))) (and (cons? (tl (tl (hd (tl (hd (tl V6658))))))) (and (= () (tl (tl (tl (hd (tl (hd (tl V6658)))))))) (and (= () (tl (tl (hd (tl V6658))))) (and (= () (tl (tl V6658))) (= V6655 (hd (tl (hd (tl (hd (tl V6658)))))))))))))))))) (cons (cons true (cons (cons let (cons V6656 (cons (cons freeze (cons (cons cond (shen.scan-body (hd (tl (hd (tl (hd (tl V6658)))))) V6659)) ())) (cons (cons if (cons (hd V6658) (cons (cons let (cons V6657 (cons (hd (tl (tl (hd (tl (hd (tl V6658))))))) (cons (cons if (cons (cons (hd (tl (hd (tl (hd (tl V6658)))))) (cons V6657 ())) (cons (cons thaw (cons V6656 ())) (cons V6657 ())))) ())))) (cons (cons thaw (cons V6656 ())) ())))) ())))) ())) ())) ((and (cons? V6658) (and (cons? (tl V6658)) (and (cons? (hd (tl V6658))) (and (cons? (tl (hd (tl V6658)))) (and (= () (tl (tl (hd (tl V6658))))) (= () (tl (tl V6658)))))))) (cons (cons true (cons (cons let (cons V6656 (cons (cons freeze (cons (cons cond (shen.scan-body V6655 V6659)) ())) (cons (cons if (cons (hd V6658) (cons (cons let (cons V6657 (cons (hd (tl (hd (tl V6658)))) (cons (cons if (cons (cons = (cons V6657 (cons (cons fail ()) ()))) (cons (cons thaw (cons V6656 ())) (cons V6657 ())))) ())))) (cons (cons thaw (cons V6656 ())) ())))) ())))) ())) ())) (true (simple-error "implementation error in shen.choicepoint"))))

(defun shen.rep-X (V6661 V6662 V6663) (cond ((= V6661 V6663) V6662) ((cons? V6663) (let Rep (shen.rep-X V6661 V6662 (hd V6663)) (if (= Rep (hd V6663)) (cons (hd V6663) (shen.rep-X V6661 V6662 (tl V6663))) (cons Rep (tl V6663))))) (true V6663)))

(defun shen.kl-body (V6664 V6665) (map (lambda R (shen.triple-stack () (fst R) V6665 (snd R))) V6664))

(defun shen.triple-stack (V6674 V6675 V6676 V6677) (cond ((and (= () V6675) (and (= () V6676) (and (cons? V6677) (and (= where (hd V6677)) (and (cons? (tl V6677)) (and (cons? (tl (tl V6677))) (= () (tl (tl (tl V6677)))))))))) (shen.triple-stack (cons (hd (tl V6677)) V6674) () () (hd (tl (tl V6677))))) ((and (= () V6675) (= () V6676)) (cons (shen.rectify-test (reverse V6674)) (cons V6677 ()))) ((and (cons? V6675) (and (cons? V6676) (variable? (hd V6675)))) (shen.triple-stack V6674 (tl V6675) (tl V6676) (shen.beta (hd V6675) (hd V6676) V6677))) ((and (cons? V6675) (and (cons? (hd V6675)) (and (cons? (tl (hd V6675))) (and (cons? (tl (tl (hd V6675)))) (and (= () (tl (tl (tl (hd V6675))))) (cons? V6676)))))) (shen.triple-stack (cons (cons (shen.op-test (hd (hd V6675))) (cons (hd V6676) ())) V6674) (cons (hd (tl (hd V6675))) (cons (hd (tl (tl (hd V6675)))) (tl V6675))) (cons (cons (shen.op1 (hd (hd V6675))) (cons (hd V6676) ())) (cons (cons (shen.op2 (hd (hd V6675))) (cons (hd V6676) ())) (tl V6676))) (shen.beta (hd V6675) (hd V6676) V6677))) ((and (cons? V6675) (cons? V6676)) (shen.triple-stack (cons (cons = (cons (hd V6675) (cons (hd V6676) ()))) V6674) (tl V6675) (tl V6676) V6677)) (true (simple-error "implementation error in shen.triple-stack"))))

(defun shen.rectify-test (V6680) (cond ((= () V6680) true) ((and (cons? V6680) (= () (tl V6680))) (hd V6680)) ((and (cons? V6680) (cons? (tl V6680))) (cons and (cons (hd V6680) (cons (shen.rectify-test (tl V6680)) ())))) (true (simple-error "implementation error in shen.rectify-test"))))

(defun shen.beta (V6690 V6691 V6692) (cond ((= V6690 V6692) V6691) ((and (cons? V6692) (and (= lambda (hd V6692)) (and (cons? (tl V6692)) (and (cons? (tl (tl V6692))) (and (= () (tl (tl (tl V6692)))) (= V6690 (hd (tl V6692)))))))) V6692) ((and (cons? V6692) (and (= let (hd V6692)) (and (cons? (tl V6692)) (and (cons? (tl (tl V6692))) (and (cons? (tl (tl (tl V6692)))) (and (= () (tl (tl (tl (tl V6692))))) (= V6690 (hd (tl V6692))))))))) (cons let (cons (hd (tl V6692)) (cons (shen.beta (hd (tl V6692)) V6691 (hd (tl (tl V6692)))) (tl (tl (tl V6692))))))) ((cons? V6692) (map (lambda V (shen.beta V6690 V6691 V)) V6692)) (true V6692)))

(defun shen.op1 (V6695) (cond ((= cons V6695) hd) ((= @s V6695) hdstr) ((= @p V6695) fst) ((= @v V6695) hdv) (true (simple-error "implementation error in shen.op1"))))

(defun shen.op2 (V6698) (cond ((= cons V6698) tl) ((= @s V6698) tlstr) ((= @p V6698) snd) ((= @v V6698) tlv) (true (simple-error "implementation error in shen.op2"))))

(defun shen.op-test (V6701) (cond ((= cons V6701) cons?) ((= @s V6701) shen.+string?) ((= @p V6701) tuple?) ((= @v V6701) shen.+vector?) (true (simple-error "implementation error in shen.op-test"))))

(defun shen.+string? (V6702) (cond ((= "" V6702) false) (true (string? V6702))))

(defun shen.+vector? (V6703) (cond ((= V6703 (vector 0)) false) (true (vector? V6703))))

(defun factorise (V6706) (cond ((= + V6706) (set shen.*factorise?* true)) ((= - V6706) (set shen.*factorise?* false)) (true (simple-error "factorise expects a + or a -
"))))

(defun shen.factorise-code (V6707) (cond ((and (cons? V6707) (and (= defun (hd V6707)) (and (cons? (tl V6707)) (and (cons? (tl (tl V6707))) (and (cons? (tl (tl (tl V6707)))) (and (cons? (hd (tl (tl (tl V6707))))) (and (= cond (hd (hd (tl (tl (tl V6707)))))) (and (= () (tl (tl (tl (tl V6707))))) (value shen.*factorise?*))))))))) (cons defun (cons (hd (tl V6707)) (cons (hd (tl (tl V6707))) (cons (shen.vertical (hd (tl (tl V6707))) (tl (hd (tl (tl (tl V6707))))) (cons shen.f-error (cons (hd (tl V6707)) ()))) ()))))) (true V6707)))

(defun shen.vertical (V6720 V6721 V6722) (cond ((and (cons? V6721) (and (cons? (hd V6721)) (and (= true (hd (hd V6721))) (and (cons? (tl (hd V6721))) (= () (tl (tl (hd V6721)))))))) (hd (tl (hd V6721)))) ((= () V6721) V6722) ((and (cons? V6721) (and (cons? (hd V6721)) (and (cons? (hd (hd V6721))) (and (= and (hd (hd (hd V6721)))) (and (cons? (tl (hd (hd V6721)))) (and (cons? (tl (tl (hd (hd V6721))))) (and (= () (tl (tl (tl (hd (hd V6721)))))) (and (cons? (tl (hd V6721))) (= () (tl (tl (hd V6721)))))))))))) (let Before+After (shen.split-cases (hd (tl (hd (hd V6721)))) V6721 ()) (shen.branch (hd (tl (hd (hd V6721)))) V6720 Before+After V6722))) ((and (cons? V6721) (and (cons? (hd V6721)) (and (cons? (tl (hd V6721))) (= () (tl (tl (hd V6721))))))) (cons if (cons (hd (hd V6721)) (cons (hd (tl (hd V6721))) (cons (shen.vertical V6720 (tl V6721) V6722) ()))))) (true (simple-error "implementation error in shen.vertical"))))

(defun shen.split-cases (V6727 V6728 V6729) (cond ((and (cons? V6728) (and (cons? (hd V6728)) (and (cons? (hd (hd V6728))) (and (= and (hd (hd (hd V6728)))) (and (cons? (tl (hd (hd V6728)))) (and (cons? (tl (tl (hd (hd V6728))))) (and (= () (tl (tl (tl (hd (hd V6728)))))) (and (cons? (tl (hd V6728))) (and (= () (tl (tl (hd V6728)))) (= V6727 (hd (tl (hd (hd V6728)))))))))))))) (shen.split-cases (hd (tl (hd (hd V6728)))) (tl V6728) (cons (cons (hd (tl (tl (hd (hd V6728))))) (tl (hd V6728))) V6729))) ((and (cons? V6728) (and (cons? (hd V6728)) (and (cons? (tl (hd V6728))) (and (= () (tl (tl (hd V6728)))) (= V6727 (hd (hd V6728))))))) (shen.split-cases (hd (hd V6728)) (tl V6728) (cons (cons true (tl (hd V6728))) V6729))) (true (cons (reverse V6729) (cons V6728 ())))))

(defun shen.branch (V6730 V6731 V6732 V6733) (cond ((and (cons? V6732) (and (cons? (tl V6732)) (= () (tl (tl V6732))))) (let Else (shen.else V6731 (hd (tl V6732)) V6733) (let Then (shen.then V6730 V6731 (hd V6732) Else) (cons if (cons V6730 (cons Then (cons Else ()))))))) (true (shen.f-error shen.branch))))

(defun shen.else (V6734 V6735 V6736) (let Else (shen.vertical V6734 V6735 V6736) (if (shen.inline? Else) Else (shen.procedure-call V6734 Else))))

(defun shen.procedure-call (V6737 V6738) (let F (gensym shen.else) (let Used (shen.remove-if-unused V6737 V6738) (let KL (cons defun (cons F (cons Used (cons V6738 ())))) (let EvalKL (eval-kl KL) (let Record (shen.record-kl F KL) (cons F Used)))))))

(defun shen.remove-if-unused (V6745 V6746) (cond ((= () V6745) ()) ((cons? V6745) (if (shen.occurs? (hd V6745) V6746) (cons (hd V6745) (shen.remove-if-unused (tl V6745) V6746)) (shen.remove-if-unused (tl V6745) V6746))) (true (simple-error "implementation error in shen.remove-if-unused"))))

(defun shen.then (V6747 V6748 V6749 V6750) (shen.horizontal (shen.selectors V6747 V6749) V6748 V6749 V6750))

(defun shen.horizontal (V6759 V6760 V6761 V6762) (cond ((= () V6759) (shen.vertical V6760 V6761 V6762)) ((cons? V6759) (let V (gensym V) (cons let (cons V (cons (hd V6759) (cons (shen.horizontal (tl V6759) (cons V V6760) (subst V (hd V6759) V6761) V6762) ())))))) (true (simple-error "implementation error in shen.horizontal"))))

(defun shen.selectors (V6767 V6768) (cond ((and (cons? V6767) (and (cons? (tl V6767)) (and (= () (tl (tl V6767))) (shen.constructor? (shen.op (hd V6767)))))) (let Op (shen.op (hd V6767)) (let Hd (cons (shen.op1 Op) (tl V6767)) (let Tl (cons (shen.op2 Op) (tl V6767)) (let RptedHd? (shen.rpted? Hd V6768) (let RptedTl? (shen.rpted? Tl V6768) (if (and RptedHd? RptedTl?) (cons Hd (cons Tl ())) (if RptedHd? (cons Hd ()) (if RptedTl? (cons Tl ()) ()))))))))) (true ())))

(defun shen.rpted? (V6769 V6770) (> (occurrences V6769 V6770) 1))

(defun shen.inline? (V6771) (cond ((cons? V6771) (and (atom? (hd V6771)) (shen.inline? (tl V6771)))) (true (atom? V6771))))

(defun shen.op (V6774) (cond ((= cons? V6774) cons) ((= shen.+string? V6774) @s) ((= shen.+vector? V6774) @v) ((= tuple? V6774) @p) (true shen.skip)))

