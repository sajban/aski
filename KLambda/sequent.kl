(defun shen.<datatype> (V8230) (let Result (if (shen.non-empty-stream? V8230) (let D (shen.hds V8230) (let News8091 (shen.tls V8230) (let Parseshen.<datatype-rules> (shen.<datatype-rules> News8091) (if (shen.parse-failure? Parseshen.<datatype-rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<datatype-rules>) (let Prolog (shen.rules->prolog D (shen.<-out Parseshen.<datatype-rules>)) (shen.remember-datatype D (fn D)))))))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<datatype-rules> (V8231) (let Result (let Parseshen.<datatype-rule> (shen.<datatype-rule> V8231) (if (shen.parse-failure? Parseshen.<datatype-rule>) (shen.parse-failure) (let Parseshen.<datatype-rules> (shen.<datatype-rules> Parseshen.<datatype-rule>) (if (shen.parse-failure? Parseshen.<datatype-rules>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<datatype-rules>) (append (shen.<-out Parseshen.<datatype-rule>) (shen.<-out Parseshen.<datatype-rules>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<!> (<!> V8231) (if (shen.parse-failure? Parse<!>) (shen.parse-failure) (shen.comb (shen.in-> Parse<!>) (if (empty? (shen.<-out Parse<!>)) () (simple-error (cn "datatype syntax error here:
 " (shen.app (shen.<-out Parse<!>) "
 ..." shen.r))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<datatype-rule> (V8232) (let Result (let Parseshen.<single> (shen.<single> V8232) (if (shen.parse-failure? Parseshen.<single>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<single>) (shen.<-out Parseshen.<single>)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<double> (shen.<double> V8232) (if (shen.parse-failure? Parseshen.<double>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<double>) (shen.<-out Parseshen.<double>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<single> (V8233) (let Result (let Parseshen.<sides> (shen.<sides> V8233) (if (shen.parse-failure? Parseshen.<sides>) (shen.parse-failure) (let Parseshen.<prems> (shen.<prems> Parseshen.<sides>) (if (shen.parse-failure? Parseshen.<prems>) (shen.parse-failure) (let Parseshen.<sng> (shen.<sng> Parseshen.<prems>) (if (shen.parse-failure? Parseshen.<sng>) (shen.parse-failure) (let Parseshen.<conc> (shen.<conc> Parseshen.<sng>) (if (shen.parse-failure? Parseshen.<conc>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<conc>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sc>) (cons (cons (shen.<-out Parseshen.<sides>) (cons (shen.<-out Parseshen.<prems>) (cons (shen.<-out Parseshen.<conc>) ()))) ())))))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<double> (V8234) (let Result (let Parseshen.<sides> (shen.<sides> V8234) (if (shen.parse-failure? Parseshen.<sides>) (shen.parse-failure) (let Parseshen.<formulae> (shen.<formulae> Parseshen.<sides>) (if (shen.parse-failure? Parseshen.<formulae>) (shen.parse-failure) (let Parseshen.<dbl> (shen.<dbl> Parseshen.<formulae>) (if (shen.parse-failure? Parseshen.<dbl>) (shen.parse-failure) (let Parseshen.<formula> (shen.<formula> Parseshen.<dbl>) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<formula>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sc>) (shen.lr-rule (shen.<-out Parseshen.<sides>) (shen.<-out Parseshen.<formulae>) (cons () (cons (shen.<-out Parseshen.<formula>) ())))))))))))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<formulae> (V8235) (let Result (let Parseshen.<formula> (shen.<formula> V8235) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<formula>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (let Parseshen.<formulae> (shen.<formulae> Parseshen.<sc>) (if (shen.parse-failure? Parseshen.<formulae>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<formulae>) (cons (cons () (cons (shen.<-out Parseshen.<formula>) ())) (shen.<-out Parseshen.<formulae>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<formula> (shen.<formula> V8235) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<formula>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sc>) (cons (cons () (cons (shen.<-out Parseshen.<formula>) ())) ())))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<conc> (V8236) (let Result (let Parseshen.<ass> (shen.<ass> V8236) (if (shen.parse-failure? Parseshen.<ass>) (shen.parse-failure) (if (shen.=hd? Parseshen.<ass> >>) (let News8098 (shen.tls Parseshen.<ass>) (let Parseshen.<formula> (shen.<formula> News8098) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<formula>) (cons (shen.<-out Parseshen.<ass>) (cons (shen.<-out Parseshen.<formula>) ())))))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<formula> (shen.<formula> V8236) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<formula>) (cons () (cons (shen.<-out Parseshen.<formula>) ()))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<prems> (V8237) (let Result (let Parseshen.<prem> (shen.<prem> V8237) (if (shen.parse-failure? Parseshen.<prem>) (shen.parse-failure) (let Parseshen.<sc> (shen.<sc> Parseshen.<prem>) (if (shen.parse-failure? Parseshen.<sc>) (shen.parse-failure) (let Parseshen.<prems> (shen.<prems> Parseshen.<sc>) (if (shen.parse-failure? Parseshen.<prems>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<prems>) (cons (shen.<-out Parseshen.<prem>) (shen.<-out Parseshen.<prems>))))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V8237) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<prem> (V8238) (let Result (if (shen.=hd? V8238 !) (let News8101 (shen.tls V8238) (shen.comb (shen.in-> News8101) !)) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (let Parseshen.<ass> (shen.<ass> V8238) (if (shen.parse-failure? Parseshen.<ass>) (shen.parse-failure) (if (shen.=hd? Parseshen.<ass> >>) (let News8102 (shen.tls Parseshen.<ass>) (let Parseshen.<formula> (shen.<formula> News8102) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<formula>) (cons (shen.<-out Parseshen.<ass>) (cons (shen.<-out Parseshen.<formula>) ())))))) (shen.parse-failure)))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<formula> (shen.<formula> V8238) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<formula>) (cons () (cons (shen.<-out Parseshen.<formula>) ()))))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<ass> (V8239) (let Result (let Parseshen.<formula> (shen.<formula> V8239) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (let Parseshen.<iscomma> (shen.<iscomma> Parseshen.<formula>) (if (shen.parse-failure? Parseshen.<iscomma>) (shen.parse-failure) (let Parseshen.<ass> (shen.<ass> Parseshen.<iscomma>) (if (shen.parse-failure? Parseshen.<ass>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<ass>) (cons (shen.<-out Parseshen.<formula>) (shen.<-out Parseshen.<ass>))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<formula> (shen.<formula> V8239) (if (shen.parse-failure? Parseshen.<formula>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<formula>) (cons (shen.<-out Parseshen.<formula>) ())))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V8239) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.<iscomma> (V8240) (let Result (if (shen.non-empty-stream? V8240) (let X (shen.hds V8240) (let News8105 (shen.tls V8240) (if (= X (intern ",")) (shen.comb (shen.in-> News8105) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<formula> (V8241) (let Result (let Parseshen.<expr> (shen.<expr> V8241) (if (shen.parse-failure? Parseshen.<expr>) (shen.parse-failure) (let Parseshen.<iscolon> (shen.<iscolon> Parseshen.<expr>) (if (shen.parse-failure? Parseshen.<iscolon>) (shen.parse-failure) (let Parseshen.<type> (shen.<type> Parseshen.<iscolon>) (if (shen.parse-failure? Parseshen.<type>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<type>) (cons (shen.curry (shen.<-out Parseshen.<expr>)) (cons (intern ":") (cons (shen.rectify-type (shen.<-out Parseshen.<type>)) ())))))))))) (if (shen.parse-failure? Result) (let Result (let Parseshen.<expr> (shen.<expr> V8241) (if (shen.parse-failure? Parseshen.<expr>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<expr>) (shen.<-out Parseshen.<expr>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<iscolon> (V8242) (let Result (if (shen.non-empty-stream? V8242) (let X (shen.hds V8242) (let News8108 (shen.tls V8242) (if (= X (intern ":")) (shen.comb (shen.in-> News8108) shen.skip) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<sides> (V8243) (let Result (let Parseshen.<side> (shen.<side> V8243) (if (shen.parse-failure? Parseshen.<side>) (shen.parse-failure) (let Parseshen.<sides> (shen.<sides> Parseshen.<side>) (if (shen.parse-failure? Parseshen.<sides>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<sides>) (cons (shen.<-out Parseshen.<side>) (shen.<-out Parseshen.<sides>))))))) (if (shen.parse-failure? Result) (let Result (let Parse<e> (<e> V8243) (if (shen.parse-failure? Parse<e>) (shen.parse-failure) (shen.comb (shen.in-> Parse<e>) ()))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)))

(defun shen.<side> (V8244) (let Result (if (shen.=hd? V8244 if) (let News8111 (shen.tls V8244) (if (shen.non-empty-stream? News8111) (let P (shen.hds News8111) (let News8112 (shen.tls News8111) (shen.comb (shen.in-> News8112) (cons if (cons P ()))))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.=hd? V8244 let) (let News8113 (shen.tls V8244) (if (shen.non-empty-stream? News8113) (let X (shen.hds News8113) (let News8114 (shen.tls News8113) (if (shen.non-empty-stream? News8114) (let Y (shen.hds News8114) (let News8115 (shen.tls News8114) (shen.comb (shen.in-> News8115) (cons let (cons X (cons Y ())))))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (let Result (if (shen.=hd? V8244 shen.let!) (let News8116 (shen.tls V8244) (if (shen.non-empty-stream? News8116) (let X (shen.hds News8116) (let News8117 (shen.tls News8116) (if (shen.non-empty-stream? News8117) (let Y (shen.hds News8117) (let News8118 (shen.tls News8117) (shen.comb (shen.in-> News8118) (cons shen.let! (cons X (cons Y ())))))) (shen.parse-failure)))) (shen.parse-failure))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)) Result)) Result)))

(defun shen.lr-rule (V8251 V8252 V8253) (cond ((and (cons? V8253) (and (= () (hd V8253)) (and (cons? (tl V8253)) (= () (tl (tl V8253)))))) (let P (gensym P) (let LConc (cons (tl V8253) (cons P ())) (let LPrem (cons (shen.coll-formulae V8252) (cons P ())) (let Left (cons V8251 (cons (cons LPrem ()) (cons LConc ()))) (let Right (cons V8251 (cons V8252 (cons V8253 ()))) (cons Right (cons Left ())))))))) (true (simple-error "implementation error in shen.lr-rule"))))

(defun shen.coll-formulae (V8256) (cond ((= () V8256) ()) ((and (cons? V8256) (and (cons? (hd V8256)) (and (= () (hd (hd V8256))) (and (cons? (tl (hd V8256))) (= () (tl (tl (hd V8256)))))))) (cons (hd (tl (hd V8256))) (shen.coll-formulae (tl V8256)))) (true (simple-error "implementation error in shen.coll-formulae"))))

(defun shen.<expr> (V8257) (let Result (if (shen.non-empty-stream? V8257) (let X (shen.hds V8257) (let News8120 (shen.tls V8257) (if (not (shen.key-in-sequent-calculus? X)) (shen.comb (shen.in-> News8120) (macroexpand X)) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.key-in-sequent-calculus? (V8258) (or (element? V8258 (cons >> (cons (intern ";") (cons (intern ",") (cons (intern ":") (cons <-- ())))))) (or (shen.sng? V8258) (shen.dbl? V8258))))

(defun shen.<type> (V8259) (let Result (let Parseshen.<expr> (shen.<expr> V8259) (if (shen.parse-failure? Parseshen.<expr>) (shen.parse-failure) (shen.comb (shen.in-> Parseshen.<expr>) (shen.<-out Parseshen.<expr>)))) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<dbl> (V8260) (let Result (if (shen.non-empty-stream? V8260) (let X (shen.hds V8260) (let News8123 (shen.tls V8260) (if (shen.dbl? X) (shen.comb (shen.in-> News8123) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.<sng> (V8261) (let Result (if (shen.non-empty-stream? V8261) (let X (shen.hds V8261) (let News8125 (shen.tls V8261) (if (shen.sng? X) (shen.comb (shen.in-> News8125) X) (shen.parse-failure)))) (shen.parse-failure)) (if (shen.parse-failure? Result) (shen.parse-failure) Result)))

(defun shen.sng? (V8262) (and (symbol? V8262) (shen.sng-h? (str V8262))))

(defun shen.sng-h? (V8265) (cond ((= "___" V8265) true) ((and (shen.+string? V8265) (= "_" (hdstr V8265))) (shen.sng-h? (tlstr V8265))) (true false)))

(defun shen.dbl? (V8266) (and (symbol? V8266) (shen.dbl-h? (str V8266))))

(defun shen.dbl-h? (V8269) (cond ((= "===" V8269) true) ((and (shen.+string? V8269) (= "=" (hdstr V8269))) (shen.dbl-h? (tlstr V8269))) (true false)))

(defun shen.remember-datatype (V8270 V8271) (do (set shen.*datatypes* (shen.assoc-> V8270 V8271 (value shen.*datatypes*))) (do (set shen.*alldatatypes* (shen.assoc-> V8270 V8271 (value shen.*alldatatypes*))) V8270)))

(defun shen.rules->prolog (V8272 V8273) (let Clauses (mapcan (lambda Rule (shen.rule->clause Rule)) V8273) (eval (cons defprolog (cons V8272 Clauses)))))

(defun shen.rule->clause (V8276) (cond ((and (cons? V8276) (and (cons? (tl V8276)) (and (cons? (tl (tl V8276))) (and (cons? (hd (tl (tl V8276)))) (and (cons? (tl (hd (tl (tl V8276))))) (and (= () (tl (tl (hd (tl (tl V8276)))))) (= () (tl (tl (tl V8276)))))))))) (let Constraints (shen.extract-vars V8276) (let HypVs (append (shen.nvars (length (hd (hd (tl (tl V8276)))))) (cons Delta ())) (let Active (shen.extract-vars (hd (tl (hd (tl (tl V8276)))))) (let Head (shen.compile-consequent (hd (tl (hd (tl (tl V8276))))) HypVs) (let Goals (shen.goals Constraints (hd (hd (tl (tl V8276)))) (hd V8276) (hd (tl V8276)) HypVs Active) (append Head (append (cons <-- ()) (append Goals (cons (intern ";") ())))))))))) (true (simple-error "implementation error in shen.rule->clause"))))

(defun shen.compile-consequent (V8283 V8284) (cond ((cons? V8284) (cons (shen.optimise-typing V8283) (cons (hd V8284) ()))) (true (simple-error "implementation error in shen.compile-consequent"))))

(defun shen.nvars (V8285) (cond ((= 0 V8285) ()) (true (cons (gensym V) (shen.nvars (- V8285 1))))))

(defun shen.optimise-typing (V8286) (cond ((and (cons? V8286) (and (cons? (tl V8286)) (and (cons? (tl (tl V8286))) (and (= () (tl (tl (tl V8286)))) (= (hd (tl V8286)) (intern ":")))))) (cons - (cons (shen.cons-form-with-modes (cons (hd V8286) (cons (hd (tl V8286)) (cons (cons + (tl (tl V8286))) ())))) ()))) (true (cons + (cons (shen.cons-form-with-modes V8286) ())))))

(defun shen.cons-form-with-modes (V8287) (cond ((and (cons? V8287) (and (= - (hd V8287)) (and (cons? (tl V8287)) (= () (tl (tl V8287)))))) (cons - (cons (shen.cons-form-with-modes (hd (tl V8287))) ()))) ((and (cons? V8287) (and (= + (hd V8287)) (and (cons? (tl V8287)) (= () (tl (tl V8287)))))) (cons + (cons (shen.cons-form-with-modes (hd (tl V8287))) ()))) ((and (cons? V8287) (and (= mode (hd V8287)) (and (cons? (tl V8287)) (and (cons? (tl (tl V8287))) (= () (tl (tl (tl V8287)))))))) (cons (hd (tl (tl V8287))) (cons (shen.cons-form-with-modes (hd (tl V8287))) ()))) ((and (cons? V8287) (and (= bar! (hd V8287)) (and (cons? (tl V8287)) (= () (tl (tl V8287)))))) (hd (tl V8287))) ((cons? V8287) (cons cons (cons (shen.cons-form-with-modes (hd V8287)) (cons (shen.cons-form-with-modes (tl V8287)) ())))) (true V8287)))

(defun shen.goals (V8288 V8289 V8290 V8291 V8292 V8293) (let GoalsAs (shen.compile-assumptions V8289 V8288 V8292 V8293) (let GoalsS (shen.compile-side-conditions V8290) (let GoalsP (shen.compile-premises V8291 V8292) (append GoalsAs (append GoalsS GoalsP))))))

(defun shen.compile-assumptions (V8308 V8309 V8310 V8311) (cond ((= () V8308) ()) ((and (cons? V8308) (and (cons? V8310) (cons? (tl V8310)))) (let NewActive (append (shen.extract-vars (hd V8308)) V8311) (cons (shen.compile-assumption (hd V8308) (hd V8310) (hd (tl V8310)) V8309 V8311) (shen.compile-assumptions (tl V8308) V8309 (tl V8310) NewActive)))) (true (simple-error "implementation error in shen.compile-assumptions"))))

(defun shen.compile-assumption (V8312 V8313 V8314 V8315 V8316) (let F (gensym shen.search) (let Compile (shen.compile-search-procedure F V8312 V8313 V8314 V8315 V8316) (cons F (cons V8313 (cons () (cons V8314 V8315)))))))

(defun shen.compile-search-procedure (V8317 V8318 V8319 V8320 V8321 V8322) (let Past (gensym Previous) (let Base (shen.foundit! V8318 V8319 Past V8320 V8321 V8322) (let Recursive (shen.keep-looking V8317 V8319 Past V8320 V8321) (eval (cons defprolog (cons V8317 (append Base Recursive))))))))

(defun shen.foundit! (V8323 V8324 V8325 V8326 V8327 V8328) (let Passive (shen.passive V8323 V8328) (let Table (shen.tabulate-passive Passive) (let Head (shen.head-foundit! V8323 V8324 V8325 V8326 V8327 Table) (let Body (shen.body-foundit! V8324 V8325 V8326 Table) (append Head (append (cons <-- ()) (append Body (cons (intern ";") ())))))))))

(defun shen.keep-looking (V8329 V8330 V8331 V8332 V8333) (let X (gensym V) (let Head (cons (cons - (cons (cons cons (cons X (cons V8330 ()))) ())) (cons V8331 (cons V8332 V8333))) (let Body (cons (cons V8329 (cons V8330 (cons (cons cons (cons X (cons V8331 ()))) (cons V8332 V8333)))) ()) (append Head (append (cons <-- ()) (append Body (cons (intern ";") ()))))))))

(defun shen.passive (V8338 V8339) (cond ((cons? V8338) (union (shen.passive (hd V8338) V8339) (shen.passive (tl V8338) V8339))) ((shen.passive? V8338 V8339) (cons V8338 ())) (true ())))

(defun shen.passive? (V8340 V8341) (and (not (element? V8340 V8341)) (variable? V8340)))

(defun shen.tabulate-passive (V8342) (map (lambda X (cons X (gensym V))) V8342))

(defun shen.head-foundit! (V8343 V8344 V8345 V8346 V8347 V8348) (let Optimise (shen.optimise-passive V8347 V8348) (cons (cons - (cons (cons cons (cons (shen.optimise-typing V8343) (cons V8344 ()))) ())) (cons V8345 (cons V8346 Optimise)))))

(defun shen.optimise-passive (V8349 V8350) (map (lambda C (shen.optimise-passive-h C V8350)) V8349))

(defun shen.optimise-passive-h (V8351 V8352) (let Entry (assoc V8351 V8352) (if (empty? Entry) V8351 (tl Entry))))

(defun shen.body-foundit! (V8361 V8362 V8363 V8364) (cond ((= () V8364) (cons (cons bind (cons V8363 (cons (cons append (cons (cons 1 (cons V8362 ())) (cons (cons 1 (cons V8361 ())) ()))) ()))) ())) ((and (cons? V8364) (cons? (hd V8364))) (cons (cons bind (cons (tl (hd V8364)) (cons (hd (hd V8364)) ()))) (shen.body-foundit! V8361 V8362 V8363 (tl V8364)))) (true (simple-error "implementation error in shen.body-foundit!"))))

(defun shen.compile-side-conditions (V8365) (map (lambda X (shen.compile-side-condition X)) V8365))

(defun shen.compile-side-condition (V8368) (cond ((and (cons? V8368) (and (= let (hd V8368)) (and (cons? (tl V8368)) (and (cons? (tl (tl V8368))) (= () (tl (tl (tl V8368)))))))) (cons is (tl V8368))) ((and (cons? V8368) (and (= shen.let! (hd V8368)) (and (cons? (tl V8368)) (and (cons? (tl (tl V8368))) (= () (tl (tl (tl V8368)))))))) (cons is! (tl V8368))) ((and (cons? V8368) (and (= if (hd V8368)) (and (cons? (tl V8368)) (= () (tl (tl V8368)))))) (cons when (tl V8368))) (true (simple-error "implementation error in shen.compile-side-condition"))))

(defun shen.compile-premises (V8369 V8370) (let Hyp (hd (reverse V8370)) (map (lambda X (shen.compile-premise X Hyp)) V8369)))

(defun shen.compile-premise (V8377 V8378) (cond ((= ! V8377) !) ((and (cons? V8377) (and (cons? (tl V8377)) (= () (tl (tl V8377))))) (shen.compile-premise-h (reverse (hd V8377)) (hd (tl V8377)) V8378)) (true (simple-error "implementation error in shen.premise"))))

(defun shen.compile-premise-h (V8385 V8386 V8387) (cond ((= () V8385) (cons shen.system-S (cons (shen.cons-form-no-modes V8386) (cons V8387 ())))) ((cons? V8385) (shen.compile-premise-h (tl V8385) V8386 (cons cons (cons (shen.cons-form-no-modes (hd V8385)) (cons V8387 ()))))) (true (simple-error "implementation error in shen.compile-premise-h"))))

(defun shen.cons-form-no-modes (V8388) (cond ((and (cons? V8388) (and (= bar! (hd V8388)) (and (cons? (tl V8388)) (= () (tl (tl V8388)))))) (hd (tl V8388))) ((cons? V8388) (cons cons (cons (shen.cons-form-no-modes (hd V8388)) (cons (shen.cons-form-no-modes (tl V8388)) ())))) (true V8388)))

(defun preclude (V8389) (let InternTypes (map (lambda X (shen.intern-type X)) V8389) (let Datatypes (value shen.*datatypes*) (let Remove (shen.remove-datatypes InternTypes Datatypes) (let NewDatatypes (set shen.*datatypes* Remove) (shen.show-datatypes NewDatatypes))))))

(defun shen.remove-datatypes (V8394 V8395) (cond ((= () V8394) V8395) ((cons? V8394) (shen.remove-datatypes (tl V8394) (shen.unassoc (hd V8394) V8395))) (true (simple-error "implementation error in shen.remove-datatypes"))))

(defun shen.unassoc (V8405 V8406) (cond ((= () V8406) ()) ((and (cons? V8406) (and (cons? (hd V8406)) (= V8405 (hd (hd V8406))))) (tl V8406)) ((cons? V8406) (cons (hd V8406) (shen.unassoc V8405 (tl V8406)))) (true (simple-error "implementation error in shen.unassoc"))))

(defun shen.show-datatypes (V8407) (map (lambda X (hd X)) V8407))

(defun include (V8408) (let InternTypes (map (lambda X (shen.intern-type X)) V8408) (let Remember (map (lambda D (shen.remember-datatype D (fn D))) InternTypes) (let Datatypes (value shen.*datatypes*) (shen.show-datatypes Datatypes)))))

(defun preclude-all-but (V8409) (let Initialise (set shen.*datatypes* ()) (let InternTypes (map (lambda X (shen.intern-type X)) V8409) (let NewDatatypes (map (lambda D (shen.remember-datatype D (fn D))) InternTypes) (shen.show-datatypes (value shen.*datatypes*))))))

(defun include-all-but (V8410) (let InternTypes (map (lambda X (shen.intern-type X)) V8410) (let AllDatatypes (value shen.*alldatatypes*) (let Datatypes (set shen.*datatypes* (shen.remove-datatypes InternTypes AllDatatypes)) (shen.show-datatypes Datatypes)))))

